   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB13:
  15               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "action_layer.h"
  24:tmk_core/common/action.c **** #include "action_tapping.h"
  25:tmk_core/common/action.c **** #include "action_macro.h"
  26:tmk_core/common/action.c **** #include "action_util.h"
  27:tmk_core/common/action.c **** #include "action.h"
  28:tmk_core/common/action.c **** #include "wait.h"
  29:tmk_core/common/action.c **** 
  30:tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
  31:tmk_core/common/action.c **** #    include "backlight.h"
  32:tmk_core/common/action.c **** #endif
  33:tmk_core/common/action.c **** 
  34:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  35:tmk_core/common/action.c **** #    include "debug.h"
  36:tmk_core/common/action.c **** #else
  37:tmk_core/common/action.c **** #    include "nodebug.h"
  38:tmk_core/common/action.c **** #endif
  39:tmk_core/common/action.c **** 
  40:tmk_core/common/action.c **** int tp_buttons;
  41:tmk_core/common/action.c **** 
  42:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  43:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  44:tmk_core/common/action.c **** #endif
  45:tmk_core/common/action.c **** 
  46:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  47:tmk_core/common/action.c **** #    include <fauxclicky.h>
  48:tmk_core/common/action.c **** #endif
  49:tmk_core/common/action.c **** 
  50:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  51:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  54:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  55:tmk_core/common/action.c **** #endif
  56:tmk_core/common/action.c **** /** \brief Called to execute an action.
  57:tmk_core/common/action.c ****  *
  58:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  59:tmk_core/common/action.c ****  */
  60:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  16               		.loc 1 60 36 view -0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  61:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  48               		.loc 1 61 5 view .LVU1
  62:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  63:tmk_core/common/action.c ****         dprint("EVENT: ");
  64:tmk_core/common/action.c ****         debug_event(event);
  65:tmk_core/common/action.c ****         dprintln();
  49               		.loc 1 65 19 view .LVU2
  66:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  67:tmk_core/common/action.c ****         retro_tapping_counter++;
  68:tmk_core/common/action.c **** #endif
  69:tmk_core/common/action.c ****     }
  70:tmk_core/common/action.c **** 
  71:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  72:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  73:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  74:tmk_core/common/action.c ****     }
  75:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  76:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  77:tmk_core/common/action.c ****     }
  78:tmk_core/common/action.c ****     fauxclicky_check();
  79:tmk_core/common/action.c **** #endif
  80:tmk_core/common/action.c **** 
  81:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  82:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  83:tmk_core/common/action.c ****         process_hand_swap(&event);
  84:tmk_core/common/action.c ****     }
  85:tmk_core/common/action.c **** #endif
  86:tmk_core/common/action.c **** 
  87:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  50               		.loc 1 87 5 view .LVU3
  51               		.loc 1 87 17 is_stmt 0 view .LVU4
  52 001e 1E82      		std Y+6,__zero_reg__
  53 0020 1D82      		std Y+5,__zero_reg__
  54 0022 85E0      		ldi r24,lo8(5)
  55 0024 FE01      		movw r30,r28
  56 0026 3796      		adiw r30,7
  57 0028 DE01      		movw r26,r28
  58 002a 1196      		adiw r26,1
  59               		0:
  60 002c 0190      		ld r0,Z+
  61 002e 0D92      		st X+,r0
  62 0030 8A95      		dec r24
  63 0032 01F4      		brne 0b
  88:tmk_core/common/action.c **** 
  89:tmk_core/common/action.c **** #if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  90:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  91:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  92:tmk_core/common/action.c ****     }
  93:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  94:tmk_core/common/action.c ****         clear_oneshot_mods();
  95:tmk_core/common/action.c ****     }
  96:tmk_core/common/action.c **** #endif
  97:tmk_core/common/action.c **** 
  98:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
  99:tmk_core/common/action.c ****     action_tapping_process(record);
  64               		.loc 1 99 5 is_stmt 1 view .LVU5
  65 0034 4981      		ldd r20,Y+1
  66               	.LVL1:
  67               		.loc 1 99 5 is_stmt 0 view .LVU6
  68 0036 5A81      		ldd r21,Y+2
  69               	.LVL2:
  70               		.loc 1 99 5 view .LVU7
  71 0038 6B81      		ldd r22,Y+3
  72 003a 7C81      		ldd r23,Y+4
  73 003c 8D81      		ldd r24,Y+5
  74 003e 9E81      		ldd r25,Y+6
  75               	/* epilogue start */
 100:tmk_core/common/action.c **** #else
 101:tmk_core/common/action.c ****     process_record(&record);
 102:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 103:tmk_core/common/action.c ****         dprint("processed: ");
 104:tmk_core/common/action.c ****         debug_record(record);
 105:tmk_core/common/action.c ****         dprintln();
 106:tmk_core/common/action.c ****     }
 107:tmk_core/common/action.c **** #endif
 108:tmk_core/common/action.c **** }
  76               		.loc 1 108 1 view .LVU8
  77 0040 2B96      		adiw r28,11
  78 0042 0FB6      		in __tmp_reg__,__SREG__
  79 0044 F894      		cli
  80 0046 DEBF      		out __SP_H__,r29
  81 0048 0FBE      		out __SREG__,__tmp_reg__
  82 004a CDBF      		out __SP_L__,r28
  83 004c DF91      		pop r29
  84 004e CF91      		pop r28
  99:tmk_core/common/action.c **** #else
  85               		.loc 1 99 5 view .LVU9
  86 0050 0C94 0000 		jmp action_tapping_process
  87               	.LVL3:
  88               		.cfi_endproc
  89               	.LFE13:
  91               		.section	.text.process_record_quantum,"ax",@progbits
  92               		.weak	process_record_quantum
  94               	process_record_quantum:
  95               	.LVL4:
  96               	.LFB15:
 109:tmk_core/common/action.c **** 
 110:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 111:tmk_core/common/action.c **** bool swap_hands = false;
 112:tmk_core/common/action.c **** bool swap_held  = false;
 113:tmk_core/common/action.c **** 
 114:tmk_core/common/action.c **** /** \brief Process Hand Swap
 115:tmk_core/common/action.c ****  *
 116:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 117:tmk_core/common/action.c ****  */
 118:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 119:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 120:tmk_core/common/action.c **** 
 121:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
 122:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 123:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 124:tmk_core/common/action.c **** 
 125:tmk_core/common/action.c ****     if (do_swap) {
 126:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 127:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 128:tmk_core/common/action.c ****     } else {
 129:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 130:tmk_core/common/action.c ****     }
 131:tmk_core/common/action.c **** }
 132:tmk_core/common/action.c **** #endif
 133:tmk_core/common/action.c **** 
 134:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 135:tmk_core/common/action.c **** bool disable_action_cache = false;
 136:tmk_core/common/action.c **** 
 137:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 138:tmk_core/common/action.c ****     disable_action_cache = true;
 139:tmk_core/common/action.c ****     process_record(record);
 140:tmk_core/common/action.c ****     disable_action_cache = false;
 141:tmk_core/common/action.c **** }
 142:tmk_core/common/action.c **** #else
 143:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 144:tmk_core/common/action.c **** #endif
 145:tmk_core/common/action.c **** 
 146:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
  97               		.loc 1 146 72 is_stmt 1 view -0
  98               		.cfi_startproc
  99               	/* prologue: function */
 100               	/* frame size = 0 */
 101               	/* stack size = 0 */
 102               	.L__stack_usage = 0
 103               		.loc 1 146 74 view .LVU11
 104               		.loc 1 146 1 is_stmt 0 view .LVU12
 105 0000 81E0      		ldi r24,lo8(1)
 106               	.LVL5:
 107               	/* epilogue start */
 108               		.loc 1 146 1 view .LVU13
 109 0002 0895      		ret
 110               		.cfi_endproc
 111               	.LFE15:
 113               		.section	.text.process_record_tap_hint,"ax",@progbits
 114               	.global	process_record_tap_hint
 116               	process_record_tap_hint:
 117               	.LVL6:
 118               	.LFB16:
 147:tmk_core/common/action.c **** 
 148:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 149:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 150:tmk_core/common/action.c ****  *
 151:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 152:tmk_core/common/action.c ****  */
 153:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 119               		.loc 1 153 51 is_stmt 1 view -0
 120               		.cfi_startproc
 121               	/* prologue: function */
 122               	/* frame size = 0 */
 123               	/* stack size = 0 */
 124               	.L__stack_usage = 0
 154:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 125               		.loc 1 154 5 view .LVU15
 126               		.loc 1 154 23 is_stmt 0 view .LVU16
 127 0000 FC01      		movw r30,r24
 128 0002 8081      		ld r24,Z
 129 0004 9181      		ldd r25,Z+1
 130               	.LVL7:
 131               		.loc 1 154 23 view .LVU17
 132 0006 0C94 0000 		jmp layer_switch_get_action
 133               	.LVL8:
 134               		.loc 1 154 23 view .LVU18
 135               		.cfi_endproc
 136               	.LFE16:
 138               		.section	.text.register_code,"ax",@progbits
 139               	.global	register_code
 141               	register_code:
 142               	.LVL9:
 143               	.LFB19:
 155:tmk_core/common/action.c **** 
 156:tmk_core/common/action.c ****     switch (action.kind.id) {
 157:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 158:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 159:tmk_core/common/action.c ****             switch (action.swap.code) {
 160:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 161:tmk_core/common/action.c ****                 default:
 162:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 163:tmk_core/common/action.c ****                     swap_held  = true;
 164:tmk_core/common/action.c ****             }
 165:tmk_core/common/action.c ****             break;
 166:tmk_core/common/action.c **** #    endif
 167:tmk_core/common/action.c ****     }
 168:tmk_core/common/action.c **** }
 169:tmk_core/common/action.c **** #endif
 170:tmk_core/common/action.c **** 
 171:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 172:tmk_core/common/action.c ****  *
 173:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 174:tmk_core/common/action.c ****  */
 175:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 176:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 177:tmk_core/common/action.c ****         return;
 178:tmk_core/common/action.c ****     }
 179:tmk_core/common/action.c **** 
 180:tmk_core/common/action.c ****     if (!process_record_quantum(record)) return;
 181:tmk_core/common/action.c **** 
 182:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 183:tmk_core/common/action.c ****     dprint("ACTION: ");
 184:tmk_core/common/action.c ****     debug_action(action);
 185:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 186:tmk_core/common/action.c ****     dprint(" layer_state: ");
 187:tmk_core/common/action.c ****     layer_debug();
 188:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 189:tmk_core/common/action.c ****     default_layer_debug();
 190:tmk_core/common/action.c **** #endif
 191:tmk_core/common/action.c ****     dprintln();
 192:tmk_core/common/action.c **** 
 193:tmk_core/common/action.c ****     process_action(record, action);
 194:tmk_core/common/action.c **** }
 195:tmk_core/common/action.c **** 
 196:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 197:tmk_core/common/action.c ****  *
 198:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 199:tmk_core/common/action.c ****  */
 200:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 201:tmk_core/common/action.c ****     keyevent_t event = record->event;
 202:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 203:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 204:tmk_core/common/action.c **** #endif
 205:tmk_core/common/action.c **** 
 206:tmk_core/common/action.c ****     if (event.pressed) {
 207:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 208:tmk_core/common/action.c ****         clear_weak_mods();
 209:tmk_core/common/action.c ****     }
 210:tmk_core/common/action.c **** 
 211:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 212:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 213:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 214:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 215:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 216:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 217:tmk_core/common/action.c ****     }
 218:tmk_core/common/action.c **** #endif
 219:tmk_core/common/action.c **** 
 220:tmk_core/common/action.c ****     switch (action.kind.id) {
 221:tmk_core/common/action.c ****         /* Key and Mods */
 222:tmk_core/common/action.c ****         case ACT_LMODS:
 223:tmk_core/common/action.c ****         case ACT_RMODS: {
 224:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 225:tmk_core/common/action.c ****             if (event.pressed) {
 226:tmk_core/common/action.c ****                 if (mods) {
 227:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 228:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 229:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 230:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 231:tmk_core/common/action.c ****                         add_mods(mods);
 232:tmk_core/common/action.c ****                     } else {
 233:tmk_core/common/action.c ****                         add_weak_mods(mods);
 234:tmk_core/common/action.c ****                     }
 235:tmk_core/common/action.c ****                     send_keyboard_report();
 236:tmk_core/common/action.c ****                 }
 237:tmk_core/common/action.c ****                 register_code(action.key.code);
 238:tmk_core/common/action.c ****             } else {
 239:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 240:tmk_core/common/action.c ****                 if (mods) {
 241:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 242:tmk_core/common/action.c ****                         del_mods(mods);
 243:tmk_core/common/action.c ****                     } else {
 244:tmk_core/common/action.c ****                         del_weak_mods(mods);
 245:tmk_core/common/action.c ****                     }
 246:tmk_core/common/action.c ****                     send_keyboard_report();
 247:tmk_core/common/action.c ****                 }
 248:tmk_core/common/action.c ****             }
 249:tmk_core/common/action.c ****         } break;
 250:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 251:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 252:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 253:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 254:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 255:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 256:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 257:tmk_core/common/action.c ****                     // Oneshot modifier
 258:tmk_core/common/action.c ****                     if (event.pressed) {
 259:tmk_core/common/action.c ****                         if (tap_count == 0) {
 260:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 261:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 262:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 263:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 264:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 265:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 266:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 267:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 268:tmk_core/common/action.c ****                             clear_oneshot_mods();
 269:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 270:tmk_core/common/action.c ****                             register_mods(mods);
 271:tmk_core/common/action.c **** #        endif
 272:tmk_core/common/action.c ****                         } else {
 273:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 274:tmk_core/common/action.c ****                         }
 275:tmk_core/common/action.c ****                     } else {
 276:tmk_core/common/action.c ****                         if (tap_count == 0) {
 277:tmk_core/common/action.c ****                             clear_oneshot_mods();
 278:tmk_core/common/action.c ****                             unregister_mods(mods);
 279:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 280:tmk_core/common/action.c ****                             // Retain Oneshot mods
 281:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 282:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 283:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 284:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 285:tmk_core/common/action.c ****                                 unregister_mods(mods);
 286:tmk_core/common/action.c ****                             }
 287:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 288:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 289:tmk_core/common/action.c **** #        endif
 290:tmk_core/common/action.c ****                         } else {
 291:tmk_core/common/action.c ****                             clear_oneshot_mods();
 292:tmk_core/common/action.c ****                             unregister_mods(mods);
 293:tmk_core/common/action.c ****                         }
 294:tmk_core/common/action.c ****                     }
 295:tmk_core/common/action.c ****                     break;
 296:tmk_core/common/action.c **** #    endif
 297:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 298:tmk_core/common/action.c ****                     if (event.pressed) {
 299:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 300:tmk_core/common/action.c ****                             register_mods(mods);
 301:tmk_core/common/action.c ****                         }
 302:tmk_core/common/action.c ****                     } else {
 303:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 304:tmk_core/common/action.c ****                             unregister_mods(mods);
 305:tmk_core/common/action.c ****                         }
 306:tmk_core/common/action.c ****                     }
 307:tmk_core/common/action.c ****                     break;
 308:tmk_core/common/action.c ****                 default:
 309:tmk_core/common/action.c ****                     if (event.pressed) {
 310:tmk_core/common/action.c ****                         if (tap_count > 0) {
 311:tmk_core/common/action.c **** #    ifndef IGNORE_MOD_TAP_INTERRUPT
 312:tmk_core/common/action.c ****                             if (record->tap.interrupted) {
 313:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 314:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 315:tmk_core/common/action.c ****                                 record->tap.count = 0;
 316:tmk_core/common/action.c ****                                 register_mods(mods);
 317:tmk_core/common/action.c ****                             } else
 318:tmk_core/common/action.c **** #    endif
 319:tmk_core/common/action.c ****                             {
 320:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 321:tmk_core/common/action.c ****                                 register_code(action.key.code);
 322:tmk_core/common/action.c ****                             }
 323:tmk_core/common/action.c ****                         } else {
 324:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 325:tmk_core/common/action.c ****                             register_mods(mods);
 326:tmk_core/common/action.c ****                         }
 327:tmk_core/common/action.c ****                     } else {
 328:tmk_core/common/action.c ****                         if (tap_count > 0) {
 329:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 330:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 331:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 332:tmk_core/common/action.c ****                             }
 333:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 334:tmk_core/common/action.c ****                         } else {
 335:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 336:tmk_core/common/action.c ****                             unregister_mods(mods);
 337:tmk_core/common/action.c ****                         }
 338:tmk_core/common/action.c ****                     }
 339:tmk_core/common/action.c ****                     break;
 340:tmk_core/common/action.c ****             }
 341:tmk_core/common/action.c ****         } break;
 342:tmk_core/common/action.c **** #endif
 343:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 344:tmk_core/common/action.c ****         /* other HID usage */
 345:tmk_core/common/action.c ****         case ACT_USAGE:
 346:tmk_core/common/action.c ****             switch (action.usage.page) {
 347:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 348:tmk_core/common/action.c ****                     if (event.pressed) {
 349:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 350:tmk_core/common/action.c ****                     } else {
 351:tmk_core/common/action.c ****                         host_system_send(0);
 352:tmk_core/common/action.c ****                     }
 353:tmk_core/common/action.c ****                     break;
 354:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 355:tmk_core/common/action.c ****                     if (event.pressed) {
 356:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 357:tmk_core/common/action.c ****                     } else {
 358:tmk_core/common/action.c ****                         host_consumer_send(0);
 359:tmk_core/common/action.c ****                     }
 360:tmk_core/common/action.c ****                     break;
 361:tmk_core/common/action.c ****             }
 362:tmk_core/common/action.c ****             break;
 363:tmk_core/common/action.c **** #endif
 364:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 365:tmk_core/common/action.c ****         /* Mouse key */
 366:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 367:tmk_core/common/action.c ****             if (event.pressed) {
 368:tmk_core/common/action.c ****                 switch (action.key.code) {
 369:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 370:tmk_core/common/action.c ****                         tp_buttons |= (1 << 0);
 371:tmk_core/common/action.c ****                         break;
 372:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 373:tmk_core/common/action.c ****                         tp_buttons |= (1 << 1);
 374:tmk_core/common/action.c ****                         break;
 375:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 376:tmk_core/common/action.c ****                         tp_buttons |= (1 << 2);
 377:tmk_core/common/action.c ****                         break;
 378:tmk_core/common/action.c ****                     default:
 379:tmk_core/common/action.c ****                         break;
 380:tmk_core/common/action.c ****                 }
 381:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 382:tmk_core/common/action.c ****                 mousekey_send();
 383:tmk_core/common/action.c ****             } else {
 384:tmk_core/common/action.c ****                 switch (action.key.code) {
 385:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 386:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 0);
 387:tmk_core/common/action.c ****                         break;
 388:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 389:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 1);
 390:tmk_core/common/action.c ****                         break;
 391:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 392:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 2);
 393:tmk_core/common/action.c ****                         break;
 394:tmk_core/common/action.c ****                     default:
 395:tmk_core/common/action.c ****                         break;
 396:tmk_core/common/action.c ****                 }
 397:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 398:tmk_core/common/action.c ****                 mousekey_send();
 399:tmk_core/common/action.c ****             }
 400:tmk_core/common/action.c ****             break;
 401:tmk_core/common/action.c **** #endif
 402:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 403:tmk_core/common/action.c ****         case ACT_LAYER:
 404:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 405:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 406:tmk_core/common/action.c ****                 if (!event.pressed) {
 407:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 408:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 409:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 410:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 411:tmk_core/common/action.c ****                         case OP_BIT_AND:
 412:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 413:tmk_core/common/action.c ****                             break;
 414:tmk_core/common/action.c ****                         case OP_BIT_OR:
 415:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 416:tmk_core/common/action.c ****                             break;
 417:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 418:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 419:tmk_core/common/action.c ****                             break;
 420:tmk_core/common/action.c ****                         case OP_BIT_SET:
 421:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 422:tmk_core/common/action.c ****                             break;
 423:tmk_core/common/action.c ****                     }
 424:tmk_core/common/action.c ****                 }
 425:tmk_core/common/action.c ****             } else {
 426:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 427:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 428:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 429:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 430:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 431:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 432:tmk_core/common/action.c ****                         case OP_BIT_AND:
 433:tmk_core/common/action.c ****                             layer_and(bits | mask);
 434:tmk_core/common/action.c ****                             break;
 435:tmk_core/common/action.c ****                         case OP_BIT_OR:
 436:tmk_core/common/action.c ****                             layer_or(bits | mask);
 437:tmk_core/common/action.c ****                             break;
 438:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 439:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 440:tmk_core/common/action.c ****                             break;
 441:tmk_core/common/action.c ****                         case OP_BIT_SET:
 442:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 443:tmk_core/common/action.c ****                             break;
 444:tmk_core/common/action.c ****                     }
 445:tmk_core/common/action.c ****                 }
 446:tmk_core/common/action.c ****             }
 447:tmk_core/common/action.c ****             break;
 448:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 449:tmk_core/common/action.c ****             if (event.pressed) {
 450:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 451:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 452:tmk_core/common/action.c ****             } else {
 453:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 454:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 455:tmk_core/common/action.c ****             }
 456:tmk_core/common/action.c ****             break;
 457:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 458:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 459:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 460:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 461:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 462:tmk_core/common/action.c ****                     /* tap toggle */
 463:tmk_core/common/action.c ****                     if (event.pressed) {
 464:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 465:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 466:tmk_core/common/action.c ****                         }
 467:tmk_core/common/action.c ****                     } else {
 468:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 469:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 470:tmk_core/common/action.c ****                         }
 471:tmk_core/common/action.c ****                     }
 472:tmk_core/common/action.c ****                     break;
 473:tmk_core/common/action.c ****                 case OP_ON_OFF:
 474:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 475:tmk_core/common/action.c ****                     break;
 476:tmk_core/common/action.c ****                 case OP_OFF_ON:
 477:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 478:tmk_core/common/action.c ****                     break;
 479:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 480:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 481:tmk_core/common/action.c ****                     break;
 482:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 483:tmk_core/common/action.c ****                 case OP_ONESHOT:
 484:tmk_core/common/action.c ****                     // Oneshot modifier
 485:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 486:tmk_core/common/action.c ****                     do_release_oneshot = false;
 487:tmk_core/common/action.c ****                     if (event.pressed) {
 488:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 489:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 490:tmk_core/common/action.c ****                             reset_oneshot_layer();
 491:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 492:tmk_core/common/action.c ****                             break;
 493:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 494:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 495:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 496:tmk_core/common/action.c ****                         }
 497:tmk_core/common/action.c ****                     } else {
 498:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 499:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 500:tmk_core/common/action.c ****                             reset_oneshot_layer();
 501:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 502:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 503:tmk_core/common/action.c ****                         } else {
 504:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 505:tmk_core/common/action.c ****                         }
 506:tmk_core/common/action.c ****                     }
 507:tmk_core/common/action.c **** #            else
 508:tmk_core/common/action.c ****                     if (event.pressed) {
 509:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 510:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 511:tmk_core/common/action.c ****                     } else {
 512:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 513:tmk_core/common/action.c ****                         if (tap_count > 1) {
 514:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 515:tmk_core/common/action.c ****                         }
 516:tmk_core/common/action.c ****                     }
 517:tmk_core/common/action.c **** #            endif
 518:tmk_core/common/action.c ****                     break;
 519:tmk_core/common/action.c **** #        endif
 520:tmk_core/common/action.c ****                 default:
 521:tmk_core/common/action.c ****                     /* tap key */
 522:tmk_core/common/action.c ****                     if (event.pressed) {
 523:tmk_core/common/action.c ****                         if (tap_count > 0) {
 524:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 525:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 526:tmk_core/common/action.c ****                         } else {
 527:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 528:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 529:tmk_core/common/action.c ****                         }
 530:tmk_core/common/action.c ****                     } else {
 531:tmk_core/common/action.c ****                         if (tap_count > 0) {
 532:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 533:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 534:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 535:tmk_core/common/action.c ****                             } else {
 536:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 537:tmk_core/common/action.c ****                             }
 538:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 539:tmk_core/common/action.c ****                         } else {
 540:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 541:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 542:tmk_core/common/action.c ****                         }
 543:tmk_core/common/action.c ****                     }
 544:tmk_core/common/action.c ****                     break;
 545:tmk_core/common/action.c ****             }
 546:tmk_core/common/action.c ****             break;
 547:tmk_core/common/action.c **** #    endif
 548:tmk_core/common/action.c **** #endif
 549:tmk_core/common/action.c ****             /* Extentions */
 550:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 551:tmk_core/common/action.c ****         case ACT_MACRO:
 552:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 553:tmk_core/common/action.c ****             break;
 554:tmk_core/common/action.c **** #endif
 555:tmk_core/common/action.c **** #if defined(BACKLIGHT_ENABLE) | defined(LED_MATRIX_ENABLE)
 556:tmk_core/common/action.c ****         case ACT_BACKLIGHT:
 557:tmk_core/common/action.c ****             if (!event.pressed) {
 558:tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 559:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 560:tmk_core/common/action.c ****                         backlight_increase();
 561:tmk_core/common/action.c ****                         break;
 562:tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 563:tmk_core/common/action.c ****                         backlight_decrease();
 564:tmk_core/common/action.c ****                         break;
 565:tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 566:tmk_core/common/action.c ****                         backlight_toggle();
 567:tmk_core/common/action.c ****                         break;
 568:tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 569:tmk_core/common/action.c ****                         backlight_step();
 570:tmk_core/common/action.c ****                         break;
 571:tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 572:tmk_core/common/action.c ****                         backlight_level(BACKLIGHT_LEVELS);
 573:tmk_core/common/action.c ****                         break;
 574:tmk_core/common/action.c ****                     case BACKLIGHT_OFF:
 575:tmk_core/common/action.c ****                         backlight_level(0);
 576:tmk_core/common/action.c ****                         break;
 577:tmk_core/common/action.c ****                 }
 578:tmk_core/common/action.c ****             }
 579:tmk_core/common/action.c ****             break;
 580:tmk_core/common/action.c **** #endif
 581:tmk_core/common/action.c ****         case ACT_COMMAND:
 582:tmk_core/common/action.c ****             break;
 583:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 584:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 585:tmk_core/common/action.c ****             switch (action.swap.code) {
 586:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 587:tmk_core/common/action.c ****                     if (event.pressed) {
 588:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 589:tmk_core/common/action.c ****                     }
 590:tmk_core/common/action.c ****                     break;
 591:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 592:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 593:tmk_core/common/action.c ****                     break;
 594:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 595:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 596:tmk_core/common/action.c ****                     break;
 597:tmk_core/common/action.c ****                 case OP_SH_ON:
 598:tmk_core/common/action.c ****                     if (!event.pressed) {
 599:tmk_core/common/action.c ****                         swap_hands = true;
 600:tmk_core/common/action.c ****                     }
 601:tmk_core/common/action.c ****                     break;
 602:tmk_core/common/action.c ****                 case OP_SH_OFF:
 603:tmk_core/common/action.c ****                     if (!event.pressed) {
 604:tmk_core/common/action.c ****                         swap_hands = false;
 605:tmk_core/common/action.c ****                     }
 606:tmk_core/common/action.c ****                     break;
 607:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 608:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 609:tmk_core/common/action.c ****                     /* tap toggle */
 610:tmk_core/common/action.c **** 
 611:tmk_core/common/action.c ****                     if (event.pressed) {
 612:tmk_core/common/action.c ****                         if (swap_held) {
 613:tmk_core/common/action.c ****                             swap_held = false;
 614:tmk_core/common/action.c ****                         } else {
 615:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 616:tmk_core/common/action.c ****                         }
 617:tmk_core/common/action.c ****                     } else {
 618:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 619:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 620:tmk_core/common/action.c ****                         }
 621:tmk_core/common/action.c ****                     }
 622:tmk_core/common/action.c ****                     break;
 623:tmk_core/common/action.c ****                 default:
 624:tmk_core/common/action.c ****                     /* tap key */
 625:tmk_core/common/action.c ****                     if (tap_count > 0) {
 626:tmk_core/common/action.c ****                         if (swap_held) {
 627:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 628:tmk_core/common/action.c ****                             swap_held  = false;
 629:tmk_core/common/action.c ****                         }
 630:tmk_core/common/action.c ****                         if (event.pressed) {
 631:tmk_core/common/action.c ****                             register_code(action.swap.code);
 632:tmk_core/common/action.c ****                         } else {
 633:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 634:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 635:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 636:tmk_core/common/action.c ****                         }
 637:tmk_core/common/action.c ****                     } else {
 638:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 639:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 640:tmk_core/common/action.c ****                             swap_held  = false;
 641:tmk_core/common/action.c ****                         }
 642:tmk_core/common/action.c ****                     }
 643:tmk_core/common/action.c **** #    endif
 644:tmk_core/common/action.c ****             }
 645:tmk_core/common/action.c **** #endif
 646:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 647:tmk_core/common/action.c ****         case ACT_FUNCTION:
 648:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 649:tmk_core/common/action.c ****             break;
 650:tmk_core/common/action.c **** #endif
 651:tmk_core/common/action.c ****         default:
 652:tmk_core/common/action.c ****             break;
 653:tmk_core/common/action.c ****     }
 654:tmk_core/common/action.c **** 
 655:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 656:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 657:tmk_core/common/action.c ****     switch (action.kind.id) {
 658:tmk_core/common/action.c ****         case ACT_LAYER:
 659:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 660:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 661:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 662:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 663:tmk_core/common/action.c **** #    endif
 664:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 665:tmk_core/common/action.c ****             break;
 666:tmk_core/common/action.c ****         default:
 667:tmk_core/common/action.c ****             break;
 668:tmk_core/common/action.c ****     }
 669:tmk_core/common/action.c **** #endif
 670:tmk_core/common/action.c **** 
 671:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 672:tmk_core/common/action.c **** #    ifdef RETRO_TAPPING
 673:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 674:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 675:tmk_core/common/action.c ****     } else {
 676:tmk_core/common/action.c ****         if (event.pressed) {
 677:tmk_core/common/action.c ****             if (tap_count > 0) {
 678:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 679:tmk_core/common/action.c ****             } else {
 680:tmk_core/common/action.c ****             }
 681:tmk_core/common/action.c ****         } else {
 682:tmk_core/common/action.c ****             if (tap_count > 0) {
 683:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 684:tmk_core/common/action.c ****             } else {
 685:tmk_core/common/action.c ****                 if (retro_tapping_counter == 2) {
 686:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 687:tmk_core/common/action.c ****                 }
 688:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 689:tmk_core/common/action.c ****             }
 690:tmk_core/common/action.c ****         }
 691:tmk_core/common/action.c ****     }
 692:tmk_core/common/action.c **** #    endif
 693:tmk_core/common/action.c **** #endif
 694:tmk_core/common/action.c **** 
 695:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 696:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 697:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 698:tmk_core/common/action.c ****      */
 699:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 700:tmk_core/common/action.c ****         record->event.pressed = false;
 701:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 702:tmk_core/common/action.c ****         process_record(record);
 703:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 704:tmk_core/common/action.c ****     }
 705:tmk_core/common/action.c **** #endif
 706:tmk_core/common/action.c **** }
 707:tmk_core/common/action.c **** 
 708:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 709:tmk_core/common/action.c ****  *
 710:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 711:tmk_core/common/action.c ****  */
 712:tmk_core/common/action.c **** void register_code(uint8_t code) {
 144               		.loc 1 712 34 is_stmt 1 view -0
 145               		.cfi_startproc
 146               		.loc 1 712 34 is_stmt 0 view .LVU20
 147 0000 CF93      		push r28
 148               	.LCFI4:
 149               		.cfi_def_cfa_offset 3
 150               		.cfi_offset 28, -2
 151               	/* prologue: function */
 152               	/* frame size = 0 */
 153               	/* stack size = 1 */
 154               	.L__stack_usage = 1
 155 0002 C82F      		mov r28,r24
 713:tmk_core/common/action.c ****     if (code == KC_NO) {
 156               		.loc 1 713 5 is_stmt 1 view .LVU21
 157               		.loc 1 713 8 is_stmt 0 view .LVU22
 158 0004 8823      		tst r24
 159 0006 01F4      		brne .+2
 160 0008 00C0      		rjmp .L4
 714:tmk_core/common/action.c ****         return;
 715:tmk_core/common/action.c ****     }
 716:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 717:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 161               		.loc 1 717 10 is_stmt 1 view .LVU23
 162               		.loc 1 717 13 is_stmt 0 view .LVU24
 163 000a 8238      		cpi r24,lo8(-126)
 164 000c 01F4      		brne .L7
 718:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 719:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 720:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 165               		.loc 1 720 9 is_stmt 1 view .LVU25
 166               		.loc 1 720 13 is_stmt 0 view .LVU26
 167 000e 0E94 0000 		call host_keyboard_leds
 168               	.LVL10:
 169               		.loc 1 720 12 view .LVU27
 170 0012 81FD      		sbrc r24,1
 171 0014 00C0      		rjmp .L4
 721:tmk_core/common/action.c **** #    endif
 722:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 172               		.loc 1 722 9 is_stmt 1 view .LVU28
 173 0016 89E3      		ldi r24,lo8(57)
 174 0018 0E94 0000 		call add_key
 175               	.LVL11:
 723:tmk_core/common/action.c ****         send_keyboard_report();
 176               		.loc 1 723 9 view .LVU29
 177 001c 0E94 0000 		call send_keyboard_report
 178               	.LVL12:
 724:tmk_core/common/action.c ****         wait_ms(100);
 179               		.loc 1 724 9 view .LVU30
 180               	.LBB22:
 181               	.LBI22:
 182               		.file 2 "/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 183               		.loc 2 166 1 view .LVU31
 184               	.LBB23:
 167:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	double __tmp ;
 185               		.loc 2 168 2 view .LVU32
 169:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 186               		.loc 2 172 2 view .LVU33
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 187               		.loc 2 173 2 view .LVU34
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 188               		.loc 2 174 2 view .LVU35
 175:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 189               		.loc 2 184 3 view .LVU36
 185:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 190               		.loc 2 187 2 view .LVU37
 191 0020 2FEF      		ldi r18,lo8(319999)
 192 0022 81EE      		ldi r24,hi8(319999)
 193 0024 94E0      		ldi r25,hlo8(319999)
 194 0026 2150      	1:	subi r18,1
 195 0028 8040      		sbci r24,0
 196 002a 9040      		sbci r25,0
 197 002c 01F4      		brne 1b
 198 002e 00C0      		rjmp .
 199 0030 0000      		nop
 200               	.LVL13:
 201               		.loc 2 187 2 is_stmt 0 view .LVU38
 202               	.LBE23:
 203               	.LBE22:
 725:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 204               		.loc 1 725 9 is_stmt 1 view .LVU39
 205 0032 89E3      		ldi r24,lo8(57)
 206               	.L42:
 726:tmk_core/common/action.c ****         send_keyboard_report();
 727:tmk_core/common/action.c ****     }
 728:tmk_core/common/action.c **** 
 729:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 730:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 731:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 732:tmk_core/common/action.c **** #    endif
 733:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 734:tmk_core/common/action.c ****         send_keyboard_report();
 735:tmk_core/common/action.c ****         wait_ms(100);
 736:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 207               		.loc 1 736 9 is_stmt 0 view .LVU40
 208 0034 0E94 0000 		call del_key
 209               	.LVL14:
 210               	.L43:
 737:tmk_core/common/action.c ****         send_keyboard_report();
 211               		.loc 1 737 9 is_stmt 1 view .LVU41
 212               	/* epilogue start */
 738:tmk_core/common/action.c ****     }
 739:tmk_core/common/action.c **** 
 740:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 741:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 742:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 743:tmk_core/common/action.c **** #    endif
 744:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 745:tmk_core/common/action.c ****         send_keyboard_report();
 746:tmk_core/common/action.c ****         wait_ms(100);
 747:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 748:tmk_core/common/action.c ****         send_keyboard_report();
 749:tmk_core/common/action.c ****     }
 750:tmk_core/common/action.c **** #endif
 751:tmk_core/common/action.c **** 
 752:tmk_core/common/action.c ****     else if
 753:tmk_core/common/action.c ****         IS_KEY(code) {
 754:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 755:tmk_core/common/action.c ****             if (command_proc(code)) return;
 756:tmk_core/common/action.c **** 
 757:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 758:tmk_core/common/action.c **** /* TODO: remove
 759:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 760:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 761:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 762:tmk_core/common/action.c **** 
 763:tmk_core/common/action.c ****             add_key(code);
 764:tmk_core/common/action.c ****             send_keyboard_report();
 765:tmk_core/common/action.c **** 
 766:tmk_core/common/action.c ****             set_mods(tmp_mods);
 767:tmk_core/common/action.c ****             send_keyboard_report();
 768:tmk_core/common/action.c ****             oneshot_cancel();
 769:tmk_core/common/action.c ****         } else
 770:tmk_core/common/action.c **** */
 771:tmk_core/common/action.c **** #endif
 772:tmk_core/common/action.c ****             {
 773:tmk_core/common/action.c ****                 add_key(code);
 774:tmk_core/common/action.c ****                 send_keyboard_report();
 775:tmk_core/common/action.c ****             }
 776:tmk_core/common/action.c ****         }
 777:tmk_core/common/action.c ****     else if
 778:tmk_core/common/action.c ****         IS_MOD(code) {
 779:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 780:tmk_core/common/action.c ****             send_keyboard_report();
 781:tmk_core/common/action.c ****         }
 782:tmk_core/common/action.c ****     else if
 783:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 784:tmk_core/common/action.c ****     else if
 785:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 786:tmk_core/common/action.c **** 
 787:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 788:tmk_core/common/action.c ****     else if
 789:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 790:tmk_core/common/action.c ****             mousekey_on(code);
 791:tmk_core/common/action.c ****             mousekey_send();
 792:tmk_core/common/action.c ****         }
 793:tmk_core/common/action.c **** #endif
 794:tmk_core/common/action.c **** }
 213               		.loc 1 794 1 is_stmt 0 view .LVU42
 214 0038 CF91      		pop r28
 737:tmk_core/common/action.c ****         send_keyboard_report();
 215               		.loc 1 737 9 view .LVU43
 216 003a 0C94 0000 		jmp send_keyboard_report
 217               	.LVL15:
 218               	.L7:
 729:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 219               		.loc 1 729 10 is_stmt 1 view .LVU44
 729:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 220               		.loc 1 729 13 is_stmt 0 view .LVU45
 221 003e 8338      		cpi r24,lo8(-125)
 222 0040 01F4      		brne .L9
 731:tmk_core/common/action.c **** #    endif
 223               		.loc 1 731 9 is_stmt 1 view .LVU46
 731:tmk_core/common/action.c **** #    endif
 224               		.loc 1 731 13 is_stmt 0 view .LVU47
 225 0042 0E94 0000 		call host_keyboard_leds
 226               	.LVL16:
 731:tmk_core/common/action.c **** #    endif
 227               		.loc 1 731 12 view .LVU48
 228 0046 80FD      		sbrc r24,0
 229 0048 00C0      		rjmp .L4
 733:tmk_core/common/action.c ****         send_keyboard_report();
 230               		.loc 1 733 9 is_stmt 1 view .LVU49
 231 004a 83E5      		ldi r24,lo8(83)
 232 004c 0E94 0000 		call add_key
 233               	.LVL17:
 734:tmk_core/common/action.c ****         wait_ms(100);
 234               		.loc 1 734 9 view .LVU50
 235 0050 0E94 0000 		call send_keyboard_report
 236               	.LVL18:
 735:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 237               		.loc 1 735 9 view .LVU51
 238               	.LBB24:
 239               	.LBI24:
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 240               		.loc 2 166 1 view .LVU52
 241               	.LBB25:
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 242               		.loc 2 168 2 view .LVU53
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 243               		.loc 2 172 2 view .LVU54
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 244               		.loc 2 173 2 view .LVU55
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 245               		.loc 2 174 2 view .LVU56
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 246               		.loc 2 184 3 view .LVU57
 247               		.loc 2 187 2 view .LVU58
 248 0054 2FEF      		ldi r18,lo8(319999)
 249 0056 81EE      		ldi r24,hi8(319999)
 250 0058 94E0      		ldi r25,hlo8(319999)
 251 005a 2150      	1:	subi r18,1
 252 005c 8040      		sbci r24,0
 253 005e 9040      		sbci r25,0
 254 0060 01F4      		brne 1b
 255 0062 00C0      		rjmp .
 256 0064 0000      		nop
 257               	.LVL19:
 258               		.loc 2 187 2 is_stmt 0 view .LVU59
 259               	.LBE25:
 260               	.LBE24:
 736:tmk_core/common/action.c ****         send_keyboard_report();
 261               		.loc 1 736 9 is_stmt 1 view .LVU60
 262 0066 83E5      		ldi r24,lo8(83)
 263 0068 00C0      		rjmp .L42
 264               	.LVL20:
 265               	.L9:
 740:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 266               		.loc 1 740 10 view .LVU61
 740:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 267               		.loc 1 740 13 is_stmt 0 view .LVU62
 268 006a 8438      		cpi r24,lo8(-124)
 269 006c 01F4      		brne .L10
 742:tmk_core/common/action.c **** #    endif
 270               		.loc 1 742 9 is_stmt 1 view .LVU63
 742:tmk_core/common/action.c **** #    endif
 271               		.loc 1 742 13 is_stmt 0 view .LVU64
 272 006e 0E94 0000 		call host_keyboard_leds
 273               	.LVL21:
 742:tmk_core/common/action.c **** #    endif
 274               		.loc 1 742 12 view .LVU65
 275 0072 82FD      		sbrc r24,2
 276 0074 00C0      		rjmp .L4
 744:tmk_core/common/action.c ****         send_keyboard_report();
 277               		.loc 1 744 9 is_stmt 1 view .LVU66
 278 0076 87E4      		ldi r24,lo8(71)
 279 0078 0E94 0000 		call add_key
 280               	.LVL22:
 745:tmk_core/common/action.c ****         wait_ms(100);
 281               		.loc 1 745 9 view .LVU67
 282 007c 0E94 0000 		call send_keyboard_report
 283               	.LVL23:
 746:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 284               		.loc 1 746 9 view .LVU68
 285               	.LBB26:
 286               	.LBI26:
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 287               		.loc 2 166 1 view .LVU69
 288               	.LBB27:
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 289               		.loc 2 168 2 view .LVU70
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 290               		.loc 2 172 2 view .LVU71
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 291               		.loc 2 173 2 view .LVU72
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 292               		.loc 2 174 2 view .LVU73
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 293               		.loc 2 184 3 view .LVU74
 294               		.loc 2 187 2 view .LVU75
 295 0080 2FEF      		ldi r18,lo8(319999)
 296 0082 81EE      		ldi r24,hi8(319999)
 297 0084 94E0      		ldi r25,hlo8(319999)
 298 0086 2150      	1:	subi r18,1
 299 0088 8040      		sbci r24,0
 300 008a 9040      		sbci r25,0
 301 008c 01F4      		brne 1b
 302 008e 00C0      		rjmp .
 303 0090 0000      		nop
 304               	.LVL24:
 305               		.loc 2 187 2 is_stmt 0 view .LVU76
 306               	.LBE27:
 307               	.LBE26:
 747:tmk_core/common/action.c ****         send_keyboard_report();
 308               		.loc 1 747 9 is_stmt 1 view .LVU77
 309 0092 87E4      		ldi r24,lo8(71)
 310 0094 00C0      		rjmp .L42
 311               	.LVL25:
 312               	.L10:
 752:tmk_core/common/action.c ****         IS_KEY(code) {
 313               		.loc 1 752 10 view .LVU78
 753:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 314               		.loc 1 753 9 is_stmt 0 view .LVU79
 315 0096 8CEF      		ldi r24,lo8(-4)
 316               	.LVL26:
 753:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 317               		.loc 1 753 9 view .LVU80
 318 0098 8C0F      		add r24,r28
 319 009a 813A      		cpi r24,lo8(-95)
 320 009c 00F4      		brsh .L11
 755:tmk_core/common/action.c **** 
 321               		.loc 1 755 13 is_stmt 1 view .LVU81
 755:tmk_core/common/action.c **** 
 322               		.loc 1 755 17 is_stmt 0 view .LVU82
 323 009e 8C2F      		mov r24,r28
 324 00a0 0E94 0000 		call command_proc
 325               	.LVL27:
 755:tmk_core/common/action.c **** 
 326               		.loc 1 755 16 view .LVU83
 327 00a4 8111      		cpse r24,__zero_reg__
 328 00a6 00C0      		rjmp .L4
 773:tmk_core/common/action.c ****                 send_keyboard_report();
 329               		.loc 1 773 17 is_stmt 1 view .LVU84
 330 00a8 8C2F      		mov r24,r28
 331 00aa 0E94 0000 		call add_key
 332               	.LVL28:
 774:tmk_core/common/action.c ****             }
 333               		.loc 1 774 17 view .LVU85
 334 00ae 00C0      		rjmp .L43
 335               	.L11:
 777:tmk_core/common/action.c ****         IS_MOD(code) {
 336               		.loc 1 777 10 view .LVU86
 778:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 337               		.loc 1 778 9 is_stmt 0 view .LVU87
 338 00b0 80E2      		ldi r24,lo8(32)
 339 00b2 8C0F      		add r24,r28
 340 00b4 8830      		cpi r24,lo8(8)
 341 00b6 00F4      		brsh .L12
 779:tmk_core/common/action.c ****             send_keyboard_report();
 342               		.loc 1 779 13 is_stmt 1 view .LVU88
 779:tmk_core/common/action.c ****             send_keyboard_report();
 343               		.loc 1 779 22 is_stmt 0 view .LVU89
 344 00b8 C770      		andi r28,lo8(7)
 345               	.LVL29:
 779:tmk_core/common/action.c ****             send_keyboard_report();
 346               		.loc 1 779 13 view .LVU90
 347 00ba 81E0      		ldi r24,lo8(1)
 348 00bc 00C0      		rjmp 2f
 349               		1:
 350 00be 880F      		lsl r24
 351               		2:
 352 00c0 CA95      		dec r28
 353 00c2 02F4      		brpl 1b
 354 00c4 0E94 0000 		call add_mods
 355               	.LVL30:
 780:tmk_core/common/action.c ****         }
 356               		.loc 1 780 13 is_stmt 1 view .LVU91
 357 00c8 00C0      		rjmp .L43
 358               	.LVL31:
 359               	.L12:
 782:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 360               		.loc 1 782 10 view .LVU92
 783:tmk_core/common/action.c ****     else if
 361               		.loc 1 783 9 is_stmt 0 view .LVU93
 362 00ca 8BE5      		ldi r24,lo8(91)
 363 00cc 8C0F      		add r24,r28
 364 00ce 8330      		cpi r24,lo8(3)
 365 00d0 00F4      		brsh .L13
 783:tmk_core/common/action.c ****     else if
 366               		.loc 1 783 27 is_stmt 1 discriminator 1 view .LVU94
 367 00d2 81E8      		ldi r24,lo8(-127)
 368 00d4 90E0      		ldi r25,0
 369 00d6 C53A      		cpi r28,lo8(-91)
 370 00d8 01F0      		breq .L14
 783:tmk_core/common/action.c ****     else if
 371               		.loc 1 783 44 is_stmt 0 discriminator 2 view .LVU95
 372 00da 83E8      		ldi r24,lo8(-125)
 373 00dc 90E0      		ldi r25,0
 374 00de C63A      		cpi r28,lo8(-90)
 375 00e0 01F4      		brne .L14
 783:tmk_core/common/action.c ****     else if
 376               		.loc 1 783 44 view .LVU96
 377 00e2 82E8      		ldi r24,lo8(-126)
 378 00e4 90E0      		ldi r25,0
 379               	.L14:
 380               	/* epilogue start */
 381               		.loc 1 794 1 discriminator 13 view .LVU97
 382 00e6 CF91      		pop r28
 383               	.LVL32:
 783:tmk_core/common/action.c ****     else if
 384               		.loc 1 783 27 discriminator 13 view .LVU98
 385 00e8 0C94 0000 		jmp host_system_send
 386               	.LVL33:
 387               	.L13:
 784:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 388               		.loc 1 784 10 is_stmt 1 view .LVU99
 785:tmk_core/common/action.c **** 
 389               		.loc 1 785 9 is_stmt 0 view .LVU100
 390 00ec 88E5      		ldi r24,lo8(88)
 391 00ee 8C0F      		add r24,r28
 392 00f0 8731      		cpi r24,lo8(23)
 393 00f2 00F0      		brlo .+2
 394 00f4 00C0      		rjmp .L15
 785:tmk_core/common/action.c **** 
 395               		.loc 1 785 29 is_stmt 1 discriminator 1 view .LVU101
 396 00f6 82EE      		ldi r24,lo8(-30)
 397 00f8 90E0      		ldi r25,0
 398 00fa C83A      		cpi r28,lo8(-88)
 399 00fc 01F4      		brne .+2
 400 00fe 00C0      		rjmp .L16
 785:tmk_core/common/action.c **** 
 401               		.loc 1 785 48 is_stmt 0 discriminator 2 view .LVU102
 402 0100 89EE      		ldi r24,lo8(-23)
 403 0102 90E0      		ldi r25,0
 404 0104 C93A      		cpi r28,lo8(-87)
 405 0106 01F4      		brne .+2
 406 0108 00C0      		rjmp .L16
 785:tmk_core/common/action.c **** 
 407               		.loc 1 785 48 discriminator 4 view .LVU103
 408 010a 8AEE      		ldi r24,lo8(-22)
 409 010c 90E0      		ldi r25,0
 410 010e CA3A      		cpi r28,lo8(-86)
 411 0110 01F4      		brne .+2
 412 0112 00C0      		rjmp .L16
 785:tmk_core/common/action.c **** 
 413               		.loc 1 785 48 discriminator 6 view .LVU104
 414 0114 85EB      		ldi r24,lo8(-75)
 415 0116 90E0      		ldi r25,0
 416 0118 CB3A      		cpi r28,lo8(-85)
 417 011a 01F4      		brne .+2
 418 011c 00C0      		rjmp .L16
 785:tmk_core/common/action.c **** 
 419               		.loc 1 785 48 discriminator 8 view .LVU105
 420 011e 86EB      		ldi r24,lo8(-74)
 421 0120 90E0      		ldi r25,0
 422 0122 CC3A      		cpi r28,lo8(-84)
 423 0124 01F4      		brne .+2
 424 0126 00C0      		rjmp .L16
 785:tmk_core/common/action.c **** 
 425               		.loc 1 785 48 discriminator 10 view .LVU106
 426 0128 83EB      		ldi r24,lo8(-77)
 427 012a 90E0      		ldi r25,0
 428 012c CB3B      		cpi r28,lo8(-69)
 429 012e 01F4      		brne .+2
 430 0130 00C0      		rjmp .L16
 785:tmk_core/common/action.c **** 
 431               		.loc 1 785 48 discriminator 12 view .LVU107
 432 0132 84EB      		ldi r24,lo8(-76)
 433 0134 90E0      		ldi r25,0
 434 0136 CC3B      		cpi r28,lo8(-68)
 435 0138 01F4      		brne .+2
 436 013a 00C0      		rjmp .L16
 785:tmk_core/common/action.c **** 
 437               		.loc 1 785 48 discriminator 14 view .LVU108
 438 013c 87EB      		ldi r24,lo8(-73)
 439 013e 90E0      		ldi r25,0
 440 0140 CD3A      		cpi r28,lo8(-83)
 441 0142 01F0      		breq .L16
 785:tmk_core/common/action.c **** 
 442               		.loc 1 785 48 discriminator 16 view .LVU109
 443 0144 8CEC      		ldi r24,lo8(-52)
 444 0146 90E0      		ldi r25,0
 445 0148 C03B      		cpi r28,lo8(-80)
 446 014a 01F0      		breq .L16
 785:tmk_core/common/action.c **** 
 447               		.loc 1 785 48 discriminator 18 view .LVU110
 448 014c 8DEC      		ldi r24,lo8(-51)
 449 014e 90E0      		ldi r25,0
 450 0150 CE3A      		cpi r28,lo8(-82)
 451 0152 01F0      		breq .L16
 785:tmk_core/common/action.c **** 
 452               		.loc 1 785 48 discriminator 20 view .LVU111
 453 0154 83E8      		ldi r24,lo8(-125)
 454 0156 91E0      		ldi r25,lo8(1)
 455 0158 CF3A      		cpi r28,lo8(-81)
 456 015a 01F0      		breq .L16
 785:tmk_core/common/action.c **** 
 457               		.loc 1 785 48 discriminator 22 view .LVU112
 458 015c 8AE8      		ldi r24,lo8(-118)
 459 015e 91E0      		ldi r25,lo8(1)
 460 0160 C13B      		cpi r28,lo8(-79)
 461 0162 01F0      		breq .L16
 785:tmk_core/common/action.c **** 
 462               		.loc 1 785 48 discriminator 24 view .LVU113
 463 0164 82E9      		ldi r24,lo8(-110)
 464 0166 91E0      		ldi r25,lo8(1)
 465 0168 C23B      		cpi r28,lo8(-78)
 466 016a 01F0      		breq .L16
 785:tmk_core/common/action.c **** 
 467               		.loc 1 785 48 discriminator 26 view .LVU114
 468 016c 84E9      		ldi r24,lo8(-108)
 469 016e 91E0      		ldi r25,lo8(1)
 470 0170 C33B      		cpi r28,lo8(-77)
 471 0172 01F0      		breq .L16
 785:tmk_core/common/action.c **** 
 472               		.loc 1 785 48 discriminator 28 view .LVU115
 473 0174 81E2      		ldi r24,lo8(33)
 474 0176 92E0      		ldi r25,lo8(2)
 475 0178 C43B      		cpi r28,lo8(-76)
 476 017a 01F0      		breq .L16
 785:tmk_core/common/action.c **** 
 477               		.loc 1 785 48 discriminator 30 view .LVU116
 478 017c 83E2      		ldi r24,lo8(35)
 479 017e 92E0      		ldi r25,lo8(2)
 480 0180 C53B      		cpi r28,lo8(-75)
 481 0182 01F0      		breq .L16
 785:tmk_core/common/action.c **** 
 482               		.loc 1 785 48 discriminator 32 view .LVU117
 483 0184 84E2      		ldi r24,lo8(36)
 484 0186 92E0      		ldi r25,lo8(2)
 485 0188 C63B      		cpi r28,lo8(-74)
 486 018a 01F0      		breq .L16
 785:tmk_core/common/action.c **** 
 487               		.loc 1 785 48 discriminator 34 view .LVU118
 488 018c 85E2      		ldi r24,lo8(37)
 489 018e 92E0      		ldi r25,lo8(2)
 490 0190 C73B      		cpi r28,lo8(-73)
 491 0192 01F0      		breq .L16
 785:tmk_core/common/action.c **** 
 492               		.loc 1 785 48 discriminator 36 view .LVU119
 493 0194 86E2      		ldi r24,lo8(38)
 494 0196 92E0      		ldi r25,lo8(2)
 495 0198 C83B      		cpi r28,lo8(-72)
 496 019a 01F0      		breq .L16
 785:tmk_core/common/action.c **** 
 497               		.loc 1 785 48 discriminator 38 view .LVU120
 498 019c 87E2      		ldi r24,lo8(39)
 499 019e 92E0      		ldi r25,lo8(2)
 500 01a0 C93B      		cpi r28,lo8(-71)
 501 01a2 01F0      		breq .L16
 785:tmk_core/common/action.c **** 
 502               		.loc 1 785 48 discriminator 40 view .LVU121
 503 01a4 8FE6      		ldi r24,lo8(111)
 504 01a6 90E0      		ldi r25,0
 505 01a8 CD3B      		cpi r28,lo8(-67)
 506 01aa 01F0      		breq .L16
 785:tmk_core/common/action.c **** 
 507               		.loc 1 785 48 discriminator 42 view .LVU122
 508 01ac 80E7      		ldi r24,lo8(112)
 509 01ae 90E0      		ldi r25,0
 510 01b0 CE3B      		cpi r28,lo8(-66)
 511 01b2 01F0      		breq .L16
 785:tmk_core/common/action.c **** 
 512               		.loc 1 785 48 discriminator 44 view .LVU123
 513 01b4 90E0      		ldi r25,0
 514 01b6 80E0      		ldi r24,0
 515 01b8 CA3B      		cpi r28,lo8(-70)
 516 01ba 01F4      		brne .L16
 785:tmk_core/common/action.c **** 
 517               		.loc 1 785 48 view .LVU124
 518 01bc 8AE2      		ldi r24,lo8(42)
 519 01be 92E0      		ldi r25,lo8(2)
 520               	.L16:
 521               	/* epilogue start */
 522               		.loc 1 794 1 discriminator 93 view .LVU125
 523 01c0 CF91      		pop r28
 524               	.LVL34:
 785:tmk_core/common/action.c **** 
 525               		.loc 1 785 29 discriminator 93 view .LVU126
 526 01c2 0C94 0000 		jmp host_consumer_send
 527               	.LVL35:
 528               	.L15:
 788:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 529               		.loc 1 788 10 is_stmt 1 view .LVU127
 789:tmk_core/common/action.c ****             mousekey_on(code);
 530               		.loc 1 789 9 is_stmt 0 view .LVU128
 531 01c6 C03F      		cpi r28,lo8(-16)
 532 01c8 00F0      		brlo .L4
 790:tmk_core/common/action.c ****             mousekey_send();
 533               		.loc 1 790 13 is_stmt 1 view .LVU129
 534 01ca 8C2F      		mov r24,r28
 535 01cc 0E94 0000 		call mousekey_on
 536               	.LVL36:
 791:tmk_core/common/action.c ****         }
 537               		.loc 1 791 13 view .LVU130
 538               	/* epilogue start */
 539               		.loc 1 794 1 is_stmt 0 view .LVU131
 540 01d0 CF91      		pop r28
 541               	.LVL37:
 791:tmk_core/common/action.c ****         }
 542               		.loc 1 791 13 view .LVU132
 543 01d2 0C94 0000 		jmp mousekey_send
 544               	.LVL38:
 545               	.L4:
 546               	/* epilogue start */
 547               		.loc 1 794 1 view .LVU133
 548 01d6 CF91      		pop r28
 549               	.LVL39:
 550               		.loc 1 794 1 view .LVU134
 551 01d8 0895      		ret
 552               		.cfi_endproc
 553               	.LFE19:
 555               		.section	.text.unregister_code,"ax",@progbits
 556               	.global	unregister_code
 558               	unregister_code:
 559               	.LVL40:
 560               	.LFB20:
 795:tmk_core/common/action.c **** 
 796:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 797:tmk_core/common/action.c ****  *
 798:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 799:tmk_core/common/action.c ****  */
 800:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 561               		.loc 1 800 36 is_stmt 1 view -0
 562               		.cfi_startproc
 563               	/* prologue: function */
 564               	/* frame size = 0 */
 565               	/* stack size = 0 */
 566               	.L__stack_usage = 0
 801:tmk_core/common/action.c ****     if (code == KC_NO) {
 567               		.loc 1 801 5 view .LVU136
 568               		.loc 1 801 8 is_stmt 0 view .LVU137
 569 0000 8823      		tst r24
 570 0002 01F4      		brne .+2
 571 0004 00C0      		rjmp .L44
 802:tmk_core/common/action.c ****         return;
 803:tmk_core/common/action.c ****     }
 804:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 805:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 572               		.loc 1 805 10 is_stmt 1 view .LVU138
 573               		.loc 1 805 13 is_stmt 0 view .LVU139
 574 0006 8238      		cpi r24,lo8(-126)
 575 0008 01F4      		brne .L47
 806:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 807:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 808:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 576               		.loc 1 808 9 is_stmt 1 view .LVU140
 577               		.loc 1 808 15 is_stmt 0 view .LVU141
 578 000a 0E94 0000 		call host_keyboard_leds
 579               	.LVL41:
 580               		.loc 1 808 12 view .LVU142
 581 000e 81FF      		sbrs r24,1
 582 0010 00C0      		rjmp .L44
 809:tmk_core/common/action.c **** #    endif
 810:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 583               		.loc 1 810 9 is_stmt 1 view .LVU143
 584 0012 89E3      		ldi r24,lo8(57)
 585 0014 0E94 0000 		call add_key
 586               	.LVL42:
 811:tmk_core/common/action.c ****         send_keyboard_report();
 587               		.loc 1 811 9 view .LVU144
 588 0018 0E94 0000 		call send_keyboard_report
 589               	.LVL43:
 812:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 590               		.loc 1 812 9 view .LVU145
 591 001c 89E3      		ldi r24,lo8(57)
 592               	.L64:
 813:tmk_core/common/action.c ****         send_keyboard_report();
 814:tmk_core/common/action.c ****     }
 815:tmk_core/common/action.c **** 
 816:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 817:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 818:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 819:tmk_core/common/action.c **** #    endif
 820:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 821:tmk_core/common/action.c ****         send_keyboard_report();
 822:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 593               		.loc 1 822 9 is_stmt 0 view .LVU146
 594 001e 0E94 0000 		call del_key
 595               	.LVL44:
 596               	.L65:
 823:tmk_core/common/action.c ****         send_keyboard_report();
 597               		.loc 1 823 9 is_stmt 1 view .LVU147
 598 0022 0C94 0000 		jmp send_keyboard_report
 599               	.LVL45:
 600               	.L47:
 816:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 601               		.loc 1 816 10 view .LVU148
 816:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 602               		.loc 1 816 13 is_stmt 0 view .LVU149
 603 0026 8338      		cpi r24,lo8(-125)
 604 0028 01F4      		brne .L49
 818:tmk_core/common/action.c **** #    endif
 605               		.loc 1 818 9 is_stmt 1 view .LVU150
 818:tmk_core/common/action.c **** #    endif
 606               		.loc 1 818 15 is_stmt 0 view .LVU151
 607 002a 0E94 0000 		call host_keyboard_leds
 608               	.LVL46:
 818:tmk_core/common/action.c **** #    endif
 609               		.loc 1 818 12 view .LVU152
 610 002e 80FF      		sbrs r24,0
 611 0030 00C0      		rjmp .L44
 820:tmk_core/common/action.c ****         send_keyboard_report();
 612               		.loc 1 820 9 is_stmt 1 view .LVU153
 613 0032 83E5      		ldi r24,lo8(83)
 614 0034 0E94 0000 		call add_key
 615               	.LVL47:
 821:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 616               		.loc 1 821 9 view .LVU154
 617 0038 0E94 0000 		call send_keyboard_report
 618               	.LVL48:
 822:tmk_core/common/action.c ****         send_keyboard_report();
 619               		.loc 1 822 9 view .LVU155
 620 003c 83E5      		ldi r24,lo8(83)
 621 003e 00C0      		rjmp .L64
 622               	.LVL49:
 623               	.L49:
 824:tmk_core/common/action.c ****     }
 825:tmk_core/common/action.c **** 
 826:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 624               		.loc 1 826 10 view .LVU156
 625               		.loc 1 826 13 is_stmt 0 view .LVU157
 626 0040 8438      		cpi r24,lo8(-124)
 627 0042 01F4      		brne .L50
 827:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 828:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 628               		.loc 1 828 9 is_stmt 1 view .LVU158
 629               		.loc 1 828 15 is_stmt 0 view .LVU159
 630 0044 0E94 0000 		call host_keyboard_leds
 631               	.LVL50:
 632               		.loc 1 828 12 view .LVU160
 633 0048 82FF      		sbrs r24,2
 634 004a 00C0      		rjmp .L44
 829:tmk_core/common/action.c **** #    endif
 830:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 635               		.loc 1 830 9 is_stmt 1 view .LVU161
 636 004c 87E4      		ldi r24,lo8(71)
 637 004e 0E94 0000 		call add_key
 638               	.LVL51:
 831:tmk_core/common/action.c ****         send_keyboard_report();
 639               		.loc 1 831 9 view .LVU162
 640 0052 0E94 0000 		call send_keyboard_report
 641               	.LVL52:
 832:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 642               		.loc 1 832 9 view .LVU163
 643 0056 87E4      		ldi r24,lo8(71)
 644 0058 00C0      		rjmp .L64
 645               	.LVL53:
 646               	.L50:
 833:tmk_core/common/action.c ****         send_keyboard_report();
 834:tmk_core/common/action.c ****     }
 835:tmk_core/common/action.c **** #endif
 836:tmk_core/common/action.c **** 
 837:tmk_core/common/action.c ****     else if
 647               		.loc 1 837 10 view .LVU164
 838:tmk_core/common/action.c ****         IS_KEY(code) {
 648               		.loc 1 838 9 is_stmt 0 view .LVU165
 649 005a 9CEF      		ldi r25,lo8(-4)
 650 005c 980F      		add r25,r24
 651 005e 913A      		cpi r25,lo8(-95)
 652 0060 00F0      		brlo .L64
 839:tmk_core/common/action.c ****             del_key(code);
 840:tmk_core/common/action.c ****             send_keyboard_report();
 841:tmk_core/common/action.c ****         }
 842:tmk_core/common/action.c ****     else if
 653               		.loc 1 842 10 is_stmt 1 view .LVU166
 843:tmk_core/common/action.c ****         IS_MOD(code) {
 654               		.loc 1 843 9 is_stmt 0 view .LVU167
 655 0062 90E2      		ldi r25,lo8(32)
 656 0064 980F      		add r25,r24
 657 0066 9830      		cpi r25,lo8(8)
 658 0068 00F4      		brsh .L52
 844:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 659               		.loc 1 844 13 is_stmt 1 view .LVU168
 660               		.loc 1 844 22 is_stmt 0 view .LVU169
 661 006a 8770      		andi r24,lo8(7)
 662               	.LVL54:
 663               		.loc 1 844 13 view .LVU170
 664 006c 91E0      		ldi r25,lo8(1)
 665 006e 00C0      		rjmp 2f
 666               		1:
 667 0070 990F      		lsl r25
 668               		2:
 669 0072 8A95      		dec r24
 670 0074 02F4      		brpl 1b
 671 0076 892F      		mov r24,r25
 672 0078 0E94 0000 		call del_mods
 673               	.LVL55:
 845:tmk_core/common/action.c ****             send_keyboard_report();
 674               		.loc 1 845 13 is_stmt 1 view .LVU171
 675 007c 00C0      		rjmp .L65
 676               	.LVL56:
 677               	.L52:
 846:tmk_core/common/action.c ****         }
 847:tmk_core/common/action.c ****     else if
 678               		.loc 1 847 10 view .LVU172
 848:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(0); }
 679               		.loc 1 848 9 is_stmt 0 view .LVU173
 680 007e 9BE5      		ldi r25,lo8(91)
 681 0080 980F      		add r25,r24
 682 0082 9330      		cpi r25,lo8(3)
 683 0084 00F4      		brsh .L53
 684               		.loc 1 848 27 is_stmt 1 discriminator 1 view .LVU174
 685 0086 90E0      		ldi r25,0
 686 0088 80E0      		ldi r24,0
 687               	.LVL57:
 688               		.loc 1 848 27 is_stmt 0 discriminator 1 view .LVU175
 689 008a 0C94 0000 		jmp host_system_send
 690               	.LVL58:
 691               	.L53:
 849:tmk_core/common/action.c ****     else if
 692               		.loc 1 849 10 is_stmt 1 view .LVU176
 850:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(0); }
 693               		.loc 1 850 9 is_stmt 0 view .LVU177
 694 008e 98E5      		ldi r25,lo8(88)
 695 0090 980F      		add r25,r24
 696 0092 9731      		cpi r25,lo8(23)
 697 0094 00F4      		brsh .L54
 698               		.loc 1 850 29 is_stmt 1 discriminator 1 view .LVU178
 699 0096 90E0      		ldi r25,0
 700 0098 80E0      		ldi r24,0
 701               	.LVL59:
 702               		.loc 1 850 29 is_stmt 0 discriminator 1 view .LVU179
 703 009a 0C94 0000 		jmp host_consumer_send
 704               	.LVL60:
 705               	.L54:
 851:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 852:tmk_core/common/action.c ****     else if
 706               		.loc 1 852 10 is_stmt 1 view .LVU180
 853:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 707               		.loc 1 853 9 is_stmt 0 view .LVU181
 708 009e 803F      		cpi r24,lo8(-16)
 709 00a0 00F0      		brlo .L44
 854:tmk_core/common/action.c ****             mousekey_off(code);
 710               		.loc 1 854 13 is_stmt 1 view .LVU182
 711 00a2 0E94 0000 		call mousekey_off
 712               	.LVL61:
 855:tmk_core/common/action.c ****             mousekey_send();
 713               		.loc 1 855 13 view .LVU183
 714 00a6 0C94 0000 		jmp mousekey_send
 715               	.LVL62:
 716               	.L44:
 717               	/* epilogue start */
 856:tmk_core/common/action.c ****         }
 857:tmk_core/common/action.c **** #endif
 858:tmk_core/common/action.c **** }
 718               		.loc 1 858 1 is_stmt 0 view .LVU184
 719 00aa 0895      		ret
 720               		.cfi_endproc
 721               	.LFE20:
 723               		.section	.text.tap_code,"ax",@progbits
 724               	.global	tap_code
 726               	tap_code:
 727               	.LVL63:
 728               	.LFB21:
 859:tmk_core/common/action.c **** 
 860:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 861:tmk_core/common/action.c ****  *
 862:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 863:tmk_core/common/action.c ****  */
 864:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 729               		.loc 1 864 29 is_stmt 1 view -0
 730               		.cfi_startproc
 731               		.loc 1 864 29 is_stmt 0 view .LVU186
 732 0000 CF93      		push r28
 733               	.LCFI5:
 734               		.cfi_def_cfa_offset 3
 735               		.cfi_offset 28, -2
 736               	/* prologue: function */
 737               	/* frame size = 0 */
 738               	/* stack size = 1 */
 739               	.L__stack_usage = 1
 740 0002 C82F      		mov r28,r24
 865:tmk_core/common/action.c ****     register_code(code);
 741               		.loc 1 865 5 is_stmt 1 view .LVU187
 742 0004 0E94 0000 		call register_code
 743               	.LVL64:
 866:tmk_core/common/action.c ****     if (code == KC_CAPS) {
 744               		.loc 1 866 5 view .LVU188
 745               		.loc 1 866 8 is_stmt 0 view .LVU189
 746 0008 C933      		cpi r28,lo8(57)
 747 000a 01F4      		brne .L68
 867:tmk_core/common/action.c ****         wait_ms(TAP_HOLD_CAPS_DELAY);
 748               		.loc 1 867 9 is_stmt 1 view .LVU190
 749               	.LVL65:
 750               	.LBB28:
 751               	.LBI28:
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 752               		.loc 2 166 1 view .LVU191
 753               	.LBB29:
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 754               		.loc 2 168 2 view .LVU192
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 755               		.loc 2 172 2 view .LVU193
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 756               		.loc 2 173 2 view .LVU194
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 757               		.loc 2 174 2 view .LVU195
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 758               		.loc 2 184 3 view .LVU196
 759               		.loc 2 187 2 view .LVU197
 760 000c 2FEF      		ldi r18,lo8(255999)
 761 000e 87EE      		ldi r24,hi8(255999)
 762 0010 93E0      		ldi r25,hlo8(255999)
 763 0012 2150      	1:	subi r18,1
 764 0014 8040      		sbci r24,0
 765 0016 9040      		sbci r25,0
 766 0018 01F4      		brne 1b
 767 001a 00C0      		rjmp .
 768 001c 0000      		nop
 769               	.LVL66:
 770               	.L68:
 771               		.loc 2 187 2 is_stmt 0 view .LVU198
 772               	.LBE29:
 773               	.LBE28:
 868:tmk_core/common/action.c ****     } else {
 869:tmk_core/common/action.c ****         wait_ms(TAP_CODE_DELAY);
 870:tmk_core/common/action.c ****     }
 871:tmk_core/common/action.c ****     unregister_code(code);
 774               		.loc 1 871 5 is_stmt 1 view .LVU199
 775 001e 8C2F      		mov r24,r28
 776               	/* epilogue start */
 872:tmk_core/common/action.c **** }
 777               		.loc 1 872 1 is_stmt 0 view .LVU200
 778 0020 CF91      		pop r28
 779               	.LVL67:
 871:tmk_core/common/action.c **** }
 780               		.loc 1 871 5 view .LVU201
 781 0022 0C94 0000 		jmp unregister_code
 782               	.LVL68:
 871:tmk_core/common/action.c **** }
 783               		.loc 1 871 5 view .LVU202
 784               		.cfi_endproc
 785               	.LFE21:
 787               		.section	.text.register_mods,"ax",@progbits
 788               	.global	register_mods
 790               	register_mods:
 791               	.LVL69:
 792               	.LFB22:
 873:tmk_core/common/action.c **** 
 874:tmk_core/common/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 875:tmk_core/common/action.c ****  *
 876:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 877:tmk_core/common/action.c ****  */
 878:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 793               		.loc 1 878 34 is_stmt 1 view -0
 794               		.cfi_startproc
 795               	/* prologue: function */
 796               	/* frame size = 0 */
 797               	/* stack size = 0 */
 798               	.L__stack_usage = 0
 879:tmk_core/common/action.c ****     if (mods) {
 799               		.loc 1 879 5 view .LVU204
 800               		.loc 1 879 8 is_stmt 0 view .LVU205
 801 0000 8823      		tst r24
 802 0002 01F0      		breq .L69
 880:tmk_core/common/action.c ****         add_mods(mods);
 803               		.loc 1 880 9 is_stmt 1 view .LVU206
 804 0004 0E94 0000 		call add_mods
 805               	.LVL70:
 881:tmk_core/common/action.c ****         send_keyboard_report();
 806               		.loc 1 881 9 view .LVU207
 807 0008 0C94 0000 		jmp send_keyboard_report
 808               	.LVL71:
 809               	.L69:
 810               	/* epilogue start */
 882:tmk_core/common/action.c ****     }
 883:tmk_core/common/action.c **** }
 811               		.loc 1 883 1 is_stmt 0 view .LVU208
 812 000c 0895      		ret
 813               		.cfi_endproc
 814               	.LFE22:
 816               		.section	.text.unregister_mods,"ax",@progbits
 817               	.global	unregister_mods
 819               	unregister_mods:
 820               	.LVL72:
 821               	.LFB23:
 884:tmk_core/common/action.c **** 
 885:tmk_core/common/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 886:tmk_core/common/action.c ****  *
 887:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 888:tmk_core/common/action.c ****  */
 889:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 822               		.loc 1 889 36 is_stmt 1 view -0
 823               		.cfi_startproc
 824               	/* prologue: function */
 825               	/* frame size = 0 */
 826               	/* stack size = 0 */
 827               	.L__stack_usage = 0
 890:tmk_core/common/action.c ****     if (mods) {
 828               		.loc 1 890 5 view .LVU210
 829               		.loc 1 890 8 is_stmt 0 view .LVU211
 830 0000 8823      		tst r24
 831 0002 01F0      		breq .L71
 891:tmk_core/common/action.c ****         del_mods(mods);
 832               		.loc 1 891 9 is_stmt 1 view .LVU212
 833 0004 0E94 0000 		call del_mods
 834               	.LVL73:
 892:tmk_core/common/action.c ****         send_keyboard_report();
 835               		.loc 1 892 9 view .LVU213
 836 0008 0C94 0000 		jmp send_keyboard_report
 837               	.LVL74:
 838               	.L71:
 839               	/* epilogue start */
 893:tmk_core/common/action.c ****     }
 894:tmk_core/common/action.c **** }
 840               		.loc 1 894 1 is_stmt 0 view .LVU214
 841 000c 0895      		ret
 842               		.cfi_endproc
 843               	.LFE23:
 845               		.section	.text.process_action,"ax",@progbits
 846               	.global	process_action
 848               	process_action:
 849               	.LVL75:
 850               	.LFB18:
 200:tmk_core/common/action.c ****     keyevent_t event = record->event;
 851               		.loc 1 200 59 is_stmt 1 view -0
 852               		.cfi_startproc
 200:tmk_core/common/action.c ****     keyevent_t event = record->event;
 853               		.loc 1 200 59 is_stmt 0 view .LVU216
 854 0000 BF92      		push r11
 855               	.LCFI6:
 856               		.cfi_def_cfa_offset 3
 857               		.cfi_offset 11, -2
 858 0002 CF92      		push r12
 859               	.LCFI7:
 860               		.cfi_def_cfa_offset 4
 861               		.cfi_offset 12, -3
 862 0004 DF92      		push r13
 863               	.LCFI8:
 864               		.cfi_def_cfa_offset 5
 865               		.cfi_offset 13, -4
 866 0006 EF92      		push r14
 867               	.LCFI9:
 868               		.cfi_def_cfa_offset 6
 869               		.cfi_offset 14, -5
 870 0008 FF92      		push r15
 871               	.LCFI10:
 872               		.cfi_def_cfa_offset 7
 873               		.cfi_offset 15, -6
 874 000a 0F93      		push r16
 875               	.LCFI11:
 876               		.cfi_def_cfa_offset 8
 877               		.cfi_offset 16, -7
 878 000c 1F93      		push r17
 879               	.LCFI12:
 880               		.cfi_def_cfa_offset 9
 881               		.cfi_offset 17, -8
 882 000e CF93      		push r28
 883               	.LCFI13:
 884               		.cfi_def_cfa_offset 10
 885               		.cfi_offset 28, -9
 886 0010 DF93      		push r29
 887               	.LCFI14:
 888               		.cfi_def_cfa_offset 11
 889               		.cfi_offset 29, -10
 890               	/* prologue: function */
 891               	/* frame size = 0 */
 892               	/* stack size = 9 */
 893               	.L__stack_usage = 9
 894 0012 6C01      		movw r12,r24
 895 0014 D62F      		mov r29,r22
 200:tmk_core/common/action.c ****     keyevent_t event = record->event;
 896               		.loc 1 200 59 view .LVU217
 897 0016 C72F      		mov r28,r23
 201:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 898               		.loc 1 201 5 is_stmt 1 view .LVU218
 899               	.LVL76:
 203:tmk_core/common/action.c **** #endif
 900               		.loc 1 203 5 view .LVU219
 203:tmk_core/common/action.c **** #endif
 901               		.loc 1 203 36 is_stmt 0 view .LVU220
 902 0018 FC01      		movw r30,r24
 903 001a 0581      		ldd r16,Z+5
 904 001c 0295      		swap r16
 905 001e 0F70      		andi r16,lo8(15)
 906               	.LVL77:
 206:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 907               		.loc 1 206 5 is_stmt 1 view .LVU221
 206:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 908               		.loc 1 206 14 is_stmt 0 view .LVU222
 909 0020 1281      		ldd r17,Z+2
 206:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 910               		.loc 1 206 8 view .LVU223
 911 0022 1111      		cpse r17,__zero_reg__
 208:tmk_core/common/action.c ****     }
 912               		.loc 1 208 9 is_stmt 1 view .LVU224
 913 0024 0E94 0000 		call clear_weak_mods
 914               	.LVL78:
 915               	.L74:
 212:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 916               		.loc 1 212 5 view .LVU225
 214:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 917               		.loc 1 214 5 view .LVU226
 214:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 918               		.loc 1 214 9 is_stmt 0 view .LVU227
 919 0028 0E94 0000 		call is_oneshot_layer_active
 920               	.LVL79:
 214:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 921               		.loc 1 214 9 view .LVU228
 922 002c E82E      		mov r14,r24
 214:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 923               		.loc 1 214 8 view .LVU229
 924 002e 8823      		tst r24
 925 0030 01F0      		breq .L75
 214:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 926               		.loc 1 214 35 discriminator 1 view .LVU230
 927 0032 1123      		tst r17
 928 0034 01F0      		breq .L158
 214:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 929               		.loc 1 214 55 discriminator 2 view .LVU231
 930 0036 80E2      		ldi r24,lo8(32)
 214:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 931               		.loc 1 214 55 discriminator 2 view .LVU232
 932 0038 8D0F      		add r24,r29
 214:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 933               		.loc 1 214 52 discriminator 2 view .LVU233
 934 003a 8830      		cpi r24,lo8(8)
 935 003c 00F0      		brlo .L158
 215:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 936               		.loc 1 215 9 is_stmt 1 view .LVU234
 937 003e 82E0      		ldi r24,lo8(2)
 938 0040 0E94 0000 		call clear_oneshot_layer_state
 939               	.LVL80:
 216:tmk_core/common/action.c ****     }
 940               		.loc 1 216 9 view .LVU235
 216:tmk_core/common/action.c ****     }
 941               		.loc 1 216 31 is_stmt 0 view .LVU236
 942 0044 0E94 0000 		call is_oneshot_layer_active
 943               	.LVL81:
 216:tmk_core/common/action.c ****     }
 944               		.loc 1 216 9 view .LVU237
 945 0048 91E0      		ldi r25,lo8(1)
 946 004a E82E      		mov r14,r24
 947 004c E926      		eor r14,r25
 948               	.LVL82:
 949               	.L75:
 220:tmk_core/common/action.c ****         /* Key and Mods */
 950               		.loc 1 220 5 is_stmt 1 view .LVU238
 220:tmk_core/common/action.c ****         /* Key and Mods */
 951               		.loc 1 220 24 is_stmt 0 view .LVU239
 952 004e BC2E      		mov r11,r28
 953 0050 B294      		swap r11
 954 0052 9FE0      		ldi r25,lo8(15)
 955 0054 B922      		and r11,r25
 220:tmk_core/common/action.c ****         /* Key and Mods */
 956               		.loc 1 220 5 view .LVU240
 957 0056 EB2D      		mov r30,r11
 958 0058 F0E0      		ldi r31,0
 959 005a E050      		subi r30,lo8(-(gs(.L78)))
 960 005c F040      		sbci r31,hi8(-(gs(.L78)))
 961 005e 0C94 0000 		jmp __tablejump2__
 962               		.section	.jumptables.gcc.process_action,"a",@progbits
 963               		.p2align	1
 964               	.L78:
 965 0000 0000      		.word gs(.L86)
 966 0002 0000      		.word gs(.L86)
 967 0004 0000      		.word gs(.L85)
 968 0006 0000      		.word gs(.L85)
 969 0008 0000      		.word gs(.L84)
 970 000a 0000      		.word gs(.L83)
 971 000c 0000      		.word gs(.L76)
 972 000e 0000      		.word gs(.L76)
 973 0010 0000      		.word gs(.L82)
 974 0012 0000      		.word gs(.L81)
 975 0014 0000      		.word gs(.L80)
 976 0016 0000      		.word gs(.L80)
 977 0018 0000      		.word gs(.L79)
 978 001a 0000      		.word gs(.L76)
 979 001c 0000      		.word gs(.L76)
 980 001e 0000      		.word gs(.L77)
 981               		.section	.text.process_action
 982               	.LVL83:
 983               	.L158:
 212:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 984               		.loc 1 212 10 view .LVU241
 985 0062 E12C      		mov r14,__zero_reg__
 986 0064 00C0      		rjmp .L75
 987               	.LVL84:
 988               	.L86:
 989               	.LBB30:
 224:tmk_core/common/action.c ****             if (event.pressed) {
 990               		.loc 1 224 13 is_stmt 1 view .LVU242
 991 0066 0C2F      		mov r16,r28
 992               	.LVL85:
 224:tmk_core/common/action.c ****             if (event.pressed) {
 993               		.loc 1 224 13 is_stmt 0 view .LVU243
 994 0068 0F70      		andi r16,lo8(15)
 224:tmk_core/common/action.c ****             if (event.pressed) {
 995               		.loc 1 224 44 view .LVU244
 996 006a C07F      		andi r28,lo8(-16)
 997               	.LVL86:
 224:tmk_core/common/action.c ****             if (event.pressed) {
 998               		.loc 1 224 21 view .LVU245
 999 006c 01F0      		breq .L87
 224:tmk_core/common/action.c ****             if (event.pressed) {
 1000               		.loc 1 224 21 discriminator 2 view .LVU246
 1001 006e 0295      		swap r16
 1002 0070 007F      		andi r16,lo8(-16)
 1003               	.L87:
 1004               	.LVL87:
 225:tmk_core/common/action.c ****                 if (mods) {
 1005               		.loc 1 225 13 is_stmt 1 discriminator 4 view .LVU247
 225:tmk_core/common/action.c ****                 if (mods) {
 1006               		.loc 1 225 16 is_stmt 0 discriminator 4 view .LVU248
 1007 0072 1123      		tst r17
 1008 0074 01F0      		breq .L88
 226:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1009               		.loc 1 226 17 is_stmt 1 view .LVU249
 226:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1010               		.loc 1 226 20 is_stmt 0 view .LVU250
 1011 0076 0023      		tst r16
 1012 0078 01F0      		breq .L190
 227:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1013               		.loc 1 227 21 is_stmt 1 view .LVU251
 227:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1014               		.loc 1 227 25 is_stmt 0 view .LVU252
 1015 007a 80E2      		ldi r24,lo8(32)
 1016 007c 8D0F      		add r24,r29
 227:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1017               		.loc 1 227 24 view .LVU253
 1018 007e 8830      		cpi r24,lo8(8)
 1019 0080 00F0      		brlo .L90
 227:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1020               		.loc 1 227 49 discriminator 1 view .LVU254
 1021 0082 D111      		cpse r29,__zero_reg__
 1022 0084 00C0      		rjmp .L91
 1023               	.L90:
 231:tmk_core/common/action.c ****                     } else {
 1024               		.loc 1 231 25 is_stmt 1 view .LVU255
 1025 0086 802F      		mov r24,r16
 1026 0088 0E94 0000 		call add_mods
 1027               	.LVL88:
 1028               	.L92:
 235:tmk_core/common/action.c ****                 }
 1029               		.loc 1 235 21 view .LVU256
 1030 008c 0E94 0000 		call send_keyboard_report
 1031               	.LVL89:
 237:tmk_core/common/action.c ****             } else {
 1032               		.loc 1 237 17 view .LVU257
 1033               	.L190:
 237:tmk_core/common/action.c ****             } else {
 1034               		.loc 1 237 17 is_stmt 0 view .LVU258
 1035               	.LBE30:
 524:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 1036               		.loc 1 524 75 is_stmt 1 view .LVU259
 525:tmk_core/common/action.c ****                         } else {
 1037               		.loc 1 525 29 view .LVU260
 1038 0090 8D2F      		mov r24,r29
 1039 0092 0E94 0000 		call register_code
 1040               	.LVL90:
 1041 0096 00C0      		rjmp .L76
 1042               	.LVL91:
 1043               	.L91:
 1044               	.LBB31:
 233:tmk_core/common/action.c ****                     }
 1045               		.loc 1 233 25 view .LVU261
 1046 0098 802F      		mov r24,r16
 1047 009a 0E94 0000 		call add_weak_mods
 1048               	.LVL92:
 1049 009e 00C0      		rjmp .L92
 1050               	.L88:
 239:tmk_core/common/action.c ****                 if (mods) {
 1051               		.loc 1 239 17 view .LVU262
 1052 00a0 8D2F      		mov r24,r29
 1053 00a2 0E94 0000 		call unregister_code
 1054               	.LVL93:
 240:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1055               		.loc 1 240 17 view .LVU263
 240:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1056               		.loc 1 240 20 is_stmt 0 view .LVU264
 1057 00a6 0023      		tst r16
 1058 00a8 01F0      		breq .L76
 241:tmk_core/common/action.c ****                         del_mods(mods);
 1059               		.loc 1 241 21 is_stmt 1 view .LVU265
 241:tmk_core/common/action.c ****                         del_mods(mods);
 1060               		.loc 1 241 25 is_stmt 0 view .LVU266
 1061 00aa 80E2      		ldi r24,lo8(32)
 1062 00ac 8D0F      		add r24,r29
 241:tmk_core/common/action.c ****                         del_mods(mods);
 1063               		.loc 1 241 24 view .LVU267
 1064 00ae 8830      		cpi r24,lo8(8)
 1065 00b0 00F0      		brlo .L94
 241:tmk_core/common/action.c ****                         del_mods(mods);
 1066               		.loc 1 241 49 discriminator 1 view .LVU268
 1067 00b2 D111      		cpse r29,__zero_reg__
 1068 00b4 00C0      		rjmp .L95
 1069               	.L94:
 242:tmk_core/common/action.c ****                     } else {
 1070               		.loc 1 242 25 is_stmt 1 view .LVU269
 1071 00b6 802F      		mov r24,r16
 1072 00b8 0E94 0000 		call del_mods
 1073               	.LVL94:
 1074               	.L96:
 246:tmk_core/common/action.c ****                 }
 1075               		.loc 1 246 21 view .LVU270
 1076 00bc 0E94 0000 		call send_keyboard_report
 1077               	.LVL95:
 1078               	.L76:
 246:tmk_core/common/action.c ****                 }
 1079               		.loc 1 246 21 is_stmt 0 view .LVU271
 1080               	.LBE31:
 657:tmk_core/common/action.c ****         case ACT_LAYER:
 1081               		.loc 1 657 5 is_stmt 1 view .LVU272
 1082 00c0 2B2D      		mov r18,r11
 1083 00c2 2850      		subi r18,8
 1084 00c4 330B      		sbc r19,r19
 1085 00c6 2430      		cpi r18,4
 1086 00c8 3105      		cpc r19,__zero_reg__
 1087 00ca 00F4      		brsh .L153
 664:tmk_core/common/action.c ****             break;
 1088               		.loc 1 664 13 view .LVU273
 1089 00cc 0E94 0000 		call host_keyboard_leds
 1090               	.LVL96:
 1091 00d0 0E94 0000 		call led_set
 1092               	.LVL97:
 665:tmk_core/common/action.c ****         default:
 1093               		.loc 1 665 13 view .LVU274
 1094               	.L153:
 699:tmk_core/common/action.c ****         record->event.pressed = false;
 1095               		.loc 1 699 5 view .LVU275
 699:tmk_core/common/action.c ****         record->event.pressed = false;
 1096               		.loc 1 699 8 is_stmt 0 view .LVU276
 1097 00d4 EE20      		tst r14
 1098 00d6 01F4      		brne .+2
 1099 00d8 00C0      		rjmp .L73
 699:tmk_core/common/action.c ****         record->event.pressed = false;
 1100               		.loc 1 699 33 discriminator 1 view .LVU277
 1101 00da 0E94 0000 		call get_oneshot_layer_state
 1102               	.LVL98:
 699:tmk_core/common/action.c ****         record->event.pressed = false;
 1103               		.loc 1 699 28 discriminator 1 view .LVU278
 1104 00de 80FD      		sbrc r24,0
 1105 00e0 00C0      		rjmp .L73
 700:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1106               		.loc 1 700 9 is_stmt 1 view .LVU279
 700:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1107               		.loc 1 700 31 is_stmt 0 view .LVU280
 1108 00e2 F601      		movw r30,r12
 1109 00e4 1282      		std Z+2,__zero_reg__
 701:tmk_core/common/action.c ****         process_record(record);
 1110               		.loc 1 701 9 is_stmt 1 view .LVU281
 1111 00e6 0E94 0000 		call get_oneshot_layer
 1112               	.LVL99:
 1113 00ea 0E94 0000 		call layer_on
 1114               	.LVL100:
 702:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 1115               		.loc 1 702 9 view .LVU282
 1116 00ee C601      		movw r24,r12
 1117 00f0 0E94 0000 		call process_record
 1118               	.LVL101:
 703:tmk_core/common/action.c ****     }
 1119               		.loc 1 703 9 view .LVU283
 1120 00f4 0E94 0000 		call get_oneshot_layer
 1121               	.LVL102:
 1122               	/* epilogue start */
 706:tmk_core/common/action.c **** 
 1123               		.loc 1 706 1 is_stmt 0 view .LVU284
 1124 00f8 DF91      		pop r29
 1125               	.LVL103:
 706:tmk_core/common/action.c **** 
 1126               		.loc 1 706 1 view .LVU285
 1127 00fa CF91      		pop r28
 706:tmk_core/common/action.c **** 
 1128               		.loc 1 706 1 view .LVU286
 1129 00fc 1F91      		pop r17
 1130 00fe 0F91      		pop r16
 1131 0100 FF90      		pop r15
 1132 0102 EF90      		pop r14
 1133               	.LVL104:
 706:tmk_core/common/action.c **** 
 1134               		.loc 1 706 1 view .LVU287
 1135 0104 DF90      		pop r13
 1136 0106 CF90      		pop r12
 1137               	.LVL105:
 706:tmk_core/common/action.c **** 
 1138               		.loc 1 706 1 view .LVU288
 1139 0108 BF90      		pop r11
 703:tmk_core/common/action.c ****     }
 1140               		.loc 1 703 9 view .LVU289
 1141 010a 0C94 0000 		jmp layer_off
 1142               	.LVL106:
 1143               	.L95:
 1144               	.LBB32:
 244:tmk_core/common/action.c ****                     }
 1145               		.loc 1 244 25 is_stmt 1 view .LVU290
 1146 010e 802F      		mov r24,r16
 1147 0110 0E94 0000 		call del_weak_mods
 1148               	.LVL107:
 1149 0114 00C0      		rjmp .L96
 1150               	.LVL108:
 1151               	.L85:
 244:tmk_core/common/action.c ****                     }
 1152               		.loc 1 244 25 is_stmt 0 view .LVU291
 1153               	.LBE32:
 1154               	.LBB33:
 253:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1155               		.loc 1 253 13 is_stmt 1 view .LVU292
 1156 0116 FC2F      		mov r31,r28
 1157 0118 FF70      		andi r31,lo8(15)
 1158 011a FF2E      		mov r15,r31
 253:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1159               		.loc 1 253 44 is_stmt 0 view .LVU293
 1160 011c C07F      		andi r28,lo8(-16)
 1161               	.LVL109:
 253:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1162               		.loc 1 253 21 view .LVU294
 1163 011e C032      		cpi r28,lo8(32)
 1164 0120 01F0      		breq .L97
 253:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1165               		.loc 1 253 21 discriminator 2 view .LVU295
 1166 0122 F294      		swap r15
 1167 0124 80EF      		ldi r24,lo8(-16)
 1168 0126 F822      		and r15,r24
 1169               	.L97:
 1170               	.LVL110:
 254:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 1171               		.loc 1 254 13 is_stmt 1 discriminator 4 view .LVU296
 1172 0128 DD23      		tst r29
 1173 012a 01F0      		breq .L98
 1174 012c D130      		cpi r29,lo8(1)
 1175 012e 01F0      		breq .L99
 309:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1176               		.loc 1 309 21 view .LVU297
 309:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1177               		.loc 1 309 24 is_stmt 0 view .LVU298
 1178 0130 1123      		tst r17
 1179 0132 01F0      		breq .L107
 310:tmk_core/common/action.c **** #    ifndef IGNORE_MOD_TAP_INTERRUPT
 1180               		.loc 1 310 25 is_stmt 1 view .LVU299
 310:tmk_core/common/action.c **** #    ifndef IGNORE_MOD_TAP_INTERRUPT
 1181               		.loc 1 310 28 is_stmt 0 view .LVU300
 1182 0134 0023      		tst r16
 1183 0136 01F0      		breq .L108
 312:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 1184               		.loc 1 312 29 is_stmt 1 view .LVU301
 312:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 1185               		.loc 1 312 33 is_stmt 0 view .LVU302
 1186 0138 F601      		movw r30,r12
 1187 013a 8581      		ldd r24,Z+5
 312:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 1188               		.loc 1 312 32 view .LVU303
 1189 013c 80FF      		sbrs r24,0
 1190 013e 00C0      		rjmp .L190
 313:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 1191               		.loc 1 313 76 is_stmt 1 view .LVU304
 315:tmk_core/common/action.c ****                                 register_mods(mods);
 1192               		.loc 1 315 33 view .LVU305
 315:tmk_core/common/action.c ****                                 register_mods(mods);
 1193               		.loc 1 315 51 is_stmt 0 view .LVU306
 1194 0140 8F70      		andi r24,lo8(15)
 1195 0142 8583      		std Z+5,r24
 316:tmk_core/common/action.c ****                             } else
 1196               		.loc 1 316 33 is_stmt 1 view .LVU307
 1197 0144 00C0      		rjmp .L108
 1198               	.L98:
 258:tmk_core/common/action.c ****                         if (tap_count == 0) {
 1199               		.loc 1 258 21 view .LVU308
 258:tmk_core/common/action.c ****                         if (tap_count == 0) {
 1200               		.loc 1 258 24 is_stmt 0 view .LVU309
 1201 0146 1123      		tst r17
 1202 0148 01F0      		breq .L101
 259:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1203               		.loc 1 259 25 is_stmt 1 view .LVU310
 259:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1204               		.loc 1 259 28 is_stmt 0 view .LVU311
 1205 014a 0111      		cpse r16,__zero_reg__
 1206 014c 00C0      		rjmp .L102
 1207               	.L103:
 273:tmk_core/common/action.c ****                         }
 1208               		.loc 1 273 29 is_stmt 1 view .LVU312
 273:tmk_core/common/action.c ****                         }
 1209               		.loc 1 273 50 is_stmt 0 view .LVU313
 1210 014e 0E94 0000 		call get_oneshot_mods
 1211               	.LVL111:
 273:tmk_core/common/action.c ****                         }
 1212               		.loc 1 273 29 view .LVU314
 1213 0152 8F29      		or r24,r15
 1214               	.LVL112:
 1215               	.L189:
 273:tmk_core/common/action.c ****                         }
 1216               		.loc 1 273 29 view .LVU315
 1217               	.LBE33:
 451:tmk_core/common/action.c ****             } else {
 1218               		.loc 1 451 17 view .LVU316
 1219 0154 0E94 0000 		call register_mods
 1220               	.LVL113:
 1221 0158 00C0      		rjmp .L76
 1222               	.LVL114:
 1223               	.L102:
 1224               	.LBB36:
 262:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1225               		.loc 1 262 32 is_stmt 1 view .LVU317
 262:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1226               		.loc 1 262 35 is_stmt 0 view .LVU318
 1227 015a 0130      		cpi r16,lo8(1)
 1228 015c 01F4      		brne .L103
 263:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 1229               		.loc 1 263 65 is_stmt 1 view .LVU319
 264:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1230               		.loc 1 264 29 view .LVU320
 264:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1231               		.loc 1 264 53 is_stmt 0 view .LVU321
 1232 015e 0E94 0000 		call get_oneshot_mods
 1233               	.LVL115:
 264:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1234               		.loc 1 264 29 view .LVU322
 1235 0162 8F29      		or r24,r15
 1236 0164 0E94 0000 		call set_oneshot_mods
 1237               	.LVL116:
 1238 0168 00C0      		rjmp .L76
 1239               	.L101:
 276:tmk_core/common/action.c ****                             clear_oneshot_mods();
 1240               		.loc 1 276 25 is_stmt 1 view .LVU323
 276:tmk_core/common/action.c ****                             clear_oneshot_mods();
 1241               		.loc 1 276 28 is_stmt 0 view .LVU324
 1242 016a 0111      		cpse r16,__zero_reg__
 1243 016c 00C0      		rjmp .L104
 1244               	.L192:
 291:tmk_core/common/action.c ****                             unregister_mods(mods);
 1245               		.loc 1 291 29 is_stmt 1 view .LVU325
 1246 016e 0E94 0000 		call clear_oneshot_mods
 1247               	.LVL117:
 292:tmk_core/common/action.c ****                         }
 1248               		.loc 1 292 29 view .LVU326
 1249               	.L110:
 335:tmk_core/common/action.c ****                             unregister_mods(mods);
 1250               		.loc 1 335 67 view .LVU327
 336:tmk_core/common/action.c ****                         }
 1251               		.loc 1 336 29 view .LVU328
 1252 0172 8F2D      		mov r24,r15
 1253 0174 0E94 0000 		call unregister_mods
 1254               	.LVL118:
 1255 0178 00C0      		rjmp .L76
 1256               	.L104:
 279:tmk_core/common/action.c ****                             // Retain Oneshot mods
 1257               		.loc 1 279 32 view .LVU329
 279:tmk_core/common/action.c ****                             // Retain Oneshot mods
 1258               		.loc 1 279 35 is_stmt 0 view .LVU330
 1259 017a 0130      		cpi r16,lo8(1)
 1260 017c 01F4      		brne .+2
 1261 017e 00C0      		rjmp .L76
 1262 0180 00C0      		rjmp .L192
 1263               	.L99:
 298:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1264               		.loc 1 298 21 is_stmt 1 view .LVU331
 298:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1265               		.loc 1 298 24 is_stmt 0 view .LVU332
 1266 0182 1123      		tst r17
 1267 0184 01F0      		breq .L106
 299:tmk_core/common/action.c ****                             register_mods(mods);
 1268               		.loc 1 299 25 is_stmt 1 view .LVU333
 299:tmk_core/common/action.c ****                             register_mods(mods);
 1269               		.loc 1 299 28 is_stmt 0 view .LVU334
 1270 0186 0630      		cpi r16,lo8(6)
 1271 0188 00F0      		brlo .+2
 1272 018a 00C0      		rjmp .L76
 1273               	.L108:
 324:tmk_core/common/action.c ****                             register_mods(mods);
 1274               		.loc 1 324 67 is_stmt 1 view .LVU335
 325:tmk_core/common/action.c ****                         }
 1275               		.loc 1 325 29 view .LVU336
 1276 018c 8F2D      		mov r24,r15
 1277 018e 00C0      		rjmp .L189
 1278               	.L106:
 303:tmk_core/common/action.c ****                             unregister_mods(mods);
 1279               		.loc 1 303 25 view .LVU337
 303:tmk_core/common/action.c ****                             unregister_mods(mods);
 1280               		.loc 1 303 28 is_stmt 0 view .LVU338
 1281 0190 0530      		cpi r16,lo8(5)
 1282 0192 00F0      		brlo .+2
 1283 0194 00C0      		rjmp .L76
 1284 0196 00C0      		rjmp .L110
 1285               	.L107:
 328:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1286               		.loc 1 328 25 is_stmt 1 view .LVU339
 328:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1287               		.loc 1 328 28 is_stmt 0 view .LVU340
 1288 0198 0023      		tst r16
 1289 019a 01F0      		breq .L110
 329:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1290               		.loc 1 329 71 is_stmt 1 view .LVU341
 330:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1291               		.loc 1 330 29 view .LVU342
 330:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1292               		.loc 1 330 32 is_stmt 0 view .LVU343
 1293 019c D933      		cpi r29,lo8(57)
 1294 019e 01F4      		brne .L152
 331:tmk_core/common/action.c ****                             }
 1295               		.loc 1 331 33 is_stmt 1 view .LVU344
 1296               	.LVL119:
 1297               	.LBB34:
 1298               	.LBI34:
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 1299               		.loc 2 166 1 view .LVU345
 1300               	.LBB35:
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1301               		.loc 2 168 2 view .LVU346
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1302               		.loc 2 172 2 view .LVU347
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1303               		.loc 2 173 2 view .LVU348
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 1304               		.loc 2 174 2 view .LVU349
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 1305               		.loc 2 184 3 view .LVU350
 1306               		.loc 2 187 2 view .LVU351
 1307 01a0 FFEF      		ldi r31,lo8(255999)
 1308 01a2 27EE      		ldi r18,hi8(255999)
 1309 01a4 33E0      		ldi r19,hlo8(255999)
 1310 01a6 F150      	1:	subi r31,1
 1311 01a8 2040      		sbci r18,0
 1312 01aa 3040      		sbci r19,0
 1313 01ac 01F4      		brne 1b
 1314               	.LVL120:
 1315               	.L193:
 1316               		.loc 2 187 2 is_stmt 0 view .LVU352
 1317               	.LBE35:
 1318               	.LBE34:
 1319               	.LBE36:
 1320               	.LBB37:
 1321               	.LBB38:
 1322 01ae 00C0      		rjmp .
 1323 01b0 0000      		nop
 1324               	.L152:
 1325               	.LBE38:
 1326               	.LBE37:
 538:tmk_core/common/action.c ****                         } else {
 1327               		.loc 1 538 29 is_stmt 1 view .LVU353
 1328 01b2 8D2F      		mov r24,r29
 1329 01b4 0E94 0000 		call unregister_code
 1330               	.LVL121:
 1331 01b8 00C0      		rjmp .L76
 1332               	.L84:
 346:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1333               		.loc 1 346 13 view .LVU354
 346:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1334               		.loc 1 346 33 is_stmt 0 view .LVU355
 1335 01ba 8C2F      		mov r24,r28
 1336 01bc 8695      		lsr r24
 1337 01be 8695      		lsr r24
 1338 01c0 8370      		andi r24,lo8(3)
 1339 01c2 01F0      		breq .L112
 1340 01c4 8130      		cpi r24,lo8(1)
 1341 01c6 01F0      		breq .+2
 1342 01c8 00C0      		rjmp .L76
 355:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1343               		.loc 1 355 21 is_stmt 1 view .LVU356
 356:tmk_core/common/action.c ****                     } else {
 1344               		.loc 1 356 25 is_stmt 0 view .LVU357
 1345 01ca 8D2F      		mov r24,r29
 1346 01cc 9C2F      		mov r25,r28
 1347 01ce 9370      		andi r25,lo8(3)
 355:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1348               		.loc 1 355 24 view .LVU358
 1349 01d0 1111      		cpse r17,__zero_reg__
 1350 01d2 00C0      		rjmp .L191
 358:tmk_core/common/action.c ****                     }
 1351               		.loc 1 358 25 is_stmt 1 view .LVU359
 1352 01d4 90E0      		ldi r25,0
 1353 01d6 80E0      		ldi r24,0
 1354               	.L191:
 1355 01d8 0E94 0000 		call host_consumer_send
 1356               	.LVL122:
 1357 01dc 00C0      		rjmp .L76
 1358               	.L112:
 348:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1359               		.loc 1 348 21 view .LVU360
 349:tmk_core/common/action.c ****                     } else {
 1360               		.loc 1 349 25 is_stmt 0 view .LVU361
 1361 01de 8D2F      		mov r24,r29
 1362 01e0 9C2F      		mov r25,r28
 1363 01e2 9370      		andi r25,lo8(3)
 348:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1364               		.loc 1 348 24 view .LVU362
 1365 01e4 1111      		cpse r17,__zero_reg__
 1366 01e6 00C0      		rjmp .L186
 351:tmk_core/common/action.c ****                     }
 1367               		.loc 1 351 25 is_stmt 1 view .LVU363
 1368 01e8 90E0      		ldi r25,0
 1369 01ea 80E0      		ldi r24,0
 1370               	.L186:
 1371 01ec 0E94 0000 		call host_system_send
 1372               	.LVL123:
 1373 01f0 00C0      		rjmp .L76
 1374               	.L83:
 367:tmk_core/common/action.c ****                 switch (action.key.code) {
 1375               		.loc 1 367 13 view .LVU364
 367:tmk_core/common/action.c ****                 switch (action.key.code) {
 1376               		.loc 1 367 16 is_stmt 0 view .LVU365
 1377 01f2 1123      		tst r17
 1378 01f4 01F0      		breq .L116
 368:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1379               		.loc 1 368 17 is_stmt 1 view .LVU366
 1380 01f6 D53F      		cpi r29,lo8(-11)
 1381 01f8 01F0      		breq .L117
 1382 01fa D63F      		cpi r29,lo8(-10)
 1383 01fc 01F0      		breq .L118
 1384 01fe D43F      		cpi r29,lo8(-12)
 1385 0200 01F4      		brne .L119
 370:tmk_core/common/action.c ****                         break;
 1386               		.loc 1 370 25 view .LVU367
 370:tmk_core/common/action.c ****                         break;
 1387               		.loc 1 370 36 is_stmt 0 view .LVU368
 1388 0202 8091 0000 		lds r24,tp_buttons
 1389 0206 9091 0000 		lds r25,tp_buttons+1
 1390 020a 8160      		ori r24,1
 1391               	.L183:
 376:tmk_core/common/action.c ****                         break;
 1392               		.loc 1 376 36 view .LVU369
 1393 020c 9093 0000 		sts tp_buttons+1,r25
 1394 0210 8093 0000 		sts tp_buttons,r24
 377:tmk_core/common/action.c ****                     default:
 1395               		.loc 1 377 25 is_stmt 1 view .LVU370
 1396               	.L119:
 381:tmk_core/common/action.c ****                 mousekey_send();
 1397               		.loc 1 381 17 view .LVU371
 1398 0214 8D2F      		mov r24,r29
 1399 0216 0E94 0000 		call mousekey_on
 1400               	.LVL124:
 382:tmk_core/common/action.c ****             } else {
 1401               		.loc 1 382 17 view .LVU372
 1402               	.L187:
 398:tmk_core/common/action.c ****             }
 1403               		.loc 1 398 17 view .LVU373
 1404 021a 0E94 0000 		call mousekey_send
 1405               	.LVL125:
 1406 021e 00C0      		rjmp .L76
 1407               	.L117:
 373:tmk_core/common/action.c ****                         break;
 1408               		.loc 1 373 25 view .LVU374
 373:tmk_core/common/action.c ****                         break;
 1409               		.loc 1 373 36 is_stmt 0 view .LVU375
 1410 0220 8091 0000 		lds r24,tp_buttons
 1411 0224 9091 0000 		lds r25,tp_buttons+1
 1412 0228 8260      		ori r24,2
 1413 022a 00C0      		rjmp .L183
 1414               	.L118:
 376:tmk_core/common/action.c ****                         break;
 1415               		.loc 1 376 25 is_stmt 1 view .LVU376
 376:tmk_core/common/action.c ****                         break;
 1416               		.loc 1 376 36 is_stmt 0 view .LVU377
 1417 022c 8091 0000 		lds r24,tp_buttons
 1418 0230 9091 0000 		lds r25,tp_buttons+1
 1419 0234 8460      		ori r24,4
 1420 0236 00C0      		rjmp .L183
 1421               	.L116:
 384:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1422               		.loc 1 384 17 is_stmt 1 view .LVU378
 1423 0238 D53F      		cpi r29,lo8(-11)
 1424 023a 01F0      		breq .L120
 1425 023c D63F      		cpi r29,lo8(-10)
 1426 023e 01F0      		breq .L121
 1427 0240 D43F      		cpi r29,lo8(-12)
 1428 0242 01F4      		brne .L122
 386:tmk_core/common/action.c ****                         break;
 1429               		.loc 1 386 25 view .LVU379
 386:tmk_core/common/action.c ****                         break;
 1430               		.loc 1 386 36 is_stmt 0 view .LVU380
 1431 0244 8091 0000 		lds r24,tp_buttons
 1432 0248 9091 0000 		lds r25,tp_buttons+1
 1433 024c 8E7F      		andi r24,254
 1434               	.L184:
 392:tmk_core/common/action.c ****                         break;
 1435               		.loc 1 392 36 view .LVU381
 1436 024e 9093 0000 		sts tp_buttons+1,r25
 1437 0252 8093 0000 		sts tp_buttons,r24
 393:tmk_core/common/action.c ****                     default:
 1438               		.loc 1 393 25 is_stmt 1 view .LVU382
 1439               	.L122:
 397:tmk_core/common/action.c ****                 mousekey_send();
 1440               		.loc 1 397 17 view .LVU383
 1441 0256 8D2F      		mov r24,r29
 1442 0258 0E94 0000 		call mousekey_off
 1443               	.LVL126:
 1444 025c 00C0      		rjmp .L187
 1445               	.L120:
 389:tmk_core/common/action.c ****                         break;
 1446               		.loc 1 389 25 view .LVU384
 389:tmk_core/common/action.c ****                         break;
 1447               		.loc 1 389 36 is_stmt 0 view .LVU385
 1448 025e 8091 0000 		lds r24,tp_buttons
 1449 0262 9091 0000 		lds r25,tp_buttons+1
 1450 0266 8D7F      		andi r24,253
 1451 0268 00C0      		rjmp .L184
 1452               	.L121:
 392:tmk_core/common/action.c ****                         break;
 1453               		.loc 1 392 25 is_stmt 1 view .LVU386
 392:tmk_core/common/action.c ****                         break;
 1454               		.loc 1 392 36 is_stmt 0 view .LVU387
 1455 026a 8091 0000 		lds r24,tp_buttons
 1456 026e 9091 0000 		lds r25,tp_buttons+1
 1457 0272 8B7F      		andi r24,251
 1458 0274 00C0      		rjmp .L184
 1459               	.L82:
 404:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1460               		.loc 1 404 13 is_stmt 1 view .LVU388
 404:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1461               		.loc 1 404 39 is_stmt 0 view .LVU389
 1462 0276 8C2F      		mov r24,r28
 1463 0278 8370      		andi r24,lo8(3)
 404:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1464               		.loc 1 404 16 view .LVU390
 1465 027a 01F0      		breq .+2
 1466 027c 00C0      		rjmp .L123
 406:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1467               		.loc 1 406 17 is_stmt 1 view .LVU391
 406:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1468               		.loc 1 406 20 is_stmt 0 view .LVU392
 1469 027e 1111      		cpse r17,__zero_reg__
 1470 0280 00C0      		rjmp .L76
 1471               	.LBB40:
 407:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1472               		.loc 1 407 21 is_stmt 1 view .LVU393
 1473               	.LVL127:
 408:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1474               		.loc 1 408 21 view .LVU394
 407:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1475               		.loc 1 407 61 is_stmt 0 view .LVU395
 1476 0282 4D2F      		mov r20,r29
 1477 0284 4295      		swap r20
 1478 0286 4695      		lsr r20
 1479 0288 4770      		andi r20,lo8(7)
 407:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1480               		.loc 1 407 35 view .LVU396
 1481 028a 440F      		lsl r20
 1482 028c 440F      		lsl r20
 408:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1483               		.loc 1 408 77 view .LVU397
 1484 028e 0D2F      		mov r16,r29
 1485               	.LVL128:
 408:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1486               		.loc 1 408 77 view .LVU398
 1487 0290 0F70      		andi r16,lo8(15)
 408:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1488               		.loc 1 408 44 view .LVU399
 1489 0292 10E0      		ldi r17,0
 1490               	.LVL129:
 408:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1491               		.loc 1 408 44 view .LVU400
 1492 0294 30E0      		ldi r19,0
 1493 0296 20E0      		ldi r18,0
 408:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1494               		.loc 1 408 35 view .LVU401
 1495 0298 042E      		mov r0,r20
 1496 029a 00C0      		rjmp 2f
 1497               		1:
 1498 029c 000F      		lsl r16
 1499 029e 111F      		rol r17
 1500 02a0 221F      		rol r18
 1501 02a2 331F      		rol r19
 1502               		2:
 1503 02a4 0A94      		dec r0
 1504 02a6 02F4      		brpl 1b
 1505               	.LVL130:
 409:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1506               		.loc 1 409 21 is_stmt 1 view .LVU402
 409:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1507               		.loc 1 409 104 is_stmt 0 view .LVU403
 1508 02a8 60E0      		ldi r22,0
 1509 02aa 70E0      		ldi r23,0
 1510 02ac CB01      		movw r24,r22
 1511 02ae D4FF      		sbrs r29,4
 1512 02b0 00C0      		rjmp .L124
 409:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1513               		.loc 1 409 94 discriminator 1 view .LVU404
 1514 02b2 6FE0      		ldi r22,lo8(15)
 1515 02b4 70E0      		ldi r23,0
 1516 02b6 80E0      		ldi r24,0
 1517 02b8 90E0      		ldi r25,0
 1518 02ba 00C0      		rjmp 2f
 1519               		1:
 1520 02bc 660F      		lsl r22
 1521 02be 771F      		rol r23
 1522 02c0 881F      		rol r24
 1523 02c2 991F      		rol r25
 1524               		2:
 1525 02c4 4A95      		dec r20
 1526 02c6 02F4      		brpl 1b
 409:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1527               		.loc 1 409 104 discriminator 1 view .LVU405
 1528 02c8 6095      		com r22
 1529 02ca 7095      		com r23
 1530 02cc 8095      		com r24
 1531 02ce 9095      		com r25
 1532               	.L124:
 1533               	.LVL131:
 410:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1534               		.loc 1 410 21 is_stmt 1 discriminator 4 view .LVU406
 410:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1535               		.loc 1 410 47 is_stmt 0 discriminator 4 view .LVU407
 1536 02d0 C695      		lsr r28
 1537 02d2 C695      		lsr r28
 1538               	.LVL132:
 410:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1539               		.loc 1 410 47 discriminator 4 view .LVU408
 1540 02d4 C370      		andi r28,lo8(3)
 1541 02d6 602B      		or r22,r16
 1542               	.LVL133:
 410:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1543               		.loc 1 410 47 discriminator 4 view .LVU409
 1544 02d8 712B      		or r23,r17
 1545 02da 822B      		or r24,r18
 1546 02dc 932B      		or r25,r19
 1547 02de C230      		cpi r28,lo8(2)
 1548 02e0 01F0      		breq .L125
 1549 02e2 00F4      		brsh .L126
 1550 02e4 C130      		cpi r28,lo8(1)
 1551 02e6 01F0      		breq .L127
 412:tmk_core/common/action.c ****                             break;
 1552               		.loc 1 412 29 is_stmt 1 view .LVU410
 1553 02e8 0E94 0000 		call default_layer_and
 1554               	.LVL134:
 413:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1555               		.loc 1 413 29 view .LVU411
 1556 02ec 00C0      		rjmp .L76
 1557               	.L127:
 415:tmk_core/common/action.c ****                             break;
 1558               		.loc 1 415 29 view .LVU412
 1559 02ee 0E94 0000 		call default_layer_or
 1560               	.LVL135:
 416:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1561               		.loc 1 416 29 view .LVU413
 1562 02f2 00C0      		rjmp .L76
 1563               	.L125:
 418:tmk_core/common/action.c ****                             break;
 1564               		.loc 1 418 29 view .LVU414
 1565 02f4 0E94 0000 		call default_layer_xor
 1566               	.LVL136:
 419:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1567               		.loc 1 419 29 view .LVU415
 1568 02f8 00C0      		rjmp .L76
 1569               	.L126:
 421:tmk_core/common/action.c ****                             break;
 1570               		.loc 1 421 29 view .LVU416
 1571 02fa 0E94 0000 		call default_layer_set
 1572               	.LVL137:
 422:tmk_core/common/action.c ****                     }
 1573               		.loc 1 422 29 view .LVU417
 1574 02fe 00C0      		rjmp .L76
 1575               	.LVL138:
 1576               	.L123:
 422:tmk_core/common/action.c ****                     }
 1577               		.loc 1 422 29 is_stmt 0 view .LVU418
 1578               	.LBE40:
 427:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1579               		.loc 1 427 17 is_stmt 1 view .LVU419
 427:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1580               		.loc 1 427 21 is_stmt 0 view .LVU420
 1581 0300 8695      		lsr r24
 1582 0302 1123      		tst r17
 1583 0304 01F0      		breq .L129
 427:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1584               		.loc 1 427 21 discriminator 1 view .LVU421
 1585 0306 8C2F      		mov r24,r28
 1586 0308 8170      		andi r24,lo8(1)
 1587               	.L129:
 427:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1588               		.loc 1 427 20 discriminator 4 view .LVU422
 1589 030a 8823      		tst r24
 1590 030c 01F4      		brne .+2
 1591 030e 00C0      		rjmp .L76
 1592               	.LBB41:
 428:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1593               		.loc 1 428 21 is_stmt 1 view .LVU423
 1594               	.LVL139:
 429:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1595               		.loc 1 429 21 view .LVU424
 428:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1596               		.loc 1 428 61 is_stmt 0 view .LVU425
 1597 0310 4D2F      		mov r20,r29
 1598 0312 4295      		swap r20
 1599 0314 4695      		lsr r20
 1600 0316 4770      		andi r20,lo8(7)
 428:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1601               		.loc 1 428 35 view .LVU426
 1602 0318 440F      		lsl r20
 1603 031a 440F      		lsl r20
 429:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1604               		.loc 1 429 77 view .LVU427
 1605 031c 0D2F      		mov r16,r29
 1606               	.LVL140:
 429:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1607               		.loc 1 429 77 view .LVU428
 1608 031e 0F70      		andi r16,lo8(15)
 429:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1609               		.loc 1 429 44 view .LVU429
 1610 0320 10E0      		ldi r17,0
 1611               	.LVL141:
 429:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1612               		.loc 1 429 44 view .LVU430
 1613 0322 30E0      		ldi r19,0
 1614 0324 20E0      		ldi r18,0
 429:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1615               		.loc 1 429 35 view .LVU431
 1616 0326 042E      		mov r0,r20
 1617 0328 00C0      		rjmp 2f
 1618               		1:
 1619 032a 000F      		lsl r16
 1620 032c 111F      		rol r17
 1621 032e 221F      		rol r18
 1622 0330 331F      		rol r19
 1623               		2:
 1624 0332 0A94      		dec r0
 1625 0334 02F4      		brpl 1b
 1626               	.LVL142:
 430:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1627               		.loc 1 430 21 is_stmt 1 view .LVU432
 430:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1628               		.loc 1 430 104 is_stmt 0 view .LVU433
 1629 0336 60E0      		ldi r22,0
 1630 0338 70E0      		ldi r23,0
 1631 033a CB01      		movw r24,r22
 1632 033c D4FF      		sbrs r29,4
 1633 033e 00C0      		rjmp .L130
 430:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1634               		.loc 1 430 94 discriminator 1 view .LVU434
 1635 0340 6FE0      		ldi r22,lo8(15)
 1636 0342 70E0      		ldi r23,0
 1637 0344 80E0      		ldi r24,0
 1638 0346 90E0      		ldi r25,0
 1639 0348 00C0      		rjmp 2f
 1640               		1:
 1641 034a 660F      		lsl r22
 1642 034c 771F      		rol r23
 1643 034e 881F      		rol r24
 1644 0350 991F      		rol r25
 1645               		2:
 1646 0352 4A95      		dec r20
 1647 0354 02F4      		brpl 1b
 430:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1648               		.loc 1 430 104 discriminator 1 view .LVU435
 1649 0356 6095      		com r22
 1650 0358 7095      		com r23
 1651 035a 8095      		com r24
 1652 035c 9095      		com r25
 1653               	.L130:
 1654               	.LVL143:
 431:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1655               		.loc 1 431 21 is_stmt 1 discriminator 4 view .LVU436
 431:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1656               		.loc 1 431 47 is_stmt 0 discriminator 4 view .LVU437
 1657 035e C695      		lsr r28
 1658 0360 C695      		lsr r28
 1659               	.LVL144:
 431:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1660               		.loc 1 431 47 discriminator 4 view .LVU438
 1661 0362 C370      		andi r28,lo8(3)
 1662 0364 602B      		or r22,r16
 1663               	.LVL145:
 431:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1664               		.loc 1 431 47 discriminator 4 view .LVU439
 1665 0366 712B      		or r23,r17
 1666 0368 822B      		or r24,r18
 1667 036a 932B      		or r25,r19
 1668 036c C230      		cpi r28,lo8(2)
 1669 036e 01F0      		breq .L131
 1670 0370 00F4      		brsh .L132
 1671 0372 C130      		cpi r28,lo8(1)
 1672 0374 01F0      		breq .L133
 433:tmk_core/common/action.c ****                             break;
 1673               		.loc 1 433 29 is_stmt 1 view .LVU440
 1674 0376 0E94 0000 		call layer_and
 1675               	.LVL146:
 434:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1676               		.loc 1 434 29 view .LVU441
 1677 037a 00C0      		rjmp .L76
 1678               	.L133:
 436:tmk_core/common/action.c ****                             break;
 1679               		.loc 1 436 29 view .LVU442
 1680 037c 0E94 0000 		call layer_or
 1681               	.LVL147:
 437:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1682               		.loc 1 437 29 view .LVU443
 1683 0380 00C0      		rjmp .L76
 1684               	.L131:
 439:tmk_core/common/action.c ****                             break;
 1685               		.loc 1 439 29 view .LVU444
 1686 0382 0E94 0000 		call layer_xor
 1687               	.LVL148:
 440:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1688               		.loc 1 440 29 view .LVU445
 1689 0386 00C0      		rjmp .L76
 1690               	.L132:
 442:tmk_core/common/action.c ****                             break;
 1691               		.loc 1 442 29 view .LVU446
 1692 0388 0E94 0000 		call layer_state_set
 1693               	.LVL149:
 443:tmk_core/common/action.c ****                     }
 1694               		.loc 1 443 29 view .LVU447
 1695 038c 00C0      		rjmp .L76
 1696               	.LVL150:
 1697               	.L81:
 443:tmk_core/common/action.c ****                     }
 1698               		.loc 1 443 29 is_stmt 0 view .LVU448
 1699               	.LBE41:
 449:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1700               		.loc 1 449 13 is_stmt 1 view .LVU449
 1701 038e CF70      		andi r28,lo8(15)
 1702               	.LVL151:
 449:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1703               		.loc 1 449 16 is_stmt 0 view .LVU450
 1704 0390 1123      		tst r17
 1705 0392 01F0      		breq .L134
 450:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1706               		.loc 1 450 17 is_stmt 1 view .LVU451
 1707 0394 8C2F      		mov r24,r28
 1708 0396 0E94 0000 		call layer_on
 1709               	.LVL152:
 451:tmk_core/common/action.c ****             } else {
 1710               		.loc 1 451 17 view .LVU452
 1711 039a 8D2F      		mov r24,r29
 1712 039c 00C0      		rjmp .L189
 1713               	.L134:
 453:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1714               		.loc 1 453 17 view .LVU453
 1715 039e 8D2F      		mov r24,r29
 1716 03a0 0E94 0000 		call unregister_mods
 1717               	.LVL153:
 454:tmk_core/common/action.c ****             }
 1718               		.loc 1 454 17 view .LVU454
 1719 03a4 8C2F      		mov r24,r28
 1720               	.LVL154:
 1721               	.L188:
 541:tmk_core/common/action.c ****                         }
 1722               		.loc 1 541 29 is_stmt 0 view .LVU455
 1723 03a6 0E94 0000 		call layer_off
 1724               	.LVL155:
 1725 03aa 00C0      		rjmp .L76
 1726               	.L80:
 460:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1727               		.loc 1 460 13 is_stmt 1 view .LVU456
 1728 03ac D23F      		cpi r29,lo8(-14)
 1729 03ae 01F0      		breq .L135
 1730 03b0 00F4      		brsh .L136
 1731 03b2 D03F      		cpi r29,lo8(-16)
 1732 03b4 01F0      		breq .L137
 1733 03b6 D13F      		cpi r29,lo8(-15)
 1734 03b8 01F0      		breq .L138
 1735               	.L139:
 522:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1736               		.loc 1 522 21 view .LVU457
 522:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1737               		.loc 1 522 24 is_stmt 0 view .LVU458
 1738 03ba 1123      		tst r17
 1739 03bc 01F4      		brne .+2
 1740 03be 00C0      		rjmp .L148
 523:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1741               		.loc 1 523 25 is_stmt 1 view .LVU459
 523:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1742               		.loc 1 523 28 is_stmt 0 view .LVU460
 1743 03c0 0111      		cpse r16,__zero_reg__
 1744 03c2 00C0      		rjmp .L190
 527:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 1745               		.loc 1 527 76 is_stmt 1 view .LVU461
 528:tmk_core/common/action.c ****                         }
 1746               		.loc 1 528 29 view .LVU462
 1747 03c4 8C2F      		mov r24,r28
 1748 03c6 8F71      		andi r24,lo8(31)
 1749 03c8 00C0      		rjmp .L185
 1750               	.L136:
 1751 03ca D33F      		cpi r29,lo8(-13)
 1752 03cc 01F0      		breq .L140
 1753 03ce D43F      		cpi r29,lo8(-12)
 1754 03d0 01F4      		brne .L139
 508:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1755               		.loc 1 508 21 view .LVU463
 508:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1756               		.loc 1 508 24 is_stmt 0 view .LVU464
 1757 03d2 1123      		tst r17
 1758 03d4 01F0      		breq .L147
 509:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1759               		.loc 1 509 25 is_stmt 1 view .LVU465
 509:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1760               		.loc 1 509 50 is_stmt 0 view .LVU466
 1761 03d6 CF71      		andi r28,lo8(31)
 1762               	.LVL156:
 509:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1763               		.loc 1 509 25 view .LVU467
 1764 03d8 8C2F      		mov r24,r28
 1765 03da 0E94 0000 		call layer_on
 1766               	.LVL157:
 510:tmk_core/common/action.c ****                     } else {
 1767               		.loc 1 510 25 is_stmt 1 view .LVU468
 1768 03de 63E0      		ldi r22,lo8(3)
 1769 03e0 8C2F      		mov r24,r28
 1770 03e2 0E94 0000 		call set_oneshot_layer
 1771               	.LVL158:
 1772 03e6 00C0      		rjmp .L76
 1773               	.LVL159:
 1774               	.L137:
 463:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1775               		.loc 1 463 21 view .LVU469
 463:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1776               		.loc 1 463 24 is_stmt 0 view .LVU470
 1777 03e8 1123      		tst r17
 1778 03ea 01F0      		breq .L142
 464:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1779               		.loc 1 464 25 is_stmt 1 view .LVU471
 464:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1780               		.loc 1 464 28 is_stmt 0 view .LVU472
 1781 03ec 0530      		cpi r16,lo8(5)
 1782 03ee 00F0      		brlo .+2
 1783 03f0 00C0      		rjmp .L76
 1784               	.L143:
 465:tmk_core/common/action.c ****                         }
 1785               		.loc 1 465 29 is_stmt 1 view .LVU473
 1786 03f2 8C2F      		mov r24,r28
 1787 03f4 8F71      		andi r24,lo8(31)
 1788 03f6 0E94 0000 		call layer_invert
 1789               	.LVL160:
 1790 03fa 00C0      		rjmp .L76
 1791               	.L142:
 468:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1792               		.loc 1 468 25 view .LVU474
 468:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1793               		.loc 1 468 28 is_stmt 0 view .LVU475
 1794 03fc 0630      		cpi r16,lo8(6)
 1795 03fe 00F0      		brlo .+2
 1796 0400 00C0      		rjmp .L76
 1797 0402 00C0      		rjmp .L143
 1798               	.L138:
 474:tmk_core/common/action.c ****                     break;
 1799               		.loc 1 474 21 is_stmt 1 view .LVU476
 1800 0404 8C2F      		mov r24,r28
 1801 0406 8F71      		andi r24,lo8(31)
 474:tmk_core/common/action.c ****                     break;
 1802               		.loc 1 474 68 is_stmt 0 view .LVU477
 1803 0408 1123      		tst r17
 1804 040a 01F0      		breq .L188
 1805               	.L185:
 528:tmk_core/common/action.c ****                         }
 1806               		.loc 1 528 29 view .LVU478
 1807 040c 0E94 0000 		call layer_on
 1808               	.LVL161:
 1809 0410 00C0      		rjmp .L76
 1810               	.L135:
 477:tmk_core/common/action.c ****                     break;
 1811               		.loc 1 477 21 is_stmt 1 view .LVU479
 1812 0412 8C2F      		mov r24,r28
 1813 0414 8F71      		andi r24,lo8(31)
 477:tmk_core/common/action.c ****                     break;
 1814               		.loc 1 477 69 is_stmt 0 view .LVU480
 1815 0416 1123      		tst r17
 1816 0418 01F0      		breq .L185
 1817 041a 00C0      		rjmp .L188
 1818               	.L140:
 480:tmk_core/common/action.c ****                     break;
 1819               		.loc 1 480 21 is_stmt 1 view .LVU481
 480:tmk_core/common/action.c ****                     break;
 1820               		.loc 1 480 70 is_stmt 0 view .LVU482
 1821 041c 1123      		tst r17
 1822 041e 01F0      		breq .L146
 480:tmk_core/common/action.c ****                     break;
 1823               		.loc 1 480 37 discriminator 1 view .LVU483
 1824 0420 8C2F      		mov r24,r28
 1825 0422 8F71      		andi r24,lo8(31)
 1826 0424 0E94 0000 		call layer_move
 1827               	.LVL162:
 1828 0428 00C0      		rjmp .L76
 1829               	.L146:
 480:tmk_core/common/action.c ****                     break;
 1830               		.loc 1 480 72 discriminator 2 view .LVU484
 1831 042a 0E94 0000 		call layer_clear
 1832               	.LVL163:
 1833 042e 00C0      		rjmp .L76
 1834               	.L147:
 512:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1835               		.loc 1 512 25 is_stmt 1 view .LVU485
 1836 0430 81E0      		ldi r24,lo8(1)
 1837 0432 0E94 0000 		call clear_oneshot_layer_state
 1838               	.LVL164:
 513:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1839               		.loc 1 513 25 view .LVU486
 513:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1840               		.loc 1 513 28 is_stmt 0 view .LVU487
 1841 0436 0230      		cpi r16,lo8(2)
 1842 0438 00F4      		brsh .+2
 1843 043a 00C0      		rjmp .L76
 514:tmk_core/common/action.c ****                         }
 1844               		.loc 1 514 29 is_stmt 1 view .LVU488
 1845 043c 82E0      		ldi r24,lo8(2)
 1846 043e 0E94 0000 		call clear_oneshot_layer_state
 1847               	.LVL165:
 1848 0442 00C0      		rjmp .L76
 1849               	.L148:
 531:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1850               		.loc 1 531 25 view .LVU489
 531:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1851               		.loc 1 531 28 is_stmt 0 view .LVU490
 1852 0444 0023      		tst r16
 1853 0446 01F0      		breq .L150
 532:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1854               		.loc 1 532 77 is_stmt 1 view .LVU491
 533:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1855               		.loc 1 533 29 view .LVU492
 533:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1856               		.loc 1 533 32 is_stmt 0 view .LVU493
 1857 0448 D933      		cpi r29,lo8(57)
 1858 044a 01F0      		breq .+2
 1859 044c 00C0      		rjmp .L152
 534:tmk_core/common/action.c ****                             } else {
 1860               		.loc 1 534 33 is_stmt 1 view .LVU494
 1861               	.LVL166:
 1862               	.LBB42:
 1863               	.LBI37:
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 1864               		.loc 2 166 1 view .LVU495
 1865               	.LBB39:
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1866               		.loc 2 168 2 view .LVU496
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1867               		.loc 2 172 2 view .LVU497
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1868               		.loc 2 173 2 view .LVU498
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 1869               		.loc 2 174 2 view .LVU499
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 1870               		.loc 2 184 3 view .LVU500
 1871               		.loc 2 187 2 view .LVU501
 1872 044e 8FEF      		ldi r24,lo8(255999)
 1873 0450 97EE      		ldi r25,hi8(255999)
 1874 0452 E3E0      		ldi r30,hlo8(255999)
 1875 0454 8150      	1:	subi r24,1
 1876 0456 9040      		sbci r25,0
 1877 0458 E040      		sbci r30,0
 1878 045a 01F4      		brne 1b
 1879 045c 00C0      		rjmp .L193
 1880               	.LVL167:
 1881               	.L150:
 1882               		.loc 2 187 2 is_stmt 0 view .LVU502
 1883               	.LBE39:
 1884               	.LBE42:
 540:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 1885               		.loc 1 540 79 is_stmt 1 view .LVU503
 541:tmk_core/common/action.c ****                         }
 1886               		.loc 1 541 29 view .LVU504
 1887 045e 8C2F      		mov r24,r28
 1888 0460 8F71      		andi r24,lo8(31)
 1889 0462 00C0      		rjmp .L188
 1890               	.L79:
 552:tmk_core/common/action.c ****             break;
 1891               		.loc 1 552 13 view .LVU505
 552:tmk_core/common/action.c ****             break;
 1892               		.loc 1 552 83 is_stmt 0 view .LVU506
 1893 0464 4C2F      		mov r20,r28
 1894 0466 4F70      		andi r20,lo8(15)
 552:tmk_core/common/action.c ****             break;
 1895               		.loc 1 552 13 view .LVU507
 1896 0468 6D2F      		mov r22,r29
 1897 046a C601      		movw r24,r12
 1898 046c 0E94 0000 		call action_get_macro
 1899               	.LVL168:
 1900 0470 0E94 0000 		call action_macro_play
 1901               	.LVL169:
 553:tmk_core/common/action.c **** #endif
 1902               		.loc 1 553 13 is_stmt 1 view .LVU508
 1903 0474 00C0      		rjmp .L76
 1904               	.L77:
 648:tmk_core/common/action.c ****             break;
 1905               		.loc 1 648 13 view .LVU509
 648:tmk_core/common/action.c ****             break;
 1906               		.loc 1 648 64 is_stmt 0 view .LVU510
 1907 0476 4C2F      		mov r20,r28
 1908 0478 4F70      		andi r20,lo8(15)
 648:tmk_core/common/action.c ****             break;
 1909               		.loc 1 648 13 view .LVU511
 1910 047a 6D2F      		mov r22,r29
 1911 047c C601      		movw r24,r12
 1912 047e 0E94 0000 		call action_function
 1913               	.LVL170:
 649:tmk_core/common/action.c **** #endif
 1914               		.loc 1 649 13 is_stmt 1 view .LVU512
 1915 0482 00C0      		rjmp .L76
 1916               	.LVL171:
 1917               	.L73:
 1918               	/* epilogue start */
 706:tmk_core/common/action.c **** 
 1919               		.loc 1 706 1 is_stmt 0 view .LVU513
 1920 0484 DF91      		pop r29
 1921               	.LVL172:
 706:tmk_core/common/action.c **** 
 1922               		.loc 1 706 1 view .LVU514
 1923 0486 CF91      		pop r28
 706:tmk_core/common/action.c **** 
 1924               		.loc 1 706 1 view .LVU515
 1925 0488 1F91      		pop r17
 1926 048a 0F91      		pop r16
 1927 048c FF90      		pop r15
 1928 048e EF90      		pop r14
 1929               	.LVL173:
 706:tmk_core/common/action.c **** 
 1930               		.loc 1 706 1 view .LVU516
 1931 0490 DF90      		pop r13
 1932 0492 CF90      		pop r12
 1933               	.LVL174:
 706:tmk_core/common/action.c **** 
 1934               		.loc 1 706 1 view .LVU517
 1935 0494 BF90      		pop r11
 1936 0496 0895      		ret
 1937               		.cfi_endproc
 1938               	.LFE18:
 1940               		.section	.text.process_record,"ax",@progbits
 1941               	.global	process_record
 1943               	process_record:
 1944               	.LVL175:
 1945               	.LFB17:
 175:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1946               		.loc 1 175 42 is_stmt 1 view -0
 1947               		.cfi_startproc
 175:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1948               		.loc 1 175 42 is_stmt 0 view .LVU519
 1949 0000 0F93      		push r16
 1950               	.LCFI15:
 1951               		.cfi_def_cfa_offset 3
 1952               		.cfi_offset 16, -2
 1953 0002 1F93      		push r17
 1954               	.LCFI16:
 1955               		.cfi_def_cfa_offset 4
 1956               		.cfi_offset 17, -3
 1957 0004 CF93      		push r28
 1958               	.LCFI17:
 1959               		.cfi_def_cfa_offset 5
 1960               		.cfi_offset 28, -4
 1961 0006 DF93      		push r29
 1962               	.LCFI18:
 1963               		.cfi_def_cfa_offset 6
 1964               		.cfi_offset 29, -5
 1965               	/* prologue: function */
 1966               	/* frame size = 0 */
 1967               	/* stack size = 4 */
 1968               	.L__stack_usage = 4
 1969 0008 EC01      		movw r28,r24
 176:tmk_core/common/action.c ****         return;
 1970               		.loc 1 176 5 is_stmt 1 view .LVU520
 1971               	.LBB45:
 1972               	.LBI45:
 1973               		.file 3 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  25:tmk_core/common/keyboard.h **** extern "C" {
  26:tmk_core/common/keyboard.h **** #endif
  27:tmk_core/common/keyboard.h **** 
  28:tmk_core/common/keyboard.h **** /* key matrix position */
  29:tmk_core/common/keyboard.h **** typedef struct {
  30:tmk_core/common/keyboard.h ****     uint8_t col;
  31:tmk_core/common/keyboard.h ****     uint8_t row;
  32:tmk_core/common/keyboard.h **** } keypos_t;
  33:tmk_core/common/keyboard.h **** 
  34:tmk_core/common/keyboard.h **** /* key event */
  35:tmk_core/common/keyboard.h **** typedef struct {
  36:tmk_core/common/keyboard.h ****     keypos_t key;
  37:tmk_core/common/keyboard.h ****     bool     pressed;
  38:tmk_core/common/keyboard.h ****     uint16_t time;
  39:tmk_core/common/keyboard.h **** } keyevent_t;
  40:tmk_core/common/keyboard.h **** 
  41:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  42:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  43:tmk_core/common/keyboard.h **** 
  44:tmk_core/common/keyboard.h **** /* Rules for No Event:
  45:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  46:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  47:tmk_core/common/keyboard.h ****  */
  48:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1974               		.loc 3 48 20 view .LVU521
 1975               	.LBB46:
 1976               		.loc 3 48 51 view .LVU522
 1977               		.loc 3 48 74 is_stmt 0 view .LVU523
 1978 000a 8B81      		ldd r24,Y+3
 1979 000c 9C81      		ldd r25,Y+4
 1980               	.LVL176:
 1981               		.loc 3 48 74 view .LVU524
 1982 000e 892B      		or r24,r25
 1983 0010 01F0      		breq .L194
 1984 0012 8881      		ld r24,Y
 1985 0014 9981      		ldd r25,Y+1
 1986 0016 8923      		and r24,r25
 1987 0018 8F3F      		cpi r24,lo8(-1)
 1988 001a 01F4      		brne .L204
 1989               	.L194:
 1990               	/* epilogue start */
 1991               	.LBE46:
 1992               	.LBE45:
 194:tmk_core/common/action.c **** 
 1993               		.loc 1 194 1 view .LVU525
 1994 001c DF91      		pop r29
 1995 001e CF91      		pop r28
 1996               	.LVL177:
 194:tmk_core/common/action.c **** 
 1997               		.loc 1 194 1 view .LVU526
 1998 0020 1F91      		pop r17
 1999 0022 0F91      		pop r16
 2000 0024 0895      		ret
 2001               	.LVL178:
 2002               	.L204:
 180:tmk_core/common/action.c **** 
 2003               		.loc 1 180 5 is_stmt 1 view .LVU527
 180:tmk_core/common/action.c **** 
 2004               		.loc 1 180 10 is_stmt 0 view .LVU528
 2005 0026 CE01      		movw r24,r28
 2006 0028 0E94 0000 		call process_record_quantum
 2007               	.LVL179:
 180:tmk_core/common/action.c **** 
 2008               		.loc 1 180 8 view .LVU529
 2009 002c 8823      		tst r24
 2010 002e 01F0      		breq .L194
 182:tmk_core/common/action.c ****     dprint("ACTION: ");
 2011               		.loc 1 182 5 is_stmt 1 view .LVU530
 182:tmk_core/common/action.c ****     dprint("ACTION: ");
 2012               		.loc 1 182 23 is_stmt 0 view .LVU531
 2013 0030 6881      		ld r22,Y
 2014 0032 7981      		ldd r23,Y+1
 2015 0034 8A81      		ldd r24,Y+2
 2016 0036 0E94 0000 		call store_or_get_action
 2017               	.LVL180:
 2018 003a 8C01      		movw r16,r24
 2019               	.LVL181:
 183:tmk_core/common/action.c ****     debug_action(action);
 2020               		.loc 1 183 23 is_stmt 1 view .LVU532
 184:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 2021               		.loc 1 184 5 view .LVU533
 186:tmk_core/common/action.c ****     layer_debug();
 2022               		.loc 1 186 29 view .LVU534
 187:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 2023               		.loc 1 187 5 view .LVU535
 2024 003c 0E94 0000 		call layer_debug
 2025               	.LVL182:
 188:tmk_core/common/action.c ****     default_layer_debug();
 2026               		.loc 1 188 37 view .LVU536
 189:tmk_core/common/action.c **** #endif
 2027               		.loc 1 189 5 view .LVU537
 2028 0040 0E94 0000 		call default_layer_debug
 2029               	.LVL183:
 191:tmk_core/common/action.c **** 
 2030               		.loc 1 191 15 view .LVU538
 193:tmk_core/common/action.c **** }
 2031               		.loc 1 193 5 view .LVU539
 193:tmk_core/common/action.c **** }
 2032               		.loc 1 193 5 is_stmt 0 view .LVU540
 2033 0044 B801      		movw r22,r16
 2034 0046 CE01      		movw r24,r28
 2035               	/* epilogue start */
 194:tmk_core/common/action.c **** 
 2036               		.loc 1 194 1 view .LVU541
 2037 0048 DF91      		pop r29
 2038 004a CF91      		pop r28
 2039               	.LVL184:
 194:tmk_core/common/action.c **** 
 2040               		.loc 1 194 1 view .LVU542
 2041 004c 1F91      		pop r17
 2042 004e 0F91      		pop r16
 2043               	.LVL185:
 193:tmk_core/common/action.c **** }
 2044               		.loc 1 193 5 view .LVU543
 2045 0050 0C94 0000 		jmp process_action
 2046               	.LVL186:
 193:tmk_core/common/action.c **** }
 2047               		.loc 1 193 5 view .LVU544
 2048               		.cfi_endproc
 2049               	.LFE17:
 2051               		.section	.text.process_record_nocache,"ax",@progbits
 2052               	.global	process_record_nocache
 2054               	process_record_nocache:
 2055               	.LVL187:
 2056               	.LFB14:
 137:tmk_core/common/action.c ****     disable_action_cache = true;
 2057               		.loc 1 137 50 is_stmt 1 view -0
 2058               		.cfi_startproc
 2059               	/* prologue: function */
 2060               	/* frame size = 0 */
 2061               	/* stack size = 0 */
 2062               	.L__stack_usage = 0
 138:tmk_core/common/action.c ****     process_record(record);
 2063               		.loc 1 138 5 view .LVU546
 138:tmk_core/common/action.c ****     process_record(record);
 2064               		.loc 1 138 26 is_stmt 0 view .LVU547
 2065 0000 21E0      		ldi r18,lo8(1)
 2066 0002 2093 0000 		sts disable_action_cache,r18
 139:tmk_core/common/action.c ****     disable_action_cache = false;
 2067               		.loc 1 139 5 is_stmt 1 view .LVU548
 2068 0006 0E94 0000 		call process_record
 2069               	.LVL188:
 140:tmk_core/common/action.c **** }
 2070               		.loc 1 140 5 view .LVU549
 140:tmk_core/common/action.c **** }
 2071               		.loc 1 140 26 is_stmt 0 view .LVU550
 2072 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 2073               	/* epilogue start */
 141:tmk_core/common/action.c **** #else
 2074               		.loc 1 141 1 view .LVU551
 2075 000e 0895      		ret
 2076               		.cfi_endproc
 2077               	.LFE14:
 2079               		.section	.text.register_weak_mods,"ax",@progbits
 2080               	.global	register_weak_mods
 2082               	register_weak_mods:
 2083               	.LVL189:
 2084               	.LFB24:
 895:tmk_core/common/action.c **** 
 896:tmk_core/common/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 897:tmk_core/common/action.c ****  *
 898:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 899:tmk_core/common/action.c ****  */
 900:tmk_core/common/action.c **** void register_weak_mods(uint8_t mods) {
 2085               		.loc 1 900 39 is_stmt 1 view -0
 2086               		.cfi_startproc
 2087               	/* prologue: function */
 2088               	/* frame size = 0 */
 2089               	/* stack size = 0 */
 2090               	.L__stack_usage = 0
 901:tmk_core/common/action.c ****     if (mods) {
 2091               		.loc 1 901 5 view .LVU553
 2092               		.loc 1 901 8 is_stmt 0 view .LVU554
 2093 0000 8823      		tst r24
 2094 0002 01F0      		breq .L206
 902:tmk_core/common/action.c ****         add_weak_mods(mods);
 2095               		.loc 1 902 9 is_stmt 1 view .LVU555
 2096 0004 0E94 0000 		call add_weak_mods
 2097               	.LVL190:
 903:tmk_core/common/action.c ****         send_keyboard_report();
 2098               		.loc 1 903 9 view .LVU556
 2099 0008 0C94 0000 		jmp send_keyboard_report
 2100               	.LVL191:
 2101               	.L206:
 2102               	/* epilogue start */
 904:tmk_core/common/action.c ****     }
 905:tmk_core/common/action.c **** }
 2103               		.loc 1 905 1 is_stmt 0 view .LVU557
 2104 000c 0895      		ret
 2105               		.cfi_endproc
 2106               	.LFE24:
 2108               		.section	.text.unregister_weak_mods,"ax",@progbits
 2109               	.global	unregister_weak_mods
 2111               	unregister_weak_mods:
 2112               	.LVL192:
 2113               	.LFB25:
 906:tmk_core/common/action.c **** 
 907:tmk_core/common/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 908:tmk_core/common/action.c ****  *
 909:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 910:tmk_core/common/action.c ****  */
 911:tmk_core/common/action.c **** void unregister_weak_mods(uint8_t mods) {
 2114               		.loc 1 911 41 is_stmt 1 view -0
 2115               		.cfi_startproc
 2116               	/* prologue: function */
 2117               	/* frame size = 0 */
 2118               	/* stack size = 0 */
 2119               	.L__stack_usage = 0
 912:tmk_core/common/action.c ****     if (mods) {
 2120               		.loc 1 912 5 view .LVU559
 2121               		.loc 1 912 8 is_stmt 0 view .LVU560
 2122 0000 8823      		tst r24
 2123 0002 01F0      		breq .L208
 913:tmk_core/common/action.c ****         del_weak_mods(mods);
 2124               		.loc 1 913 9 is_stmt 1 view .LVU561
 2125 0004 0E94 0000 		call del_weak_mods
 2126               	.LVL193:
 914:tmk_core/common/action.c ****         send_keyboard_report();
 2127               		.loc 1 914 9 view .LVU562
 2128 0008 0C94 0000 		jmp send_keyboard_report
 2129               	.LVL194:
 2130               	.L208:
 2131               	/* epilogue start */
 915:tmk_core/common/action.c ****     }
 916:tmk_core/common/action.c **** }
 2132               		.loc 1 916 1 is_stmt 0 view .LVU563
 2133 000c 0895      		ret
 2134               		.cfi_endproc
 2135               	.LFE25:
 2137               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 2138               	.global	clear_keyboard_but_mods_and_keys
 2140               	clear_keyboard_but_mods_and_keys:
 2141               	.LFB28:
 917:tmk_core/common/action.c **** 
 918:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 919:tmk_core/common/action.c ****  *
 920:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 921:tmk_core/common/action.c ****  */
 922:tmk_core/common/action.c **** void clear_keyboard(void) {
 923:tmk_core/common/action.c ****     clear_mods();
 924:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 925:tmk_core/common/action.c **** }
 926:tmk_core/common/action.c **** 
 927:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 928:tmk_core/common/action.c ****  *
 929:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 930:tmk_core/common/action.c ****  */
 931:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
 932:tmk_core/common/action.c ****     clear_keys();
 933:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 934:tmk_core/common/action.c **** }
 935:tmk_core/common/action.c **** 
 936:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 937:tmk_core/common/action.c ****  *
 938:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 939:tmk_core/common/action.c ****  */
 940:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 2142               		.loc 1 940 41 is_stmt 1 view -0
 2143               		.cfi_startproc
 2144               	/* prologue: function */
 2145               	/* frame size = 0 */
 2146               	/* stack size = 0 */
 2147               	.L__stack_usage = 0
 941:tmk_core/common/action.c ****     clear_weak_mods();
 2148               		.loc 1 941 5 view .LVU565
 2149 0000 0E94 0000 		call clear_weak_mods
 2150               	.LVL195:
 942:tmk_core/common/action.c ****     clear_macro_mods();
 2151               		.loc 1 942 5 view .LVU566
 2152 0004 0E94 0000 		call clear_macro_mods
 2153               	.LVL196:
 943:tmk_core/common/action.c ****     send_keyboard_report();
 2154               		.loc 1 943 5 view .LVU567
 2155 0008 0E94 0000 		call send_keyboard_report
 2156               	.LVL197:
 944:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 945:tmk_core/common/action.c ****     mousekey_clear();
 2157               		.loc 1 945 5 view .LVU568
 2158 000c 0E94 0000 		call mousekey_clear
 2159               	.LVL198:
 946:tmk_core/common/action.c ****     mousekey_send();
 2160               		.loc 1 946 5 view .LVU569
 2161 0010 0E94 0000 		call mousekey_send
 2162               	.LVL199:
 947:tmk_core/common/action.c **** #endif
 948:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 949:tmk_core/common/action.c ****     host_system_send(0);
 2163               		.loc 1 949 5 view .LVU570
 2164 0014 90E0      		ldi r25,0
 2165 0016 80E0      		ldi r24,0
 2166 0018 0E94 0000 		call host_system_send
 2167               	.LVL200:
 950:tmk_core/common/action.c ****     host_consumer_send(0);
 2168               		.loc 1 950 5 view .LVU571
 2169 001c 90E0      		ldi r25,0
 2170 001e 80E0      		ldi r24,0
 2171 0020 0C94 0000 		jmp host_consumer_send
 2172               	.LVL201:
 2173               		.cfi_endproc
 2174               	.LFE28:
 2176               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 2177               	.global	clear_keyboard_but_mods
 2179               	clear_keyboard_but_mods:
 2180               	.LFB27:
 931:tmk_core/common/action.c ****     clear_keys();
 2181               		.loc 1 931 36 view -0
 2182               		.cfi_startproc
 2183               	/* prologue: function */
 2184               	/* frame size = 0 */
 2185               	/* stack size = 0 */
 2186               	.L__stack_usage = 0
 932:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 2187               		.loc 1 932 5 view .LVU573
 2188 0000 0E94 0000 		call clear_keys
 2189               	.LVL202:
 933:tmk_core/common/action.c **** }
 2190               		.loc 1 933 5 view .LVU574
 2191 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 2192               	.LVL203:
 2193               		.cfi_endproc
 2194               	.LFE27:
 2196               		.section	.text.clear_keyboard,"ax",@progbits
 2197               	.global	clear_keyboard
 2199               	clear_keyboard:
 2200               	.LFB26:
 922:tmk_core/common/action.c ****     clear_mods();
 2201               		.loc 1 922 27 view -0
 2202               		.cfi_startproc
 2203               	/* prologue: function */
 2204               	/* frame size = 0 */
 2205               	/* stack size = 0 */
 2206               	.L__stack_usage = 0
 923:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 2207               		.loc 1 923 5 view .LVU576
 2208 0000 0E94 0000 		call clear_mods
 2209               	.LVL204:
 924:tmk_core/common/action.c **** }
 2210               		.loc 1 924 5 view .LVU577
 2211 0004 0C94 0000 		jmp clear_keyboard_but_mods
 2212               	.LVL205:
 2213               		.cfi_endproc
 2214               	.LFE26:
 2216               		.section	.text.is_tap_action,"ax",@progbits
 2217               	.global	is_tap_action
 2219               	is_tap_action:
 2220               	.LVL206:
 2221               	.LFB30:
 951:tmk_core/common/action.c **** #endif
 952:tmk_core/common/action.c **** }
 953:tmk_core/common/action.c **** 
 954:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 955:tmk_core/common/action.c ****  *
 956:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 957:tmk_core/common/action.c ****  */
 958:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
 959:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 960:tmk_core/common/action.c ****     return is_tap_action(action);
 961:tmk_core/common/action.c **** }
 962:tmk_core/common/action.c **** 
 963:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 964:tmk_core/common/action.c ****  *
 965:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 966:tmk_core/common/action.c ****  */
 967:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 2222               		.loc 1 967 37 view -0
 2223               		.cfi_startproc
 2224               	/* prologue: function */
 2225               	/* frame size = 0 */
 2226               	/* stack size = 0 */
 2227               	.L__stack_usage = 0
 968:tmk_core/common/action.c ****     switch (action.kind.id) {
 2228               		.loc 1 968 5 view .LVU579
 2229               		.loc 1 968 24 is_stmt 0 view .LVU580
 2230 0000 E92F      		mov r30,r25
 2231 0002 E295      		swap r30
 2232 0004 EF70      		andi r30,lo8(15)
 2233               		.loc 1 968 5 view .LVU581
 2234 0006 E250      		subi r30,lo8(-(-2))
 2235 0008 EE30      		cpi r30,lo8(14)
 2236 000a 00F4      		brsh .L222
 2237 000c F0E0      		ldi r31,0
 2238 000e E050      		subi r30,lo8(-(gs(.L216)))
 2239 0010 F040      		sbci r31,hi8(-(gs(.L216)))
 2240 0012 0C94 0000 		jmp __tablejump2__
 2241               		.section	.jumptables.gcc.is_tap_action,"a",@progbits
 2242               		.p2align	1
 2243               	.L216:
 2244 0000 0000      		.word gs(.L217)
 2245 0002 0000      		.word gs(.L217)
 2246 0004 0000      		.word gs(.L222)
 2247 0006 0000      		.word gs(.L222)
 2248 0008 0000      		.word gs(.L218)
 2249 000a 0000      		.word gs(.L222)
 2250 000c 0000      		.word gs(.L222)
 2251 000e 0000      		.word gs(.L222)
 2252 0010 0000      		.word gs(.L217)
 2253 0012 0000      		.word gs(.L217)
 2254 0014 0000      		.word gs(.L215)
 2255 0016 0000      		.word gs(.L222)
 2256 0018 0000      		.word gs(.L222)
 2257 001a 0000      		.word gs(.L215)
 2258               		.section	.text.is_tap_action
 2259               	.L217:
 969:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 970:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 971:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 972:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 973:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 2260               		.loc 1 973 13 is_stmt 1 view .LVU582
 2261 0016 803F      		cpi r24,lo8(-16)
 2262 0018 01F0      		breq .L225
 2263 001a 00F4      		brsh .L219
 2264 001c 883E      		cpi r24,lo8(-24)
 2265 001e 00F4      		brsh .L222
 2266               	.L225:
 974:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 975:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 976:tmk_core/common/action.c ****                 case OP_ONESHOT:
 977:tmk_core/common/action.c ****                     return true;
 2267               		.loc 1 977 28 is_stmt 0 view .LVU583
 2268 0020 81E0      		ldi r24,lo8(1)
 2269               	.LVL207:
 2270               	/* epilogue start */
 978:tmk_core/common/action.c ****             }
 979:tmk_core/common/action.c ****             return false;
 980:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 981:tmk_core/common/action.c ****             switch (action.swap.code) {
 982:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 983:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 984:tmk_core/common/action.c ****                     return true;
 985:tmk_core/common/action.c ****             }
 986:tmk_core/common/action.c ****             return false;
 987:tmk_core/common/action.c ****         case ACT_MACRO:
 988:tmk_core/common/action.c ****         case ACT_FUNCTION:
 989:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
 990:tmk_core/common/action.c ****                 return true;
 991:tmk_core/common/action.c ****             }
 992:tmk_core/common/action.c ****             return false;
 993:tmk_core/common/action.c ****     }
 994:tmk_core/common/action.c ****     return false;
 995:tmk_core/common/action.c **** }
 2271               		.loc 1 995 1 view .LVU584
 2272 0022 0895      		ret
 2273               	.LVL208:
 2274               	.L219:
 2275               		.loc 1 995 1 view .LVU585
 2276 0024 843F      		cpi r24,lo8(-12)
 2277 0026 01F0      		breq .L225
 2278               	.L222:
 979:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2279               		.loc 1 979 20 view .LVU586
 2280 0028 80E0      		ldi r24,0
 2281               	.LVL209:
 979:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2282               		.loc 1 979 20 view .LVU587
 2283 002a 0895      		ret
 2284               	.LVL210:
 2285               	.L218:
 981:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 2286               		.loc 1 981 13 is_stmt 1 view .LVU588
 2287 002c 883E      		cpi r24,lo8(-24)
 2288 002e 00F0      		brlo .L225
 2289 0030 813F      		cpi r24,lo8(-15)
 2290 0032 01F4      		brne .L222
 2291 0034 00C0      		rjmp .L225
 2292               	.L215:
 989:tmk_core/common/action.c ****                 return true;
 2293               		.loc 1 989 13 view .LVU589
 989:tmk_core/common/action.c ****                 return true;
 2294               		.loc 1 989 16 is_stmt 0 view .LVU590
 2295 0036 93FB      		bst r25,3
 2296 0038 8827      		clr r24
 2297 003a 80F9      		bld r24,0
 2298               	.LVL211:
 989:tmk_core/common/action.c ****                 return true;
 2299               		.loc 1 989 16 view .LVU591
 2300 003c 0895      		ret
 2301               		.cfi_endproc
 2302               	.LFE30:
 2304               		.section	.text.is_tap_key,"ax",@progbits
 2305               	.global	is_tap_key
 2307               	is_tap_key:
 2308               	.LVL212:
 2309               	.LFB29:
 958:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 2310               		.loc 1 958 31 is_stmt 1 view -0
 2311               		.cfi_startproc
 2312               	/* prologue: function */
 2313               	/* frame size = 0 */
 2314               	/* stack size = 0 */
 2315               	.L__stack_usage = 0
 959:tmk_core/common/action.c ****     return is_tap_action(action);
 2316               		.loc 1 959 5 view .LVU593
 959:tmk_core/common/action.c ****     return is_tap_action(action);
 2317               		.loc 1 959 23 is_stmt 0 view .LVU594
 2318 0000 0E94 0000 		call layer_switch_get_action
 2319               	.LVL213:
 960:tmk_core/common/action.c **** }
 2320               		.loc 1 960 5 is_stmt 1 view .LVU595
 960:tmk_core/common/action.c **** }
 2321               		.loc 1 960 12 is_stmt 0 view .LVU596
 2322 0004 0C94 0000 		jmp is_tap_action
 2323               	.LVL214:
 2324               		.cfi_endproc
 2325               	.LFE29:
 2327               		.section	.text.debug_event,"ax",@progbits
 2328               	.global	debug_event
 2330               	debug_event:
 2331               	.LFB31:
 996:tmk_core/common/action.c **** 
 997:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 998:tmk_core/common/action.c ****  *
 999:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1000:tmk_core/common/action.c ****  */
1001:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 2332               		.loc 1 1001 36 is_stmt 1 view -0
 2333               		.cfi_startproc
 2334 0000 CF93      		push r28
 2335               	.LCFI19:
 2336               		.cfi_def_cfa_offset 3
 2337               		.cfi_offset 28, -2
 2338 0002 DF93      		push r29
 2339               	.LCFI20:
 2340               		.cfi_def_cfa_offset 4
 2341               		.cfi_offset 29, -3
 2342 0004 00D0      		rcall .
 2343 0006 00D0      		rcall .
 2344 0008 0F92      		push __tmp_reg__
 2345               	.LCFI21:
 2346               		.cfi_def_cfa_offset 9
 2347 000a CDB7      		in r28,__SP_L__
 2348 000c DEB7      		in r29,__SP_H__
 2349               	.LCFI22:
 2350               		.cfi_def_cfa_register 28
 2351               	/* prologue: function */
 2352               	/* frame size = 5 */
 2353               	/* stack size = 7 */
 2354               	.L__stack_usage = 7
 2355               		.loc 1 1001 138 view .LVU598
 2356               	/* epilogue start */
 2357               		.loc 1 1001 1 is_stmt 0 view .LVU599
 2358 000e 0F90      		pop __tmp_reg__
 2359 0010 0F90      		pop __tmp_reg__
 2360 0012 0F90      		pop __tmp_reg__
 2361 0014 0F90      		pop __tmp_reg__
 2362 0016 0F90      		pop __tmp_reg__
 2363 0018 DF91      		pop r29
 2364 001a CF91      		pop r28
 2365 001c 0895      		ret
 2366               		.cfi_endproc
 2367               	.LFE31:
 2369               		.section	.text.debug_record,"ax",@progbits
 2370               	.global	debug_record
 2372               	debug_record:
 2373               	.LFB32:
1002:tmk_core/common/action.c **** 
1003:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1004:tmk_core/common/action.c ****  *
1005:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1006:tmk_core/common/action.c ****  */
1007:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 2374               		.loc 1 1007 39 is_stmt 1 view -0
 2375               		.cfi_startproc
 2376 0000 CF93      		push r28
 2377               	.LCFI23:
 2378               		.cfi_def_cfa_offset 3
 2379               		.cfi_offset 28, -2
 2380 0002 DF93      		push r29
 2381               	.LCFI24:
 2382               		.cfi_def_cfa_offset 4
 2383               		.cfi_offset 29, -3
 2384 0004 00D0      		rcall .
 2385 0006 00D0      		rcall .
 2386 0008 00D0      		rcall .
 2387               	.LCFI25:
 2388               		.cfi_def_cfa_offset 10
 2389 000a CDB7      		in r28,__SP_L__
 2390 000c DEB7      		in r29,__SP_H__
 2391               	.LCFI26:
 2392               		.cfi_def_cfa_register 28
 2393               	/* prologue: function */
 2394               	/* frame size = 6 */
 2395               	/* stack size = 8 */
 2396               	.L__stack_usage = 8
1008:tmk_core/common/action.c ****     debug_event(record.event);
 2397               		.loc 1 1008 5 view .LVU601
1009:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
1010:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 2398               		.loc 1 1010 77 view .LVU602
 2399               	/* epilogue start */
1011:tmk_core/common/action.c **** #endif
1012:tmk_core/common/action.c **** }
 2400               		.loc 1 1012 1 is_stmt 0 view .LVU603
 2401 000e 2696      		adiw r28,6
 2402 0010 0FB6      		in __tmp_reg__,__SREG__
 2403 0012 F894      		cli
 2404 0014 DEBF      		out __SP_H__,r29
 2405 0016 0FBE      		out __SREG__,__tmp_reg__
 2406 0018 CDBF      		out __SP_L__,r28
 2407 001a DF91      		pop r29
 2408 001c CF91      		pop r28
 2409 001e 0895      		ret
 2410               		.cfi_endproc
 2411               	.LFE32:
 2413               		.section	.text.debug_action,"ax",@progbits
 2414               	.global	debug_action
 2416               	debug_action:
 2417               	.LVL215:
 2418               	.LFB33:
1013:tmk_core/common/action.c **** 
1014:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1015:tmk_core/common/action.c ****  *
1016:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1017:tmk_core/common/action.c ****  */
1018:tmk_core/common/action.c **** void debug_action(action_t action) {
 2419               		.loc 1 1018 36 is_stmt 1 view -0
 2420               		.cfi_startproc
 2421               	/* prologue: function */
 2422               	/* frame size = 0 */
 2423               	/* stack size = 0 */
 2424               	.L__stack_usage = 0
1019:tmk_core/common/action.c ****     switch (action.kind.id) {
 2425               		.loc 1 1019 5 view .LVU605
1020:tmk_core/common/action.c ****         case ACT_LMODS:
1021:tmk_core/common/action.c ****             dprint("ACT_LMODS");
1022:tmk_core/common/action.c ****             break;
1023:tmk_core/common/action.c ****         case ACT_RMODS:
1024:tmk_core/common/action.c ****             dprint("ACT_RMODS");
1025:tmk_core/common/action.c ****             break;
1026:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1027:tmk_core/common/action.c ****             dprint("ACT_LMODS_TAP");
1028:tmk_core/common/action.c ****             break;
1029:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1030:tmk_core/common/action.c ****             dprint("ACT_RMODS_TAP");
1031:tmk_core/common/action.c ****             break;
1032:tmk_core/common/action.c ****         case ACT_USAGE:
1033:tmk_core/common/action.c ****             dprint("ACT_USAGE");
1034:tmk_core/common/action.c ****             break;
1035:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
1036:tmk_core/common/action.c ****             dprint("ACT_MOUSEKEY");
1037:tmk_core/common/action.c ****             break;
1038:tmk_core/common/action.c ****         case ACT_LAYER:
1039:tmk_core/common/action.c ****             dprint("ACT_LAYER");
1040:tmk_core/common/action.c ****             break;
1041:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
1042:tmk_core/common/action.c ****             dprint("ACT_LAYER_MODS");
1043:tmk_core/common/action.c ****             break;
1044:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1045:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP");
1046:tmk_core/common/action.c ****             break;
1047:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1048:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1049:tmk_core/common/action.c ****             break;
1050:tmk_core/common/action.c ****         case ACT_MACRO:
1051:tmk_core/common/action.c ****             dprint("ACT_MACRO");
1052:tmk_core/common/action.c ****             break;
1053:tmk_core/common/action.c ****         case ACT_COMMAND:
1054:tmk_core/common/action.c ****             dprint("ACT_COMMAND");
1055:tmk_core/common/action.c ****             break;
1056:tmk_core/common/action.c ****         case ACT_FUNCTION:
1057:tmk_core/common/action.c ****             dprint("ACT_FUNCTION");
1058:tmk_core/common/action.c ****             break;
1059:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1060:tmk_core/common/action.c ****             dprint("ACT_SWAP_HANDS");
1061:tmk_core/common/action.c ****             break;
1062:tmk_core/common/action.c ****         default:
1063:tmk_core/common/action.c ****             dprint("UNKNOWN");
1064:tmk_core/common/action.c ****             break;
1065:tmk_core/common/action.c ****     }
1066:tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 2426               		.loc 1 1066 75 view .LVU606
 2427               	/* epilogue start */
1067:tmk_core/common/action.c **** }
 2428               		.loc 1 1067 1 is_stmt 0 view .LVU607
 2429 0000 0895      		ret
 2430               		.cfi_endproc
 2431               	.LFE33:
 2433               	.global	disable_action_cache
 2434               		.section	.bss.disable_action_cache,"aw",@nobits
 2437               	disable_action_cache:
 2438 0000 00        		.zero	1
 2439               		.comm	tp_buttons,2,1
 2440               		.text
 2441               	.Letext0:
 2442               		.file 4 "/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/stdint.h"
 2443               		.file 5 "tmk_core/common/keycode.h"
 2444               		.file 6 "tmk_core/common/report.h"
 2445               		.file 7 "tmk_core/common/host.h"
 2446               		.file 8 "tmk_core/common/mousekey.h"
 2447               		.file 9 "tmk_core/common/command.h"
 2448               		.file 10 "tmk_core/common/action_code.h"
 2449               		.file 11 "tmk_core/common/action.h"
 2450               		.file 12 "tmk_core/common/action_layer.h"
 2451               		.file 13 "tmk_core/common/action_util.h"
 2452               		.file 14 "tmk_core/common/avr/xprintf.h"
 2453               		.file 15 "tmk_core/common/debug.h"
 2454               		.file 16 "tmk_core/common/led.h"
 2455               		.file 17 "tmk_core/common/action_macro.h"
 2456               		.file 18 "tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:4      *ABS*:000000000000003f __SREG__
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:13     .text.action_exec:0000000000000000 action_exec
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:94     .text.process_record_quantum:0000000000000000 process_record_quantum
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:116    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:141    .text.register_code:0000000000000000 register_code
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:558    .text.unregister_code:0000000000000000 unregister_code
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:726    .text.tap_code:0000000000000000 tap_code
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:790    .text.register_mods:0000000000000000 register_mods
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:819    .text.unregister_mods:0000000000000000 unregister_mods
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:848    .text.process_action:0000000000000000 process_action
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:1943   .text.process_record:0000000000000000 process_record
                            *COM*:0000000000000002 tp_buttons
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:2054   .text.process_record_nocache:0000000000000000 process_record_nocache
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:2437   .bss.disable_action_cache:0000000000000000 disable_action_cache
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:2082   .text.register_weak_mods:0000000000000000 register_weak_mods
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:2111   .text.unregister_weak_mods:0000000000000000 unregister_weak_mods
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:2140   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:2179   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:2199   .text.clear_keyboard:0000000000000000 clear_keyboard
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:2219   .text.is_tap_action:0000000000000000 is_tap_action
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:2307   .text.is_tap_key:0000000000000000 is_tap_key
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:2330   .text.debug_event:0000000000000000 debug_event
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:2372   .text.debug_record:0000000000000000 debug_record
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//ccZd5rV3.s:2416   .text.debug_action:0000000000000000 debug_action

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
host_keyboard_leds
add_key
send_keyboard_report
del_key
command_proc
add_mods
host_system_send
host_consumer_send
mousekey_on
mousekey_send
del_mods
mousekey_off
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
led_set
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
action_get_macro
action_macro_play
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
mousekey_clear
clear_keys
clear_mods
__do_clear_bss
