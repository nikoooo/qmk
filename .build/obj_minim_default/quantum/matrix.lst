   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.matrix_init_user,"ax",@progbits
  11               		.weak	matrix_init_user
  13               	matrix_init_user:
  14               	.LFB23:
  15               		.file 1 "quantum/matrix.c"
   1:quantum/matrix.c **** /*
   2:quantum/matrix.c **** Copyright 2012-2018 Jun Wako, Jack Humbert, Yiancar
   3:quantum/matrix.c **** 
   4:quantum/matrix.c **** This program is free software: you can redistribute it and/or modify
   5:quantum/matrix.c **** it under the terms of the GNU General Public License as published by
   6:quantum/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/matrix.c **** (at your option) any later version.
   8:quantum/matrix.c **** 
   9:quantum/matrix.c **** This program is distributed in the hope that it will be useful,
  10:quantum/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/matrix.c **** GNU General Public License for more details.
  13:quantum/matrix.c **** 
  14:quantum/matrix.c **** You should have received a copy of the GNU General Public License
  15:quantum/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/matrix.c **** */
  17:quantum/matrix.c **** #include <stdint.h>
  18:quantum/matrix.c **** #include <stdbool.h>
  19:quantum/matrix.c **** #include "wait.h"
  20:quantum/matrix.c **** #include "print.h"
  21:quantum/matrix.c **** #include "debug.h"
  22:quantum/matrix.c **** #include "util.h"
  23:quantum/matrix.c **** #include "matrix.h"
  24:quantum/matrix.c **** #include "debounce.h"
  25:quantum/matrix.c **** #include "quantum.h"
  26:quantum/matrix.c **** 
  27:quantum/matrix.c **** #if (MATRIX_COLS <= 8)
  28:quantum/matrix.c **** #    define print_matrix_header() print("\nr/c 01234567\n")
  29:quantum/matrix.c **** #    define print_matrix_row(row) print_bin_reverse8(matrix_get_row(row))
  30:quantum/matrix.c **** #    define matrix_bitpop(i) bitpop(matrix[i])
  31:quantum/matrix.c **** #    define ROW_SHIFTER ((uint8_t)1)
  32:quantum/matrix.c **** #elif (MATRIX_COLS <= 16)
  33:quantum/matrix.c **** #    define print_matrix_header() print("\nr/c 0123456789ABCDEF\n")
  34:quantum/matrix.c **** #    define print_matrix_row(row) print_bin_reverse16(matrix_get_row(row))
  35:quantum/matrix.c **** #    define matrix_bitpop(i) bitpop16(matrix[i])
  36:quantum/matrix.c **** #    define ROW_SHIFTER ((uint16_t)1)
  37:quantum/matrix.c **** #elif (MATRIX_COLS <= 32)
  38:quantum/matrix.c **** #    define print_matrix_header() print("\nr/c 0123456789ABCDEF0123456789ABCDEF\n")
  39:quantum/matrix.c **** #    define print_matrix_row(row) print_bin_reverse32(matrix_get_row(row))
  40:quantum/matrix.c **** #    define matrix_bitpop(i) bitpop32(matrix[i])
  41:quantum/matrix.c **** #    define ROW_SHIFTER ((uint32_t)1)
  42:quantum/matrix.c **** #endif
  43:quantum/matrix.c **** 
  44:quantum/matrix.c **** #ifdef MATRIX_MASKED
  45:quantum/matrix.c **** extern const matrix_row_t matrix_mask[];
  46:quantum/matrix.c **** #endif
  47:quantum/matrix.c **** 
  48:quantum/matrix.c **** #ifdef DIRECT_PINS
  49:quantum/matrix.c **** static pin_t direct_pins[MATRIX_ROWS][MATRIX_COLS] = DIRECT_PINS;
  50:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL) || (DIODE_DIRECTION == COL2ROW)
  51:quantum/matrix.c **** static const pin_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  52:quantum/matrix.c **** static const pin_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  53:quantum/matrix.c **** #endif
  54:quantum/matrix.c **** 
  55:quantum/matrix.c **** /* matrix state(1:on, 0:off) */
  56:quantum/matrix.c **** static matrix_row_t raw_matrix[MATRIX_ROWS];  // raw values
  57:quantum/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];      // debounced values
  58:quantum/matrix.c **** 
  59:quantum/matrix.c **** __attribute__((weak)) void matrix_init_quantum(void) { matrix_init_kb(); }
  60:quantum/matrix.c **** 
  61:quantum/matrix.c **** __attribute__((weak)) void matrix_scan_quantum(void) { matrix_scan_kb(); }
  62:quantum/matrix.c **** 
  63:quantum/matrix.c **** __attribute__((weak)) void matrix_init_kb(void) { matrix_init_user(); }
  64:quantum/matrix.c **** 
  65:quantum/matrix.c **** __attribute__((weak)) void matrix_scan_kb(void) { matrix_scan_user(); }
  66:quantum/matrix.c **** 
  67:quantum/matrix.c **** __attribute__((weak)) void matrix_init_user(void) {}
  16               		.loc 1 67 51 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22               		.loc 1 67 52 view .LVU1
  23               	/* epilogue start */
  24               		.loc 1 67 1 is_stmt 0 view .LVU2
  25 0000 0895      		ret
  26               		.cfi_endproc
  27               	.LFE23:
  29               		.set	matrix_init_user.localalias.0,matrix_init_user
  30               		.section	.text.matrix_init_kb,"ax",@progbits
  31               		.weak	matrix_init_kb
  33               	matrix_init_kb:
  34               	.LFB21:
  63:quantum/matrix.c **** 
  35               		.loc 1 63 49 is_stmt 1 view -0
  36               		.cfi_startproc
  37               	/* prologue: function */
  38               	/* frame size = 0 */
  39               	/* stack size = 0 */
  40               	.L__stack_usage = 0
  63:quantum/matrix.c **** 
  41               		.loc 1 63 51 view .LVU4
  42 0000 0C94 0000 		jmp matrix_init_user
  43               	.LVL0:
  44               		.cfi_endproc
  45               	.LFE21:
  47               		.section	.text.matrix_init_quantum,"ax",@progbits
  48               		.weak	matrix_init_quantum
  50               	matrix_init_quantum:
  51               	.LFB19:
  59:quantum/matrix.c **** 
  52               		.loc 1 59 54 view -0
  53               		.cfi_startproc
  54               	/* prologue: function */
  55               	/* frame size = 0 */
  56               	/* stack size = 0 */
  57               	.L__stack_usage = 0
  59:quantum/matrix.c **** 
  58               		.loc 1 59 56 view .LVU6
  59 0000 0C94 0000 		jmp matrix_init_kb
  60               	.LVL1:
  61               		.cfi_endproc
  62               	.LFE19:
  64               		.section	.text.matrix_scan_user,"ax",@progbits
  65               		.weak	matrix_scan_user
  67               	matrix_scan_user:
  68               	.LFB40:
  69               		.cfi_startproc
  70               	/* prologue: function */
  71               	/* frame size = 0 */
  72               	/* stack size = 0 */
  73               	.L__stack_usage = 0
  74               	/* epilogue start */
  75 0000 0895      		ret
  76               		.cfi_endproc
  77               	.LFE40:
  79               		.section	.text.matrix_scan_kb,"ax",@progbits
  80               		.weak	matrix_scan_kb
  82               	matrix_scan_kb:
  83               	.LFB22:
  65:quantum/matrix.c **** 
  84               		.loc 1 65 49 view -0
  85               		.cfi_startproc
  86               	/* prologue: function */
  87               	/* frame size = 0 */
  88               	/* stack size = 0 */
  89               	.L__stack_usage = 0
  65:quantum/matrix.c **** 
  90               		.loc 1 65 51 view .LVU8
  91 0000 0C94 0000 		jmp matrix_scan_user
  92               	.LVL2:
  93               		.cfi_endproc
  94               	.LFE22:
  96               		.section	.text.matrix_scan_quantum,"ax",@progbits
  97               		.weak	matrix_scan_quantum
  99               	matrix_scan_quantum:
 100               	.LFB20:
  61:quantum/matrix.c **** 
 101               		.loc 1 61 54 view -0
 102               		.cfi_startproc
 103               	/* prologue: function */
 104               	/* frame size = 0 */
 105               	/* stack size = 0 */
 106               	.L__stack_usage = 0
  61:quantum/matrix.c **** 
 107               		.loc 1 61 56 view .LVU10
 108 0000 0C94 0000 		jmp matrix_scan_kb
 109               	.LVL3:
 110               		.cfi_endproc
 111               	.LFE20:
 113               		.section	.text.matrix_rows,"ax",@progbits
 114               	.global	matrix_rows
 116               	matrix_rows:
 117               	.LFB25:
  68:quantum/matrix.c **** 
  69:quantum/matrix.c **** __attribute__((weak)) void matrix_scan_user(void) {}
  70:quantum/matrix.c **** 
  71:quantum/matrix.c **** inline uint8_t matrix_rows(void) { return MATRIX_ROWS; }
 118               		.loc 1 71 34 view -0
 119               		.cfi_startproc
 120               	/* prologue: function */
 121               	/* frame size = 0 */
 122               	/* stack size = 0 */
 123               	.L__stack_usage = 0
 124               		.loc 1 71 36 view .LVU12
 125               		.loc 1 71 1 is_stmt 0 view .LVU13
 126 0000 84E0      		ldi r24,lo8(4)
 127               	/* epilogue start */
 128 0002 0895      		ret
 129               		.cfi_endproc
 130               	.LFE25:
 132               		.section	.text.matrix_cols,"ax",@progbits
 133               	.global	matrix_cols
 135               	matrix_cols:
 136               	.LFB26:
  72:quantum/matrix.c **** 
  73:quantum/matrix.c **** inline uint8_t matrix_cols(void) { return MATRIX_COLS; }
 137               		.loc 1 73 34 is_stmt 1 view -0
 138               		.cfi_startproc
 139               	/* prologue: function */
 140               	/* frame size = 0 */
 141               	/* stack size = 0 */
 142               	.L__stack_usage = 0
 143               		.loc 1 73 36 view .LVU15
 144               		.loc 1 73 1 is_stmt 0 view .LVU16
 145 0000 8DE0      		ldi r24,lo8(13)
 146               	/* epilogue start */
 147 0002 0895      		ret
 148               		.cfi_endproc
 149               	.LFE26:
 151               		.section	.text.matrix_is_modified,"ax",@progbits
 152               	.global	matrix_is_modified
 154               	matrix_is_modified:
 155               	.LFB27:
  74:quantum/matrix.c **** 
  75:quantum/matrix.c **** // Deprecated.
  76:quantum/matrix.c **** bool matrix_is_modified(void) {
 156               		.loc 1 76 31 is_stmt 1 view -0
 157               		.cfi_startproc
 158               	/* prologue: function */
 159               	/* frame size = 0 */
 160               	/* stack size = 0 */
 161               	.L__stack_usage = 0
  77:quantum/matrix.c ****     if (debounce_active()) return false;
 162               		.loc 1 77 5 view .LVU18
 163               		.loc 1 77 9 is_stmt 0 view .LVU19
 164 0000 0E94 0000 		call debounce_active
 165               	.LVL4:
  78:quantum/matrix.c ****     return true;
  79:quantum/matrix.c **** }
 166               		.loc 1 79 1 view .LVU20
 167 0004 91E0      		ldi r25,lo8(1)
 168 0006 8927      		eor r24,r25
 169               	/* epilogue start */
 170 0008 0895      		ret
 171               		.cfi_endproc
 172               	.LFE27:
 174               		.section	.text.matrix_is_on,"ax",@progbits
 175               	.global	matrix_is_on
 177               	matrix_is_on:
 178               	.LVL5:
 179               	.LFB28:
  80:quantum/matrix.c **** 
  81:quantum/matrix.c **** inline bool matrix_is_on(uint8_t row, uint8_t col) { return (matrix[row] & ((matrix_row_t)1 << col)
 180               		.loc 1 81 52 is_stmt 1 view -0
 181               		.cfi_startproc
 182               	/* prologue: function */
 183               	/* frame size = 0 */
 184               	/* stack size = 0 */
 185               	.L__stack_usage = 0
 186               		.loc 1 81 54 view .LVU22
 187               		.loc 1 81 68 is_stmt 0 view .LVU23
 188 0000 E82F      		mov r30,r24
 189 0002 F0E0      		ldi r31,0
 190 0004 EE0F      		lsl r30
 191 0006 FF1F      		rol r31
 192               	.LVL6:
 193               		.loc 1 81 68 view .LVU24
 194 0008 E050      		subi r30,lo8(-(matrix))
 195 000a F040      		sbci r31,hi8(-(matrix))
 196               		.loc 1 81 93 view .LVU25
 197 000c 21E0      		ldi r18,lo8(1)
 198 000e 30E0      		ldi r19,0
 199 0010 00C0      		rjmp 2f
 200               		1:
 201 0012 220F      		lsl r18
 202 0014 331F      		rol r19
 203               		2:
 204 0016 6A95      		dec r22
 205 0018 02F4      		brpl 1b
 206               		.loc 1 81 74 view .LVU26
 207 001a 8081      		ld r24,Z
 208 001c 9181      		ldd r25,Z+1
 209 001e 2823      		and r18,r24
 210 0020 3923      		and r19,r25
 211 0022 81E0      		ldi r24,lo8(1)
 212 0024 232B      		or r18,r19
 213 0026 01F4      		brne .L11
 214 0028 80E0      		ldi r24,0
 215               	.L11:
 216               	/* epilogue start */
 217               		.loc 1 81 1 view .LVU27
 218 002a 0895      		ret
 219               		.cfi_endproc
 220               	.LFE28:
 222               		.section	.text.matrix_get_row,"ax",@progbits
 223               	.global	matrix_get_row
 225               	matrix_get_row:
 226               	.LVL7:
 227               	.LFB29:
  82:quantum/matrix.c **** 
  83:quantum/matrix.c **** inline matrix_row_t matrix_get_row(uint8_t row) {
 228               		.loc 1 83 49 is_stmt 1 view -0
 229               		.cfi_startproc
 230               	/* prologue: function */
 231               	/* frame size = 0 */
 232               	/* stack size = 0 */
 233               	.L__stack_usage = 0
  84:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
  85:quantum/matrix.c ****     // switch blocker installed and the switch is always pressed.
  86:quantum/matrix.c **** #ifdef MATRIX_MASKED
  87:quantum/matrix.c ****     return matrix[row] & matrix_mask[row];
  88:quantum/matrix.c **** #else
  89:quantum/matrix.c ****     return matrix[row];
 234               		.loc 1 89 5 view .LVU29
 235               		.loc 1 89 18 is_stmt 0 view .LVU30
 236 0000 E82F      		mov r30,r24
 237 0002 F0E0      		ldi r31,0
 238 0004 EE0F      		lsl r30
 239 0006 FF1F      		rol r31
 240               	.LVL8:
 241               		.loc 1 89 18 view .LVU31
 242 0008 E050      		subi r30,lo8(-(matrix))
 243 000a F040      		sbci r31,hi8(-(matrix))
  90:quantum/matrix.c **** #endif
  91:quantum/matrix.c **** }
 244               		.loc 1 91 1 view .LVU32
 245 000c 8081      		ld r24,Z
 246 000e 9181      		ldd r25,Z+1
 247               	/* epilogue start */
 248 0010 0895      		ret
 249               		.cfi_endproc
 250               	.LFE29:
 252               		.section	.text.matrix_print,"ax",@progbits
 253               	.global	matrix_print
 255               	matrix_print:
 256               	.LFB30:
  92:quantum/matrix.c **** 
  93:quantum/matrix.c **** void matrix_print(void) {
 257               		.loc 1 93 25 is_stmt 1 view -0
 258               		.cfi_startproc
 259 0000 CF92      		push r12
 260               	.LCFI0:
 261               		.cfi_def_cfa_offset 3
 262               		.cfi_offset 12, -2
 263 0002 DF92      		push r13
 264               	.LCFI1:
 265               		.cfi_def_cfa_offset 4
 266               		.cfi_offset 13, -3
 267 0004 EF92      		push r14
 268               	.LCFI2:
 269               		.cfi_def_cfa_offset 5
 270               		.cfi_offset 14, -4
 271 0006 FF92      		push r15
 272               	.LCFI3:
 273               		.cfi_def_cfa_offset 6
 274               		.cfi_offset 15, -5
 275 0008 0F93      		push r16
 276               	.LCFI4:
 277               		.cfi_def_cfa_offset 7
 278               		.cfi_offset 16, -6
 279 000a 1F93      		push r17
 280               	.LCFI5:
 281               		.cfi_def_cfa_offset 8
 282               		.cfi_offset 17, -7
 283 000c CF93      		push r28
 284               	.LCFI6:
 285               		.cfi_def_cfa_offset 9
 286               		.cfi_offset 28, -8
 287 000e DF93      		push r29
 288               	.LCFI7:
 289               		.cfi_def_cfa_offset 10
 290               		.cfi_offset 29, -9
 291               	/* prologue: function */
 292               	/* frame size = 0 */
 293               	/* stack size = 8 */
 294               	.L__stack_usage = 8
  94:quantum/matrix.c ****     print_matrix_header();
 295               		.loc 1 94 5 view .LVU34
 296               	.LBB18:
 297               		.loc 1 94 5 view .LVU35
 298               		.loc 1 94 5 view .LVU36
 299               	.LBE18:
 300 0010 80E0      		ldi r24,lo8(__c.3401)
 301 0012 90E0      		ldi r25,hi8(__c.3401)
 302 0014 0E94 0000 		call xputs
  95:quantum/matrix.c **** 
  96:quantum/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 303               		.loc 1 96 5 view .LVU37
 304               	.LBB19:
 305               		.loc 1 96 10 view .LVU38
 306               		.loc 1 96 27 view .LVU39
 307 0018 80E0      		ldi r24,lo8(matrix)
 308 001a E82E      		mov r14,r24
 309 001c 80E0      		ldi r24,hi8(matrix)
 310 001e F82E      		mov r15,r24
 311               	.LBE19:
  94:quantum/matrix.c ****     print_matrix_header();
 312               		.loc 1 94 5 is_stmt 0 view .LVU40
 313 0020 D0E0      		ldi r29,0
 314 0022 C0E0      		ldi r28,0
 315               	.LBB26:
  97:quantum/matrix.c ****         phex(row);
 316               		.loc 1 97 9 view .LVU41
 317 0024 90E0      		ldi r25,lo8(__c.3404)
 318 0026 C92E      		mov r12,r25
 319 0028 90E0      		ldi r25,hi8(__c.3404)
 320 002a D92E      		mov r13,r25
  98:quantum/matrix.c ****         print(": ");
  99:quantum/matrix.c ****         print_matrix_row(row);
 321               		.loc 1 99 9 view .LVU42
 322 002c 00E0      		ldi r16,lo8(__c.3408)
 323 002e 10E0      		ldi r17,hi8(__c.3408)
 324               	.L14:
  97:quantum/matrix.c ****         phex(row);
 325               		.loc 1 97 9 is_stmt 1 discriminator 3 view .LVU43
 326               	.LBB20:
  97:quantum/matrix.c ****         phex(row);
 327               		.loc 1 97 9 discriminator 3 view .LVU44
  97:quantum/matrix.c ****         phex(row);
 328               		.loc 1 97 9 discriminator 3 view .LVU45
 329               	.LBE20:
 330 0030 DF93      		push r29
 331               	.LCFI8:
 332               		.cfi_def_cfa_offset 11
 333 0032 CF93      		push r28
 334               	.LCFI9:
 335               		.cfi_def_cfa_offset 12
 336 0034 DF92      		push r13
 337               	.LCFI10:
 338               		.cfi_def_cfa_offset 13
 339 0036 CF92      		push r12
 340               	.LCFI11:
 341               		.cfi_def_cfa_offset 14
 342 0038 0E94 0000 		call __xprintf
  98:quantum/matrix.c ****         print(": ");
 343               		.loc 1 98 9 discriminator 3 view .LVU46
 344               	.LBB21:
  98:quantum/matrix.c ****         print(": ");
 345               		.loc 1 98 9 discriminator 3 view .LVU47
  98:quantum/matrix.c ****         print(": ");
 346               		.loc 1 98 9 discriminator 3 view .LVU48
 347               	.LBE21:
 348 003c 80E0      		ldi r24,lo8(__c.3406)
 349 003e 90E0      		ldi r25,hi8(__c.3406)
 350 0040 0E94 0000 		call xputs
 351               		.loc 1 99 9 discriminator 3 view .LVU49
 352               	.LBB22:
 353               	.LBI22:
  83:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 354               		.loc 1 83 21 discriminator 3 view .LVU50
 355               	.LBB23:
  89:quantum/matrix.c **** #endif
 356               		.loc 1 89 5 discriminator 3 view .LVU51
 357               	.LBE23:
 358               	.LBE22:
 359               		.loc 1 99 9 is_stmt 0 discriminator 3 view .LVU52
 360 0044 F701      		movw r30,r14
 361 0046 8191      		ld r24,Z+
 362 0048 9191      		ld r25,Z+
 363 004a 7F01      		movw r14,r30
 364 004c 0E94 0000 		call bitrev16
 365               	.LBB24:
 366               		.loc 1 99 9 is_stmt 1 discriminator 3 view .LVU53
 367               		.loc 1 99 9 discriminator 3 view .LVU54
 368               	.LBE24:
 369 0050 9F93      		push r25
 370               	.LCFI12:
 371               		.cfi_def_cfa_offset 15
 372 0052 8F93      		push r24
 373               	.LCFI13:
 374               		.cfi_def_cfa_offset 16
 375 0054 1F93      		push r17
 376               	.LCFI14:
 377               		.cfi_def_cfa_offset 17
 378 0056 0F93      		push r16
 379               	.LCFI15:
 380               		.cfi_def_cfa_offset 18
 381 0058 0E94 0000 		call __xprintf
 100:quantum/matrix.c ****         print("\n");
 382               		.loc 1 100 9 discriminator 3 view .LVU55
 383               	.LBB25:
 384               		.loc 1 100 9 discriminator 3 view .LVU56
 385               		.loc 1 100 9 discriminator 3 view .LVU57
 386               	.LBE25:
 387 005c 80E0      		ldi r24,lo8(__c.3410)
 388 005e 90E0      		ldi r25,hi8(__c.3410)
 389 0060 0E94 0000 		call xputs
  96:quantum/matrix.c ****         phex(row);
 390               		.loc 1 96 46 discriminator 3 view .LVU58
  96:quantum/matrix.c ****         phex(row);
 391               		.loc 1 96 27 discriminator 3 view .LVU59
 392 0064 2196      		adiw r28,1
  96:quantum/matrix.c ****         phex(row);
 393               		.loc 1 96 5 is_stmt 0 discriminator 3 view .LVU60
 394 0066 8DB7      		in r24,__SP_L__
 395 0068 9EB7      		in r25,__SP_H__
 396 006a 0896      		adiw r24,8
 397 006c 0FB6      		in __tmp_reg__,__SREG__
 398 006e F894      		cli
 399 0070 9EBF      		out __SP_H__,r25
 400 0072 0FBE      		out __SREG__,__tmp_reg__
 401 0074 8DBF      		out __SP_L__,r24
 402               	.LCFI16:
 403               		.cfi_def_cfa_offset 10
 404 0076 C430      		cpi r28,4
 405 0078 D105      		cpc r29,__zero_reg__
 406 007a 01F4      		brne .L14
 407               	/* epilogue start */
 408               	.LBE26:
 101:quantum/matrix.c ****     }
 102:quantum/matrix.c **** }
 409               		.loc 1 102 1 view .LVU61
 410 007c DF91      		pop r29
 411 007e CF91      		pop r28
 412 0080 1F91      		pop r17
 413 0082 0F91      		pop r16
 414 0084 FF90      		pop r15
 415 0086 EF90      		pop r14
 416 0088 DF90      		pop r13
 417 008a CF90      		pop r12
 418 008c 0895      		ret
 419               		.cfi_endproc
 420               	.LFE30:
 422               		.section	.text.matrix_key_count,"ax",@progbits
 423               	.global	matrix_key_count
 425               	matrix_key_count:
 426               	.LFB31:
 103:quantum/matrix.c **** 
 104:quantum/matrix.c **** uint8_t matrix_key_count(void) {
 427               		.loc 1 104 32 is_stmt 1 view -0
 428               		.cfi_startproc
 429 0000 0F93      		push r16
 430               	.LCFI17:
 431               		.cfi_def_cfa_offset 3
 432               		.cfi_offset 16, -2
 433 0002 1F93      		push r17
 434               	.LCFI18:
 435               		.cfi_def_cfa_offset 4
 436               		.cfi_offset 17, -3
 437 0004 CF93      		push r28
 438               	.LCFI19:
 439               		.cfi_def_cfa_offset 5
 440               		.cfi_offset 28, -4
 441               	/* prologue: function */
 442               	/* frame size = 0 */
 443               	/* stack size = 3 */
 444               	.L__stack_usage = 3
 105:quantum/matrix.c ****     uint8_t count = 0;
 445               		.loc 1 105 5 view .LVU63
 446               	.LVL9:
 106:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 447               		.loc 1 106 5 view .LVU64
 448               	.LBB27:
 449               		.loc 1 106 10 view .LVU65
 450               		.loc 1 106 25 view .LVU66
 451 0006 00E0      		ldi r16,lo8(matrix)
 452 0008 10E0      		ldi r17,hi8(matrix)
 453               	.LBE27:
 105:quantum/matrix.c ****     uint8_t count = 0;
 454               		.loc 1 105 13 is_stmt 0 view .LVU67
 455 000a C0E0      		ldi r28,0
 456               	.LVL10:
 457               	.L17:
 458               	.LBB28:
 107:quantum/matrix.c ****         count += matrix_bitpop(i);
 459               		.loc 1 107 9 is_stmt 1 discriminator 3 view .LVU68
 460               		.loc 1 107 18 is_stmt 0 discriminator 3 view .LVU69
 461 000c F801      		movw r30,r16
 462 000e 8191      		ld r24,Z+
 463 0010 9191      		ld r25,Z+
 464 0012 8F01      		movw r16,r30
 465 0014 0E94 0000 		call bitpop16
 466               	.LVL11:
 467               		.loc 1 107 15 discriminator 3 view .LVU70
 468 0018 C80F      		add r28,r24
 469               	.LVL12:
 106:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 470               		.loc 1 106 42 is_stmt 1 discriminator 3 view .LVU71
 106:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 471               		.loc 1 106 25 discriminator 3 view .LVU72
 106:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 472               		.loc 1 106 5 is_stmt 0 discriminator 3 view .LVU73
 473 001a F0E0      		ldi r31,hi8(matrix+8)
 474 001c 0030      		cpi r16,lo8(matrix+8)
 475 001e 1F07      		cpc r17,r31
 476 0020 01F4      		brne .L17
 477               	.LBE28:
 108:quantum/matrix.c ****     }
 109:quantum/matrix.c ****     return count;
 478               		.loc 1 109 5 is_stmt 1 view .LVU74
 110:quantum/matrix.c **** }
 479               		.loc 1 110 1 is_stmt 0 view .LVU75
 480 0022 8C2F      		mov r24,r28
 481               	/* epilogue start */
 482 0024 CF91      		pop r28
 483               	.LVL13:
 484               		.loc 1 110 1 view .LVU76
 485 0026 1F91      		pop r17
 486 0028 0F91      		pop r16
 487 002a 0895      		ret
 488               		.cfi_endproc
 489               	.LFE31:
 491               		.section	.text.matrix_init,"ax",@progbits
 492               	.global	matrix_init
 494               	matrix_init:
 495               	.LFB37:
 111:quantum/matrix.c **** 
 112:quantum/matrix.c **** #ifdef DIRECT_PINS
 113:quantum/matrix.c **** 
 114:quantum/matrix.c **** static void init_pins(void) {
 115:quantum/matrix.c ****     for (int row = 0; row < MATRIX_ROWS; row++) {
 116:quantum/matrix.c ****         for (int col = 0; col < MATRIX_COLS; col++) {
 117:quantum/matrix.c ****             pin_t pin = direct_pins[row][col];
 118:quantum/matrix.c ****             if (pin != NO_PIN) {
 119:quantum/matrix.c ****                 setPinInputHigh(pin);
 120:quantum/matrix.c ****             }
 121:quantum/matrix.c ****         }
 122:quantum/matrix.c ****     }
 123:quantum/matrix.c **** }
 124:quantum/matrix.c **** 
 125:quantum/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row) {
 126:quantum/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 127:quantum/matrix.c ****     current_matrix[current_row] = 0;
 128:quantum/matrix.c **** 
 129:quantum/matrix.c ****     for (uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 130:quantum/matrix.c ****         pin_t pin = direct_pins[current_row][col_index];
 131:quantum/matrix.c ****         if (pin != NO_PIN) {
 132:quantum/matrix.c ****             current_matrix[current_row] |= readPin(pin) ? 0 : (ROW_SHIFTER << col_index);
 133:quantum/matrix.c ****         }
 134:quantum/matrix.c ****     }
 135:quantum/matrix.c **** 
 136:quantum/matrix.c ****     return (last_row_value != current_matrix[current_row]);
 137:quantum/matrix.c **** }
 138:quantum/matrix.c **** 
 139:quantum/matrix.c **** #elif (DIODE_DIRECTION == COL2ROW)
 140:quantum/matrix.c **** 
 141:quantum/matrix.c **** static void select_row(uint8_t row) {
 142:quantum/matrix.c ****     setPinOutput(row_pins[row]);
 143:quantum/matrix.c ****     writePinLow(row_pins[row]);
 144:quantum/matrix.c **** }
 145:quantum/matrix.c **** 
 146:quantum/matrix.c **** static void unselect_row(uint8_t row) { setPinInputHigh(row_pins[row]); }
 147:quantum/matrix.c **** 
 148:quantum/matrix.c **** static void unselect_rows(void) {
 149:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_ROWS; x++) {
 150:quantum/matrix.c ****         setPinInputHigh(row_pins[x]);
 151:quantum/matrix.c ****     }
 152:quantum/matrix.c **** }
 153:quantum/matrix.c **** 
 154:quantum/matrix.c **** static void init_pins(void) {
 155:quantum/matrix.c ****     unselect_rows();
 156:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_COLS; x++) {
 157:quantum/matrix.c ****         setPinInputHigh(col_pins[x]);
 158:quantum/matrix.c ****     }
 159:quantum/matrix.c **** }
 160:quantum/matrix.c **** 
 161:quantum/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row) {
 162:quantum/matrix.c ****     // Store last value of row prior to reading
 163:quantum/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 164:quantum/matrix.c **** 
 165:quantum/matrix.c ****     // Clear data in matrix row
 166:quantum/matrix.c ****     current_matrix[current_row] = 0;
 167:quantum/matrix.c **** 
 168:quantum/matrix.c ****     // Select row and wait for row selecton to stabilize
 169:quantum/matrix.c ****     select_row(current_row);
 170:quantum/matrix.c ****     wait_us(30);
 171:quantum/matrix.c **** 
 172:quantum/matrix.c ****     // For each col...
 173:quantum/matrix.c ****     for (uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 174:quantum/matrix.c ****         // Select the col pin to read (active low)
 175:quantum/matrix.c ****         uint8_t pin_state = readPin(col_pins[col_index]);
 176:quantum/matrix.c **** 
 177:quantum/matrix.c ****         // Populate the matrix row with the state of the col pin
 178:quantum/matrix.c ****         current_matrix[current_row] |= pin_state ? 0 : (ROW_SHIFTER << col_index);
 179:quantum/matrix.c ****     }
 180:quantum/matrix.c **** 
 181:quantum/matrix.c ****     // Unselect row
 182:quantum/matrix.c ****     unselect_row(current_row);
 183:quantum/matrix.c **** 
 184:quantum/matrix.c ****     return (last_row_value != current_matrix[current_row]);
 185:quantum/matrix.c **** }
 186:quantum/matrix.c **** 
 187:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
 188:quantum/matrix.c **** 
 189:quantum/matrix.c **** static void select_col(uint8_t col) {
 190:quantum/matrix.c ****     setPinOutput(col_pins[col]);
 191:quantum/matrix.c ****     writePinLow(col_pins[col]);
 192:quantum/matrix.c **** }
 193:quantum/matrix.c **** 
 194:quantum/matrix.c **** static void unselect_col(uint8_t col) { setPinInputHigh(col_pins[col]); }
 195:quantum/matrix.c **** 
 196:quantum/matrix.c **** static void unselect_cols(void) {
 197:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_COLS; x++) {
 198:quantum/matrix.c ****         setPinInputHigh(col_pins[x]);
 199:quantum/matrix.c ****     }
 200:quantum/matrix.c **** }
 201:quantum/matrix.c **** 
 202:quantum/matrix.c **** static void init_pins(void) {
 203:quantum/matrix.c ****     unselect_cols();
 204:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_ROWS; x++) {
 205:quantum/matrix.c ****         setPinInputHigh(row_pins[x]);
 206:quantum/matrix.c ****     }
 207:quantum/matrix.c **** }
 208:quantum/matrix.c **** 
 209:quantum/matrix.c **** static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col) {
 210:quantum/matrix.c ****     bool matrix_changed = false;
 211:quantum/matrix.c **** 
 212:quantum/matrix.c ****     // Select col and wait for col selecton to stabilize
 213:quantum/matrix.c ****     select_col(current_col);
 214:quantum/matrix.c ****     wait_us(30);
 215:quantum/matrix.c **** 
 216:quantum/matrix.c ****     // For each row...
 217:quantum/matrix.c ****     for (uint8_t row_index = 0; row_index < MATRIX_ROWS; row_index++) {
 218:quantum/matrix.c ****         // Store last value of row prior to reading
 219:quantum/matrix.c ****         matrix_row_t last_row_value = current_matrix[row_index];
 220:quantum/matrix.c **** 
 221:quantum/matrix.c ****         // Check row pin state
 222:quantum/matrix.c ****         if (readPin(row_pins[row_index]) == 0) {
 223:quantum/matrix.c ****             // Pin LO, set col bit
 224:quantum/matrix.c ****             current_matrix[row_index] |= (ROW_SHIFTER << current_col);
 225:quantum/matrix.c ****         } else {
 226:quantum/matrix.c ****             // Pin HI, clear col bit
 227:quantum/matrix.c ****             current_matrix[row_index] &= ~(ROW_SHIFTER << current_col);
 228:quantum/matrix.c ****         }
 229:quantum/matrix.c **** 
 230:quantum/matrix.c ****         // Determine if the matrix changed state
 231:quantum/matrix.c ****         if ((last_row_value != current_matrix[row_index]) && !(matrix_changed)) {
 232:quantum/matrix.c ****             matrix_changed = true;
 233:quantum/matrix.c ****         }
 234:quantum/matrix.c ****     }
 235:quantum/matrix.c **** 
 236:quantum/matrix.c ****     // Unselect col
 237:quantum/matrix.c ****     unselect_col(current_col);
 238:quantum/matrix.c **** 
 239:quantum/matrix.c ****     return matrix_changed;
 240:quantum/matrix.c **** }
 241:quantum/matrix.c **** 
 242:quantum/matrix.c **** #endif
 243:quantum/matrix.c **** 
 244:quantum/matrix.c **** void matrix_init(void) {
 496               		.loc 1 244 24 is_stmt 1 view -0
 497               		.cfi_startproc
 498 0000 CF93      		push r28
 499               	.LCFI20:
 500               		.cfi_def_cfa_offset 3
 501               		.cfi_offset 28, -2
 502 0002 DF93      		push r29
 503               	.LCFI21:
 504               		.cfi_def_cfa_offset 4
 505               		.cfi_offset 29, -3
 506               	/* prologue: function */
 507               	/* frame size = 0 */
 508               	/* stack size = 2 */
 509               	.L__stack_usage = 2
 245:quantum/matrix.c ****     // initialize key pins
 246:quantum/matrix.c ****     init_pins();
 510               		.loc 1 246 5 view .LVU78
 511               	.LBB36:
 512               	.LBI36:
 154:quantum/matrix.c ****     unselect_rows();
 513               		.loc 1 154 13 view .LVU79
 514               	.LBE36:
 155:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_COLS; x++) {
 515               		.loc 1 155 5 view .LVU80
 516               	.LBB40:
 517               	.LBB37:
 518               	.LBI37:
 148:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_ROWS; x++) {
 519               		.loc 1 148 13 view .LVU81
 520               	.LVL14:
 521               	.LBB38:
 149:quantum/matrix.c ****         setPinInputHigh(row_pins[x]);
 522               		.loc 1 149 25 view .LVU82
 523 0004 A0E0      		ldi r26,lo8(row_pins)
 524 0006 B0E0      		ldi r27,hi8(row_pins)
 525 0008 40E0      		ldi r20,lo8(row_pins+4)
 526 000a 50E0      		ldi r21,hi8(row_pins+4)
 150:quantum/matrix.c ****     }
 527               		.loc 1 150 9 is_stmt 0 view .LVU83
 528 000c C1E0      		ldi r28,lo8(1)
 529 000e D0E0      		ldi r29,0
 530               	.LVL15:
 531               	.L20:
 150:quantum/matrix.c ****     }
 532               		.loc 1 150 9 is_stmt 1 view .LVU84
 533 0010 8D91      		ld r24,X+
 534               	.LVL16:
 150:quantum/matrix.c ****     }
 535               		.loc 1 150 9 is_stmt 0 view .LVU85
 536 0012 E82F      		mov r30,r24
 537 0014 E295      		swap r30
 538 0016 EF70      		andi r30,lo8(15)
 539 0018 F0E0      		ldi r31,0
 540 001a 61A1      		ldd r22,Z+33
 541 001c 8F70      		andi r24,lo8(15)
 542 001e 9E01      		movw r18,r28
 543 0020 00C0      		rjmp 2f
 544               		1:
 545 0022 220F      		lsl r18
 546               		2:
 547 0024 8A95      		dec r24
 548 0026 02F4      		brpl 1b
 549 0028 922F      		mov r25,r18
 550 002a 9095      		com r25
 551 002c 9623      		and r25,r22
 552 002e 91A3      		std Z+33,r25
 553 0030 82A1      		ldd r24,Z+34
 554 0032 822B      		or r24,r18
 555 0034 82A3      		std Z+34,r24
 149:quantum/matrix.c ****         setPinInputHigh(row_pins[x]);
 556               		.loc 1 149 42 is_stmt 1 view .LVU86
 557               	.LVL17:
 149:quantum/matrix.c ****         setPinInputHigh(row_pins[x]);
 558               		.loc 1 149 25 view .LVU87
 149:quantum/matrix.c ****         setPinInputHigh(row_pins[x]);
 559               		.loc 1 149 5 is_stmt 0 view .LVU88
 560 0036 4A17      		cp r20,r26
 561 0038 5B07      		cpc r21,r27
 562 003a 01F4      		brne .L20
 563 003c A0E0      		ldi r26,lo8(col_pins)
 564 003e B0E0      		ldi r27,hi8(col_pins)
 565               	.LVL18:
 149:quantum/matrix.c ****         setPinInputHigh(row_pins[x]);
 566               		.loc 1 149 5 view .LVU89
 567 0040 40E0      		ldi r20,lo8(col_pins+13)
 568 0042 50E0      		ldi r21,hi8(col_pins+13)
 569               	.LBE38:
 570               	.LBE37:
 571               	.LBB39:
 157:quantum/matrix.c ****     }
 572               		.loc 1 157 9 view .LVU90
 573 0044 C1E0      		ldi r28,lo8(1)
 574 0046 D0E0      		ldi r29,0
 575               	.L21:
 576               	.LVL19:
 157:quantum/matrix.c ****     }
 577               		.loc 1 157 9 is_stmt 1 view .LVU91
 578 0048 8D91      		ld r24,X+
 579               	.LVL20:
 157:quantum/matrix.c ****     }
 580               		.loc 1 157 9 is_stmt 0 view .LVU92
 581 004a E82F      		mov r30,r24
 582 004c E295      		swap r30
 583 004e EF70      		andi r30,lo8(15)
 584 0050 F0E0      		ldi r31,0
 585 0052 61A1      		ldd r22,Z+33
 586 0054 8F70      		andi r24,lo8(15)
 587 0056 9E01      		movw r18,r28
 588 0058 00C0      		rjmp 2f
 589               		1:
 590 005a 220F      		lsl r18
 591               		2:
 592 005c 8A95      		dec r24
 593 005e 02F4      		brpl 1b
 594 0060 922F      		mov r25,r18
 595 0062 9095      		com r25
 596 0064 9623      		and r25,r22
 597 0066 91A3      		std Z+33,r25
 598 0068 82A1      		ldd r24,Z+34
 599 006a 822B      		or r24,r18
 600 006c 82A3      		std Z+34,r24
 156:quantum/matrix.c ****         setPinInputHigh(col_pins[x]);
 601               		.loc 1 156 42 is_stmt 1 view .LVU93
 602               	.LVL21:
 156:quantum/matrix.c ****         setPinInputHigh(col_pins[x]);
 603               		.loc 1 156 25 view .LVU94
 156:quantum/matrix.c ****         setPinInputHigh(col_pins[x]);
 604               		.loc 1 156 5 is_stmt 0 view .LVU95
 605 006e 4A17      		cp r20,r26
 606 0070 5B07      		cpc r21,r27
 607 0072 01F4      		brne .L21
 608               	.LVL22:
 156:quantum/matrix.c ****         setPinInputHigh(col_pins[x]);
 609               		.loc 1 156 5 view .LVU96
 610               	.LBE39:
 611               	.LBE40:
 612               	.LBB41:
 247:quantum/matrix.c **** 
 248:quantum/matrix.c ****     // initialize matrix state: all keys off
 249:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 613               		.loc 1 249 25 is_stmt 1 view .LVU97
 250:quantum/matrix.c ****         raw_matrix[i] = 0;
 614               		.loc 1 250 9 view .LVU98
 615               		.loc 1 250 23 is_stmt 0 view .LVU99
 616 0074 1092 0000 		sts raw_matrix+1,__zero_reg__
 617 0078 1092 0000 		sts raw_matrix,__zero_reg__
 251:quantum/matrix.c ****         matrix[i]     = 0;
 618               		.loc 1 251 9 is_stmt 1 view .LVU100
 619               		.loc 1 251 23 is_stmt 0 view .LVU101
 620 007c 1092 0000 		sts matrix+1,__zero_reg__
 621 0080 1092 0000 		sts matrix,__zero_reg__
 249:quantum/matrix.c ****         raw_matrix[i] = 0;
 622               		.loc 1 249 42 is_stmt 1 view .LVU102
 623               	.LVL23:
 249:quantum/matrix.c ****         raw_matrix[i] = 0;
 624               		.loc 1 249 25 view .LVU103
 250:quantum/matrix.c ****         raw_matrix[i] = 0;
 625               		.loc 1 250 9 view .LVU104
 250:quantum/matrix.c ****         raw_matrix[i] = 0;
 626               		.loc 1 250 23 is_stmt 0 view .LVU105
 627 0084 1092 0000 		sts raw_matrix+2+1,__zero_reg__
 628 0088 1092 0000 		sts raw_matrix+2,__zero_reg__
 629               		.loc 1 251 9 is_stmt 1 view .LVU106
 630               		.loc 1 251 23 is_stmt 0 view .LVU107
 631 008c 1092 0000 		sts matrix+2+1,__zero_reg__
 632 0090 1092 0000 		sts matrix+2,__zero_reg__
 249:quantum/matrix.c ****         raw_matrix[i] = 0;
 633               		.loc 1 249 42 is_stmt 1 view .LVU108
 634               	.LVL24:
 249:quantum/matrix.c ****         raw_matrix[i] = 0;
 635               		.loc 1 249 25 view .LVU109
 250:quantum/matrix.c ****         raw_matrix[i] = 0;
 636               		.loc 1 250 9 view .LVU110
 250:quantum/matrix.c ****         raw_matrix[i] = 0;
 637               		.loc 1 250 23 is_stmt 0 view .LVU111
 638 0094 1092 0000 		sts raw_matrix+4+1,__zero_reg__
 639 0098 1092 0000 		sts raw_matrix+4,__zero_reg__
 640               		.loc 1 251 9 is_stmt 1 view .LVU112
 641               		.loc 1 251 23 is_stmt 0 view .LVU113
 642 009c 1092 0000 		sts matrix+4+1,__zero_reg__
 643 00a0 1092 0000 		sts matrix+4,__zero_reg__
 249:quantum/matrix.c ****         raw_matrix[i] = 0;
 644               		.loc 1 249 42 is_stmt 1 view .LVU114
 645               	.LVL25:
 249:quantum/matrix.c ****         raw_matrix[i] = 0;
 646               		.loc 1 249 25 view .LVU115
 250:quantum/matrix.c ****         raw_matrix[i] = 0;
 647               		.loc 1 250 9 view .LVU116
 250:quantum/matrix.c ****         raw_matrix[i] = 0;
 648               		.loc 1 250 23 is_stmt 0 view .LVU117
 649 00a4 1092 0000 		sts raw_matrix+6+1,__zero_reg__
 650 00a8 1092 0000 		sts raw_matrix+6,__zero_reg__
 651               		.loc 1 251 9 is_stmt 1 view .LVU118
 652               		.loc 1 251 23 is_stmt 0 view .LVU119
 653 00ac 1092 0000 		sts matrix+6+1,__zero_reg__
 654 00b0 1092 0000 		sts matrix+6,__zero_reg__
 249:quantum/matrix.c ****         raw_matrix[i] = 0;
 655               		.loc 1 249 42 is_stmt 1 view .LVU120
 656               	.LVL26:
 249:quantum/matrix.c ****         raw_matrix[i] = 0;
 657               		.loc 1 249 25 view .LVU121
 658               	.LBE41:
 252:quantum/matrix.c ****     }
 253:quantum/matrix.c **** 
 254:quantum/matrix.c ****     debounce_init(MATRIX_ROWS);
 659               		.loc 1 254 5 view .LVU122
 660 00b4 84E0      		ldi r24,lo8(4)
 661 00b6 0E94 0000 		call debounce_init
 662               	.LVL27:
 255:quantum/matrix.c **** 
 256:quantum/matrix.c ****     matrix_init_quantum();
 663               		.loc 1 256 5 view .LVU123
 664               	/* epilogue start */
 257:quantum/matrix.c **** }
 665               		.loc 1 257 1 is_stmt 0 view .LVU124
 666 00ba DF91      		pop r29
 667 00bc CF91      		pop r28
 256:quantum/matrix.c **** }
 668               		.loc 1 256 5 view .LVU125
 669 00be 0C94 0000 		jmp matrix_init_quantum
 670               	.LVL28:
 671               		.cfi_endproc
 672               	.LFE37:
 674               		.section	.text.matrix_scan,"ax",@progbits
 675               	.global	matrix_scan
 677               	matrix_scan:
 678               	.LFB38:
 258:quantum/matrix.c **** 
 259:quantum/matrix.c **** uint8_t matrix_scan(void) {
 679               		.loc 1 259 27 is_stmt 1 view -0
 680               		.cfi_startproc
 681 0000 5F92      		push r5
 682               	.LCFI22:
 683               		.cfi_def_cfa_offset 3
 684               		.cfi_offset 5, -2
 685 0002 6F92      		push r6
 686               	.LCFI23:
 687               		.cfi_def_cfa_offset 4
 688               		.cfi_offset 6, -3
 689 0004 7F92      		push r7
 690               	.LCFI24:
 691               		.cfi_def_cfa_offset 5
 692               		.cfi_offset 7, -4
 693 0006 8F92      		push r8
 694               	.LCFI25:
 695               		.cfi_def_cfa_offset 6
 696               		.cfi_offset 8, -5
 697 0008 9F92      		push r9
 698               	.LCFI26:
 699               		.cfi_def_cfa_offset 7
 700               		.cfi_offset 9, -6
 701 000a AF92      		push r10
 702               	.LCFI27:
 703               		.cfi_def_cfa_offset 8
 704               		.cfi_offset 10, -7
 705 000c BF92      		push r11
 706               	.LCFI28:
 707               		.cfi_def_cfa_offset 9
 708               		.cfi_offset 11, -8
 709 000e CF92      		push r12
 710               	.LCFI29:
 711               		.cfi_def_cfa_offset 10
 712               		.cfi_offset 12, -9
 713 0010 DF92      		push r13
 714               	.LCFI30:
 715               		.cfi_def_cfa_offset 11
 716               		.cfi_offset 13, -10
 717 0012 EF92      		push r14
 718               	.LCFI31:
 719               		.cfi_def_cfa_offset 12
 720               		.cfi_offset 14, -11
 721 0014 FF92      		push r15
 722               	.LCFI32:
 723               		.cfi_def_cfa_offset 13
 724               		.cfi_offset 15, -12
 725 0016 0F93      		push r16
 726               	.LCFI33:
 727               		.cfi_def_cfa_offset 14
 728               		.cfi_offset 16, -13
 729 0018 1F93      		push r17
 730               	.LCFI34:
 731               		.cfi_def_cfa_offset 15
 732               		.cfi_offset 17, -14
 733 001a CF93      		push r28
 734               	.LCFI35:
 735               		.cfi_def_cfa_offset 16
 736               		.cfi_offset 28, -15
 737 001c DF93      		push r29
 738               	.LCFI36:
 739               		.cfi_def_cfa_offset 17
 740               		.cfi_offset 29, -16
 741               	/* prologue: function */
 742               	/* frame size = 0 */
 743               	/* stack size = 15 */
 744               	.L__stack_usage = 15
 260:quantum/matrix.c ****     bool changed = false;
 745               		.loc 1 260 5 view .LVU127
 746               	.LVL29:
 261:quantum/matrix.c **** 
 262:quantum/matrix.c **** #if defined(DIRECT_PINS) || (DIODE_DIRECTION == COL2ROW)
 263:quantum/matrix.c ****     // Set row, read cols
 264:quantum/matrix.c ****     for (uint8_t current_row = 0; current_row < MATRIX_ROWS; current_row++) {
 747               		.loc 1 264 5 view .LVU128
 748               	.LBB53:
 749               		.loc 1 264 10 view .LVU129
 750               		.loc 1 264 35 view .LVU130
 751 001e 20E0      		ldi r18,lo8(raw_matrix)
 752 0020 30E0      		ldi r19,hi8(raw_matrix)
 753 0022 00E0      		ldi r16,lo8(row_pins)
 754 0024 10E0      		ldi r17,hi8(row_pins)
 755               	.LBE53:
 260:quantum/matrix.c ****     bool changed = false;
 756               		.loc 1 260 10 is_stmt 0 view .LVU131
 757 0026 512C      		mov r5,__zero_reg__
 758               	.LBB75:
 759               	.LBB54:
 760               	.LBB55:
 761               	.LBB56:
 762               	.LBB57:
 142:quantum/matrix.c ****     writePinLow(row_pins[row]);
 763               		.loc 1 142 5 view .LVU132
 764 0028 EE24      		clr r14
 765 002a E394      		inc r14
 766 002c F12C      		mov r15,__zero_reg__
 767               	.LVL30:
 768               	.L28:
 142:quantum/matrix.c ****     writePinLow(row_pins[row]);
 769               		.loc 1 142 5 view .LVU133
 770               	.LBE57:
 771               	.LBE56:
 772               	.LBE55:
 773               	.LBE54:
 265:quantum/matrix.c ****         changed |= read_cols_on_row(raw_matrix, current_row);
 774               		.loc 1 265 9 is_stmt 1 view .LVU134
 775               	.LBB73:
 776               	.LBI54:
 161:quantum/matrix.c ****     // Store last value of row prior to reading
 777               		.loc 1 161 13 view .LVU135
 778               	.LBB71:
 163:quantum/matrix.c **** 
 779               		.loc 1 163 5 view .LVU136
 163:quantum/matrix.c **** 
 780               		.loc 1 163 18 is_stmt 0 view .LVU137
 781 002e E901      		movw r28,r18
 782 0030 8990      		ld r8,Y+
 783 0032 9990      		ld r9,Y+
 784 0034 9E01      		movw r18,r28
 785               	.LVL31:
 166:quantum/matrix.c **** 
 786               		.loc 1 166 5 is_stmt 1 view .LVU138
 787 0036 DE01      		movw r26,r28
 166:quantum/matrix.c **** 
 788               		.loc 1 166 33 is_stmt 0 view .LVU139
 789 0038 1E92      		st -X,__zero_reg__
 790 003a 1E92      		st -X,__zero_reg__
 169:quantum/matrix.c ****     wait_us(30);
 791               		.loc 1 169 5 is_stmt 1 view .LVU140
 792               	.LVL32:
 793               	.LBB59:
 794               	.LBI56:
 141:quantum/matrix.c ****     setPinOutput(row_pins[row]);
 795               		.loc 1 141 13 view .LVU141
 796               	.LBB58:
 142:quantum/matrix.c ****     writePinLow(row_pins[row]);
 797               		.loc 1 142 5 view .LVU142
 798 003c F801      		movw r30,r16
 799 003e 8191      		ld r24,Z+
 800 0040 8F01      		movw r16,r30
 801               	.LVL33:
 142:quantum/matrix.c ****     writePinLow(row_pins[row]);
 802               		.loc 1 142 5 is_stmt 0 view .LVU143
 803 0042 E82F      		mov r30,r24
 804 0044 E295      		swap r30
 805 0046 EF70      		andi r30,lo8(15)
 806 0048 F0E0      		ldi r31,0
 807 004a 91A1      		ldd r25,Z+33
 808 004c 8F70      		andi r24,lo8(15)
 809 004e B701      		movw r22,r14
 810 0050 00C0      		rjmp 2f
 811               		1:
 812 0052 660F      		lsl r22
 813               		2:
 814 0054 8A95      		dec r24
 815 0056 02F4      		brpl 1b
 816 0058 892F      		mov r24,r25
 817 005a 862B      		or r24,r22
 818 005c 81A3      		std Z+33,r24
 143:quantum/matrix.c **** }
 819               		.loc 1 143 5 is_stmt 1 view .LVU144
 820 005e 82A1      		ldd r24,Z+34
 821 0060 662E      		mov r6,r22
 822 0062 6094      		com r6
 823 0064 8621      		and r24,r6
 824 0066 82A3      		std Z+34,r24
 825               	.LVL34:
 143:quantum/matrix.c **** }
 826               		.loc 1 143 5 is_stmt 0 view .LVU145
 827               	.LBE58:
 828               	.LBE59:
 170:quantum/matrix.c **** 
 829               		.loc 1 170 5 is_stmt 1 view .LVU146
 830               	.LBB60:
 831               	.LBI60:
 832               		.file 2 "/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 189:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #else
 190:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	{
 196:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		{
 200:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		}
 204:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		return;
 205:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	}
 206:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	else
 207:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 210:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** }
 211:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 212:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /**
 213:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 215:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 217:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 220:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 222:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 226:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 231:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 236:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    respectively.
 240:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 241:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \note
 242:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 243:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 253:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****  */
 254:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** void
 255:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** _delay_us(double __us)
 833               		.loc 2 255 1 view .LVU147
 834               	.LBB61:
 256:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 257:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	double __tmp ;
 835               		.loc 2 257 2 view .LVU148
 258:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 836               		.loc 2 261 2 view .LVU149
 262:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 837               		.loc 2 262 2 view .LVU150
 263:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 838               		.loc 2 263 2 view .LVU151
 264:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 265:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 268:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 271:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#else
 272:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		//round up by default
 273:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 839               		.loc 2 273 3 view .LVU152
 274:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 275:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 276:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 840               		.loc 2 276 2 view .LVU153
 841 0068 80EA      		ldi r24,lo8(-96)
 842 006a 8A95      	1:	dec r24
 843 006c 01F4      		brne 1b
 844               	.LVL35:
 845               		.loc 2 276 2 is_stmt 0 view .LVU154
 846               	.LBE61:
 847               	.LBE60:
 173:quantum/matrix.c ****         // Select the col pin to read (active low)
 848               		.loc 1 173 5 is_stmt 1 view .LVU155
 849               	.LBB63:
 173:quantum/matrix.c ****         // Select the col pin to read (active low)
 850               		.loc 1 173 10 view .LVU156
 173:quantum/matrix.c ****         // Select the col pin to read (active low)
 851               		.loc 1 173 33 view .LVU157
 852 006e 80E0      		ldi r24,lo8(col_pins)
 853 0070 C82E      		mov r12,r24
 854 0072 80E0      		ldi r24,hi8(col_pins)
 855 0074 D82E      		mov r13,r24
 856               	.LBE63:
 857               	.LBB66:
 858               	.LBB62:
 859               		.loc 2 276 2 is_stmt 0 view .LVU158
 860 0076 50E0      		ldi r21,0
 861 0078 40E0      		ldi r20,0
 862               	.LVL36:
 863               	.L26:
 864               		.loc 2 276 2 view .LVU159
 865               	.LBE62:
 866               	.LBE66:
 867               	.LBB67:
 868               	.LBB64:
 175:quantum/matrix.c **** 
 869               		.loc 1 175 9 is_stmt 1 view .LVU160
 175:quantum/matrix.c **** 
 870               		.loc 1 175 29 is_stmt 0 view .LVU161
 871 007a E601      		movw r28,r12
 872 007c 7990      		ld r7,Y+
 873 007e 6E01      		movw r12,r28
 874 0080 872D      		mov r24,r7
 875 0082 8295      		swap r24
 876 0084 8F70      		andi r24,lo8(15)
 877 0086 90E0      		ldi r25,0
 878 0088 EC01      		movw r28,r24
 879 008a 88A1      		ldd r24,Y+32
 880               	.LVL37:
 178:quantum/matrix.c ****     }
 881               		.loc 1 178 9 is_stmt 1 view .LVU162
 178:quantum/matrix.c ****     }
 882               		.loc 1 178 37 is_stmt 0 view .LVU163
 883 008c AD90      		ld r10,X+
 884 008e BC90      		ld r11,X
 885 0090 1197      		sbiw r26,1
 175:quantum/matrix.c **** 
 886               		.loc 1 175 29 view .LVU164
 887 0092 90E0      		ldi r25,0
 888 0094 D72D      		mov r29,r7
 889 0096 DF70      		andi r29,lo8(15)
 890               	.LVL38:
 175:quantum/matrix.c **** 
 891               		.loc 1 175 29 view .LVU165
 892 0098 00C0      		rjmp 2f
 893               		1:
 894 009a 9595      		asr r25
 895 009c 8795      		ror r24
 896               		2:
 897 009e DA95      		dec r29
 898 00a0 02F4      		brpl 1b
 899               	.LVL39:
 178:quantum/matrix.c ****     }
 900               		.loc 1 178 54 view .LVU166
 901 00a2 80FD      		sbrc r24,0
 902 00a4 00C0      		rjmp .L29
 903 00a6 C701      		movw r24,r14
 904 00a8 042E      		mov r0,r20
 905 00aa 00C0      		rjmp 2f
 906               		1:
 907 00ac 880F      		lsl r24
 908 00ae 991F      		rol r25
 909               		2:
 910 00b0 0A94      		dec r0
 911 00b2 02F4      		brpl 1b
 912               	.L25:
 178:quantum/matrix.c ****     }
 913               		.loc 1 178 37 view .LVU167
 914 00b4 8A29      		or r24,r10
 915 00b6 9B29      		or r25,r11
 916 00b8 1196      		adiw r26,1
 917 00ba 9C93      		st X,r25
 918 00bc 8E93      		st -X,r24
 919               	.LBE64:
 173:quantum/matrix.c ****         // Select the col pin to read (active low)
 920               		.loc 1 173 58 is_stmt 1 view .LVU168
 921               	.LVL40:
 173:quantum/matrix.c ****         // Select the col pin to read (active low)
 922               		.loc 1 173 33 view .LVU169
 923 00be 4F5F      		subi r20,-1
 924 00c0 5F4F      		sbci r21,-1
 925               	.LVL41:
 173:quantum/matrix.c ****         // Select the col pin to read (active low)
 926               		.loc 1 173 5 is_stmt 0 view .LVU170
 927 00c2 4D30      		cpi r20,13
 928 00c4 5105      		cpc r21,__zero_reg__
 929 00c6 01F4      		brne .L26
 930               	.LBE67:
 182:quantum/matrix.c **** 
 931               		.loc 1 182 5 is_stmt 1 view .LVU171
 932               	.LVL42:
 933               	.LBB68:
 934               	.LBI68:
 146:quantum/matrix.c **** 
 935               		.loc 1 146 13 view .LVU172
 936               	.LBB69:
 146:quantum/matrix.c **** 
 937               		.loc 1 146 41 view .LVU173
 938 00c8 81A1      		ldd r24,Z+33
 939 00ca D62D      		mov r29,r6
 940 00cc D823      		and r29,r24
 941 00ce D1A3      		std Z+33,r29
 942 00d0 82A1      		ldd r24,Z+34
 943 00d2 682B      		or r22,r24
 944 00d4 62A3      		std Z+34,r22
 945               	.LVL43:
 146:quantum/matrix.c **** 
 946               		.loc 1 146 41 is_stmt 0 view .LVU174
 947               	.LBE69:
 948               	.LBE68:
 184:quantum/matrix.c **** }
 949               		.loc 1 184 5 is_stmt 1 view .LVU175
 184:quantum/matrix.c **** }
 950               		.loc 1 184 28 is_stmt 0 view .LVU176
 951 00d6 81E0      		ldi r24,lo8(1)
 952 00d8 4D91      		ld r20,X+
 953 00da 5C91      		ld r21,X
 954 00dc 4815      		cp r20,r8
 955 00de 5905      		cpc r21,r9
 956 00e0 01F4      		brne .L27
 957 00e2 80E0      		ldi r24,0
 958               	.L27:
 959               	.LBE71:
 960               	.LBE73:
 961               		.loc 1 265 17 view .LVU177
 962 00e4 582A      		or r5,r24
 963               	.LVL44:
 264:quantum/matrix.c ****         changed |= read_cols_on_row(raw_matrix, current_row);
 964               		.loc 1 264 62 is_stmt 1 view .LVU178
 264:quantum/matrix.c ****         changed |= read_cols_on_row(raw_matrix, current_row);
 965               		.loc 1 264 35 view .LVU179
 264:quantum/matrix.c ****         changed |= read_cols_on_row(raw_matrix, current_row);
 966               		.loc 1 264 5 is_stmt 0 view .LVU180
 967 00e6 E0E0      		ldi r30,hi8(raw_matrix+8)
 968 00e8 2030      		cpi r18,lo8(raw_matrix+8)
 969 00ea 3E07      		cpc r19,r30
 970 00ec 01F0      		breq .+2
 971 00ee 00C0      		rjmp .L28
 972               	.LBE75:
 266:quantum/matrix.c ****     }
 267:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
 268:quantum/matrix.c ****     // Set col, read rows
 269:quantum/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 270:quantum/matrix.c ****         changed |= read_rows_on_col(raw_matrix, current_col);
 271:quantum/matrix.c ****     }
 272:quantum/matrix.c **** #endif
 273:quantum/matrix.c **** 
 274:quantum/matrix.c ****     debounce(raw_matrix, matrix, MATRIX_ROWS, changed);
 973               		.loc 1 274 5 is_stmt 1 view .LVU181
 974 00f0 252D      		mov r18,r5
 975 00f2 44E0      		ldi r20,lo8(4)
 976 00f4 60E0      		ldi r22,lo8(matrix)
 977 00f6 70E0      		ldi r23,hi8(matrix)
 978 00f8 80E0      		ldi r24,lo8(raw_matrix)
 979 00fa 90E0      		ldi r25,hi8(raw_matrix)
 980 00fc 0E94 0000 		call debounce
 981               	.LVL45:
 275:quantum/matrix.c **** 
 276:quantum/matrix.c ****     matrix_scan_quantum();
 982               		.loc 1 276 5 view .LVU182
 983 0100 0E94 0000 		call matrix_scan_quantum
 984               	.LVL46:
 277:quantum/matrix.c ****     return (uint8_t)changed;
 985               		.loc 1 277 5 view .LVU183
 278:quantum/matrix.c **** }
 986               		.loc 1 278 1 is_stmt 0 view .LVU184
 987 0104 852D      		mov r24,r5
 988               	/* epilogue start */
 989 0106 DF91      		pop r29
 990 0108 CF91      		pop r28
 991 010a 1F91      		pop r17
 992 010c 0F91      		pop r16
 993               	.LVL47:
 994               		.loc 1 278 1 view .LVU185
 995 010e FF90      		pop r15
 996 0110 EF90      		pop r14
 997 0112 DF90      		pop r13
 998 0114 CF90      		pop r12
 999 0116 BF90      		pop r11
 1000 0118 AF90      		pop r10
 1001 011a 9F90      		pop r9
 1002 011c 8F90      		pop r8
 1003 011e 7F90      		pop r7
 1004 0120 6F90      		pop r6
 1005 0122 5F90      		pop r5
 1006               	.LVL48:
 1007               		.loc 1 278 1 view .LVU186
 1008 0124 0895      		ret
 1009               	.LVL49:
 1010               	.L29:
 1011               	.LBB76:
 1012               	.LBB74:
 1013               	.LBB72:
 1014               	.LBB70:
 1015               	.LBB65:
 178:quantum/matrix.c ****     }
 1016               		.loc 1 178 54 view .LVU187
 1017 0126 90E0      		ldi r25,0
 1018 0128 80E0      		ldi r24,0
 1019 012a 00C0      		rjmp .L25
 1020               	.LBE65:
 1021               	.LBE70:
 1022               	.LBE72:
 1023               	.LBE74:
 1024               	.LBE76:
 1025               		.cfi_endproc
 1026               	.LFE38:
 1028               		.section	.progmem.data.__c.3410,"a"
 1031               	__c.3410:
 1032 0000 0A00      		.string	"\n"
 1033               		.section	.progmem.data.__c.3408,"a"
 1036               	__c.3408:
 1037 0000 2530 3136 		.string	"%016b"
 1037      6200 
 1038               		.section	.progmem.data.__c.3406,"a"
 1041               	__c.3406:
 1042 0000 3A20 00   		.string	": "
 1043               		.section	.progmem.data.__c.3404,"a"
 1046               	__c.3404:
 1047 0000 2530 3258 		.string	"%02X"
 1047      00
 1048               		.section	.progmem.data.__c.3401,"a"
 1051               	__c.3401:
 1052 0000 0A72 2F63 		.string	"\nr/c 0123456789ABCDEF\n"
 1052      2030 3132 
 1052      3334 3536 
 1052      3738 3941 
 1052      4243 4445 
 1053               		.section	.bss.matrix,"aw",@nobits
 1056               	matrix:
 1057 0000 0000 0000 		.zero	8
 1057      0000 0000 
 1058               		.section	.bss.raw_matrix,"aw",@nobits
 1061               	raw_matrix:
 1062 0000 0000 0000 		.zero	8
 1062      0000 0000 
 1063               		.section	.rodata.col_pins,"a"
 1066               	col_pins:
 1067 0000 67        		.byte	103
 1068 0001 66        		.byte	102
 1069 0002 64        		.byte	100
 1070 0003 65        		.byte	101
 1071 0004 36        		.byte	54
 1072 0005 35        		.byte	53
 1073 0006 34        		.byte	52
 1074 0007 32        		.byte	50
 1075 0008 31        		.byte	49
 1076 0009 30        		.byte	48
 1077 000a 96        		.byte	-106
 1078 000b 95        		.byte	-107
 1079 000c 94        		.byte	-108
 1080               		.section	.rodata.row_pins,"a"
 1083               	row_pins:
 1084 0000 90        		.byte	-112
 1085 0001 91        		.byte	-111
 1086 0002 92        		.byte	-110
 1087 0003 33        		.byte	51
 1088               		.text
 1089               	.Letext0:
 1090               		.file 3 "/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/stdint.h"
 1091               		.file 4 "/usr/local/Cellar/avr-gcc@8/8.4.0/lib/avr-gcc/8/gcc/avr/8.4.0/include/stddef.h"
 1092               		.file 5 "tmk_core/common/debug.h"
 1093               		.file 6 "tmk_core/common/avr/xprintf.h"
 1094               		.file 7 "tmk_core/common/matrix.h"
 1095               		.file 8 "tmk_core/common/action.h"
 1096               		.file 9 "tmk_core/common/report.h"
 1097               		.file 10 "tmk_core/common/host.h"
 1098               		.file 11 "quantum/keycode_config.h"
 1099               		.file 12 "quantum/keymap.h"
 1100               		.file 13 "tmk_core/common/action_layer.h"
 1101               		.file 14 "tmk_core/common/timer.h"
 1102               		.file 15 "tmk_core/common/action_util.h"
 1103               		.file 16 "/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/stdlib.h"
 1104               		.file 17 "quantum/quantum.h"
 1105               		.file 18 "quantum/debounce.h"
 1106               		.file 19 "tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:4      *ABS*:000000000000003f __SREG__
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:13     .text.matrix_init_user:0000000000000000 matrix_init_user
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:13     .text.matrix_init_user:0000000000000000 matrix_init_user.localalias.0
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:33     .text.matrix_init_kb:0000000000000000 matrix_init_kb
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:50     .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:67     .text.matrix_scan_user:0000000000000000 matrix_scan_user
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:82     .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:99     .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:116    .text.matrix_rows:0000000000000000 matrix_rows
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:135    .text.matrix_cols:0000000000000000 matrix_cols
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:154    .text.matrix_is_modified:0000000000000000 matrix_is_modified
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:177    .text.matrix_is_on:0000000000000000 matrix_is_on
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:1056   .bss.matrix:0000000000000000 matrix
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:225    .text.matrix_get_row:0000000000000000 matrix_get_row
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:255    .text.matrix_print:0000000000000000 matrix_print
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:1051   .progmem.data.__c.3401:0000000000000000 __c.3401
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:1046   .progmem.data.__c.3404:0000000000000000 __c.3404
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:1036   .progmem.data.__c.3408:0000000000000000 __c.3408
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:1041   .progmem.data.__c.3406:0000000000000000 __c.3406
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:1031   .progmem.data.__c.3410:0000000000000000 __c.3410
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:425    .text.matrix_key_count:0000000000000000 matrix_key_count
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:494    .text.matrix_init:0000000000000000 matrix_init
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:1083   .rodata.row_pins:0000000000000000 row_pins
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:1066   .rodata.col_pins:0000000000000000 col_pins
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:1061   .bss.raw_matrix:0000000000000000 raw_matrix
/var/folders/hg/m293bnw975q820z9tg0f9gdw0000gn/T//cc1mGCPt.s:677    .text.matrix_scan:0000000000000000 matrix_scan

UNDEFINED SYMBOLS
debounce_active
xputs
__xprintf
bitrev16
bitpop16
debounce_init
debounce
__do_copy_data
__do_clear_bss
