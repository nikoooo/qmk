   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB13:
  15               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "action_layer.h"
  24:tmk_core/common/action.c **** #include "action_tapping.h"
  25:tmk_core/common/action.c **** #include "action_macro.h"
  26:tmk_core/common/action.c **** #include "action_util.h"
  27:tmk_core/common/action.c **** #include "action.h"
  28:tmk_core/common/action.c **** #include "wait.h"
  29:tmk_core/common/action.c **** 
  30:tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
  31:tmk_core/common/action.c **** #    include "backlight.h"
  32:tmk_core/common/action.c **** #endif
  33:tmk_core/common/action.c **** 
  34:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  35:tmk_core/common/action.c **** #    include "debug.h"
  36:tmk_core/common/action.c **** #else
  37:tmk_core/common/action.c **** #    include "nodebug.h"
  38:tmk_core/common/action.c **** #endif
  39:tmk_core/common/action.c **** 
  40:tmk_core/common/action.c **** int tp_buttons;
  41:tmk_core/common/action.c **** 
  42:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  43:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  44:tmk_core/common/action.c **** #endif
  45:tmk_core/common/action.c **** 
  46:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  47:tmk_core/common/action.c **** #    include <fauxclicky.h>
  48:tmk_core/common/action.c **** #endif
  49:tmk_core/common/action.c **** 
  50:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  51:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  54:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  55:tmk_core/common/action.c **** #endif
  56:tmk_core/common/action.c **** /** \brief Called to execute an action.
  57:tmk_core/common/action.c ****  *
  58:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  59:tmk_core/common/action.c ****  */
  60:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  16               		.loc 1 60 0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  61:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  62:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  63:tmk_core/common/action.c ****         dprint("EVENT: ");
  64:tmk_core/common/action.c ****         debug_event(event);
  65:tmk_core/common/action.c ****         dprintln();
  66:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  67:tmk_core/common/action.c ****         retro_tapping_counter++;
  68:tmk_core/common/action.c **** #endif
  69:tmk_core/common/action.c ****     }
  70:tmk_core/common/action.c **** 
  71:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  72:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  73:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  74:tmk_core/common/action.c ****     }
  75:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  76:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  77:tmk_core/common/action.c ****     }
  78:tmk_core/common/action.c ****     fauxclicky_check();
  79:tmk_core/common/action.c **** #endif
  80:tmk_core/common/action.c **** 
  81:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  82:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  83:tmk_core/common/action.c ****         process_hand_swap(&event);
  84:tmk_core/common/action.c ****     }
  85:tmk_core/common/action.c **** #endif
  86:tmk_core/common/action.c **** 
  87:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  48               		.loc 1 87 0
  49 001e DE01      		movw r26,r28
  50 0020 1196      		adiw r26,1
  51 0022 86E0      		ldi r24,lo8(6)
  52 0024 FD01      		movw r30,r26
  53               		0:
  54 0026 1192      		st Z+,__zero_reg__
  55 0028 8A95      		dec r24
  56 002a 01F4      		brne 0b
  57 002c 85E0      		ldi r24,lo8(5)
  58 002e FE01      		movw r30,r28
  59 0030 3796      		adiw r30,7
  60               		0:
  61 0032 0190      		ld r0,Z+
  62 0034 0D92      		st X+,r0
  63 0036 8A95      		dec r24
  64 0038 01F4      		brne 0b
  88:tmk_core/common/action.c **** 
  89:tmk_core/common/action.c **** #if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  90:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  91:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  92:tmk_core/common/action.c ****     }
  93:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  94:tmk_core/common/action.c ****         clear_oneshot_mods();
  95:tmk_core/common/action.c ****     }
  96:tmk_core/common/action.c **** #endif
  97:tmk_core/common/action.c **** 
  98:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
  99:tmk_core/common/action.c ****     action_tapping_process(record);
  65               		.loc 1 99 0
  66 003a 4981      		ldd r20,Y+1
  67               	.LVL1:
  68 003c 5A81      		ldd r21,Y+2
  69               	.LVL2:
  70 003e 6B81      		ldd r22,Y+3
  71 0040 7C81      		ldd r23,Y+4
  72 0042 8D81      		ldd r24,Y+5
  73 0044 9E81      		ldd r25,Y+6
  74 0046 0E94 0000 		call action_tapping_process
  75               	.LVL3:
  76               	/* epilogue start */
 100:tmk_core/common/action.c **** #else
 101:tmk_core/common/action.c ****     process_record(&record);
 102:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 103:tmk_core/common/action.c ****         dprint("processed: ");
 104:tmk_core/common/action.c ****         debug_record(record);
 105:tmk_core/common/action.c ****         dprintln();
 106:tmk_core/common/action.c ****     }
 107:tmk_core/common/action.c **** #endif
 108:tmk_core/common/action.c **** }
  77               		.loc 1 108 0
  78 004a 2B96      		adiw r28,11
  79 004c 0FB6      		in __tmp_reg__,__SREG__
  80 004e F894      		cli
  81 0050 DEBF      		out __SP_H__,r29
  82 0052 0FBE      		out __SREG__,__tmp_reg__
  83 0054 CDBF      		out __SP_L__,r28
  84 0056 DF91      		pop r29
  85 0058 CF91      		pop r28
  86 005a 0895      		ret
  87               		.cfi_endproc
  88               	.LFE13:
  90               		.section	.text.process_record_quantum,"ax",@progbits
  91               		.weak	process_record_quantum
  93               	process_record_quantum:
  94               	.LFB15:
 109:tmk_core/common/action.c **** 
 110:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 111:tmk_core/common/action.c **** bool swap_hands = false;
 112:tmk_core/common/action.c **** bool swap_held  = false;
 113:tmk_core/common/action.c **** 
 114:tmk_core/common/action.c **** /** \brief Process Hand Swap
 115:tmk_core/common/action.c ****  *
 116:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 117:tmk_core/common/action.c ****  */
 118:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 119:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 120:tmk_core/common/action.c **** 
 121:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
 122:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 123:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 124:tmk_core/common/action.c **** 
 125:tmk_core/common/action.c ****     if (do_swap) {
 126:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 127:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 128:tmk_core/common/action.c ****     } else {
 129:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 130:tmk_core/common/action.c ****     }
 131:tmk_core/common/action.c **** }
 132:tmk_core/common/action.c **** #endif
 133:tmk_core/common/action.c **** 
 134:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 135:tmk_core/common/action.c **** bool disable_action_cache = false;
 136:tmk_core/common/action.c **** 
 137:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 138:tmk_core/common/action.c ****     disable_action_cache = true;
 139:tmk_core/common/action.c ****     process_record(record);
 140:tmk_core/common/action.c ****     disable_action_cache = false;
 141:tmk_core/common/action.c **** }
 142:tmk_core/common/action.c **** #else
 143:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 144:tmk_core/common/action.c **** #endif
 145:tmk_core/common/action.c **** 
 146:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
  95               		.loc 1 146 0
  96               		.cfi_startproc
  97               	.LVL4:
  98               	/* prologue: function */
  99               	/* frame size = 0 */
 100               	/* stack size = 0 */
 101               	.L__stack_usage = 0
 102               		.loc 1 146 0
 103 0000 81E0      		ldi r24,lo8(1)
 104               	.LVL5:
 105 0002 0895      		ret
 106               		.cfi_endproc
 107               	.LFE15:
 109               		.section	.text.process_record_tap_hint,"ax",@progbits
 110               	.global	process_record_tap_hint
 112               	process_record_tap_hint:
 113               	.LFB16:
 147:tmk_core/common/action.c **** 
 148:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 149:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 150:tmk_core/common/action.c ****  *
 151:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 152:tmk_core/common/action.c ****  */
 153:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 114               		.loc 1 153 0
 115               		.cfi_startproc
 116               	.LVL6:
 117               	/* prologue: function */
 118               	/* frame size = 0 */
 119               	/* stack size = 0 */
 120               	.L__stack_usage = 0
 154:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 121               		.loc 1 154 0
 122 0000 FC01      		movw r30,r24
 123 0002 8081      		ld r24,Z
 124 0004 9181      		ldd r25,Z+1
 125               	.LVL7:
 126 0006 0E94 0000 		call layer_switch_get_action
 127               	.LVL8:
 128 000a 0895      		ret
 129               		.cfi_endproc
 130               	.LFE16:
 132               		.section	.text.register_code,"ax",@progbits
 133               	.global	register_code
 135               	register_code:
 136               	.LFB19:
 155:tmk_core/common/action.c **** 
 156:tmk_core/common/action.c ****     switch (action.kind.id) {
 157:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 158:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 159:tmk_core/common/action.c ****             switch (action.swap.code) {
 160:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 161:tmk_core/common/action.c ****                 default:
 162:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 163:tmk_core/common/action.c ****                     swap_held  = true;
 164:tmk_core/common/action.c ****             }
 165:tmk_core/common/action.c ****             break;
 166:tmk_core/common/action.c **** #    endif
 167:tmk_core/common/action.c ****     }
 168:tmk_core/common/action.c **** }
 169:tmk_core/common/action.c **** #endif
 170:tmk_core/common/action.c **** 
 171:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 172:tmk_core/common/action.c ****  *
 173:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 174:tmk_core/common/action.c ****  */
 175:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 176:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 177:tmk_core/common/action.c ****         return;
 178:tmk_core/common/action.c ****     }
 179:tmk_core/common/action.c **** 
 180:tmk_core/common/action.c ****     if (!process_record_quantum(record)) return;
 181:tmk_core/common/action.c **** 
 182:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 183:tmk_core/common/action.c ****     dprint("ACTION: ");
 184:tmk_core/common/action.c ****     debug_action(action);
 185:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 186:tmk_core/common/action.c ****     dprint(" layer_state: ");
 187:tmk_core/common/action.c ****     layer_debug();
 188:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 189:tmk_core/common/action.c ****     default_layer_debug();
 190:tmk_core/common/action.c **** #endif
 191:tmk_core/common/action.c ****     dprintln();
 192:tmk_core/common/action.c **** 
 193:tmk_core/common/action.c ****     process_action(record, action);
 194:tmk_core/common/action.c **** }
 195:tmk_core/common/action.c **** 
 196:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 197:tmk_core/common/action.c ****  *
 198:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 199:tmk_core/common/action.c ****  */
 200:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 201:tmk_core/common/action.c ****     keyevent_t event = record->event;
 202:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 203:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 204:tmk_core/common/action.c **** #endif
 205:tmk_core/common/action.c **** 
 206:tmk_core/common/action.c ****     if (event.pressed) {
 207:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 208:tmk_core/common/action.c ****         clear_weak_mods();
 209:tmk_core/common/action.c ****     }
 210:tmk_core/common/action.c **** 
 211:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 212:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 213:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 214:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 215:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 216:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 217:tmk_core/common/action.c ****     }
 218:tmk_core/common/action.c **** #endif
 219:tmk_core/common/action.c **** 
 220:tmk_core/common/action.c ****     switch (action.kind.id) {
 221:tmk_core/common/action.c ****         /* Key and Mods */
 222:tmk_core/common/action.c ****         case ACT_LMODS:
 223:tmk_core/common/action.c ****         case ACT_RMODS: {
 224:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 225:tmk_core/common/action.c ****             if (event.pressed) {
 226:tmk_core/common/action.c ****                 if (mods) {
 227:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 228:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 229:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 230:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 231:tmk_core/common/action.c ****                         add_mods(mods);
 232:tmk_core/common/action.c ****                     } else {
 233:tmk_core/common/action.c ****                         add_weak_mods(mods);
 234:tmk_core/common/action.c ****                     }
 235:tmk_core/common/action.c ****                     send_keyboard_report();
 236:tmk_core/common/action.c ****                 }
 237:tmk_core/common/action.c ****                 register_code(action.key.code);
 238:tmk_core/common/action.c ****             } else {
 239:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 240:tmk_core/common/action.c ****                 if (mods) {
 241:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 242:tmk_core/common/action.c ****                         del_mods(mods);
 243:tmk_core/common/action.c ****                     } else {
 244:tmk_core/common/action.c ****                         del_weak_mods(mods);
 245:tmk_core/common/action.c ****                     }
 246:tmk_core/common/action.c ****                     send_keyboard_report();
 247:tmk_core/common/action.c ****                 }
 248:tmk_core/common/action.c ****             }
 249:tmk_core/common/action.c ****         } break;
 250:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 251:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 252:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 253:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 254:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 255:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 256:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 257:tmk_core/common/action.c ****                     // Oneshot modifier
 258:tmk_core/common/action.c ****                     if (event.pressed) {
 259:tmk_core/common/action.c ****                         if (tap_count == 0) {
 260:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 261:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 262:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 263:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 264:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 265:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 266:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 267:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 268:tmk_core/common/action.c ****                             clear_oneshot_mods();
 269:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 270:tmk_core/common/action.c ****                             register_mods(mods);
 271:tmk_core/common/action.c **** #        endif
 272:tmk_core/common/action.c ****                         } else {
 273:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 274:tmk_core/common/action.c ****                         }
 275:tmk_core/common/action.c ****                     } else {
 276:tmk_core/common/action.c ****                         if (tap_count == 0) {
 277:tmk_core/common/action.c ****                             clear_oneshot_mods();
 278:tmk_core/common/action.c ****                             unregister_mods(mods);
 279:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 280:tmk_core/common/action.c ****                             // Retain Oneshot mods
 281:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 282:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 283:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 284:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 285:tmk_core/common/action.c ****                                 unregister_mods(mods);
 286:tmk_core/common/action.c ****                             }
 287:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 288:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 289:tmk_core/common/action.c **** #        endif
 290:tmk_core/common/action.c ****                         } else {
 291:tmk_core/common/action.c ****                             clear_oneshot_mods();
 292:tmk_core/common/action.c ****                             unregister_mods(mods);
 293:tmk_core/common/action.c ****                         }
 294:tmk_core/common/action.c ****                     }
 295:tmk_core/common/action.c ****                     break;
 296:tmk_core/common/action.c **** #    endif
 297:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 298:tmk_core/common/action.c ****                     if (event.pressed) {
 299:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 300:tmk_core/common/action.c ****                             register_mods(mods);
 301:tmk_core/common/action.c ****                         }
 302:tmk_core/common/action.c ****                     } else {
 303:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 304:tmk_core/common/action.c ****                             unregister_mods(mods);
 305:tmk_core/common/action.c ****                         }
 306:tmk_core/common/action.c ****                     }
 307:tmk_core/common/action.c ****                     break;
 308:tmk_core/common/action.c ****                 default:
 309:tmk_core/common/action.c ****                     if (event.pressed) {
 310:tmk_core/common/action.c ****                         if (tap_count > 0) {
 311:tmk_core/common/action.c **** #    ifndef IGNORE_MOD_TAP_INTERRUPT
 312:tmk_core/common/action.c ****                             if (record->tap.interrupted) {
 313:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 314:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 315:tmk_core/common/action.c ****                                 record->tap.count = 0;
 316:tmk_core/common/action.c ****                                 register_mods(mods);
 317:tmk_core/common/action.c ****                             } else
 318:tmk_core/common/action.c **** #    endif
 319:tmk_core/common/action.c ****                             {
 320:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 321:tmk_core/common/action.c ****                                 register_code(action.key.code);
 322:tmk_core/common/action.c ****                             }
 323:tmk_core/common/action.c ****                         } else {
 324:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 325:tmk_core/common/action.c ****                             register_mods(mods);
 326:tmk_core/common/action.c ****                         }
 327:tmk_core/common/action.c ****                     } else {
 328:tmk_core/common/action.c ****                         if (tap_count > 0) {
 329:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 330:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 331:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 332:tmk_core/common/action.c ****                             }
 333:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 334:tmk_core/common/action.c ****                         } else {
 335:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 336:tmk_core/common/action.c ****                             unregister_mods(mods);
 337:tmk_core/common/action.c ****                         }
 338:tmk_core/common/action.c ****                     }
 339:tmk_core/common/action.c ****                     break;
 340:tmk_core/common/action.c ****             }
 341:tmk_core/common/action.c ****         } break;
 342:tmk_core/common/action.c **** #endif
 343:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 344:tmk_core/common/action.c ****         /* other HID usage */
 345:tmk_core/common/action.c ****         case ACT_USAGE:
 346:tmk_core/common/action.c ****             switch (action.usage.page) {
 347:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 348:tmk_core/common/action.c ****                     if (event.pressed) {
 349:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 350:tmk_core/common/action.c ****                     } else {
 351:tmk_core/common/action.c ****                         host_system_send(0);
 352:tmk_core/common/action.c ****                     }
 353:tmk_core/common/action.c ****                     break;
 354:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 355:tmk_core/common/action.c ****                     if (event.pressed) {
 356:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 357:tmk_core/common/action.c ****                     } else {
 358:tmk_core/common/action.c ****                         host_consumer_send(0);
 359:tmk_core/common/action.c ****                     }
 360:tmk_core/common/action.c ****                     break;
 361:tmk_core/common/action.c ****             }
 362:tmk_core/common/action.c ****             break;
 363:tmk_core/common/action.c **** #endif
 364:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 365:tmk_core/common/action.c ****         /* Mouse key */
 366:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 367:tmk_core/common/action.c ****             if (event.pressed) {
 368:tmk_core/common/action.c ****                 switch (action.key.code) {
 369:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 370:tmk_core/common/action.c ****                         tp_buttons |= (1 << 0);
 371:tmk_core/common/action.c ****                         break;
 372:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 373:tmk_core/common/action.c ****                         tp_buttons |= (1 << 1);
 374:tmk_core/common/action.c ****                         break;
 375:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 376:tmk_core/common/action.c ****                         tp_buttons |= (1 << 2);
 377:tmk_core/common/action.c ****                         break;
 378:tmk_core/common/action.c ****                     default:
 379:tmk_core/common/action.c ****                         break;
 380:tmk_core/common/action.c ****                 }
 381:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 382:tmk_core/common/action.c ****                 mousekey_send();
 383:tmk_core/common/action.c ****             } else {
 384:tmk_core/common/action.c ****                 switch (action.key.code) {
 385:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 386:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 0);
 387:tmk_core/common/action.c ****                         break;
 388:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 389:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 1);
 390:tmk_core/common/action.c ****                         break;
 391:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 392:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 2);
 393:tmk_core/common/action.c ****                         break;
 394:tmk_core/common/action.c ****                     default:
 395:tmk_core/common/action.c ****                         break;
 396:tmk_core/common/action.c ****                 }
 397:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 398:tmk_core/common/action.c ****                 mousekey_send();
 399:tmk_core/common/action.c ****             }
 400:tmk_core/common/action.c ****             break;
 401:tmk_core/common/action.c **** #endif
 402:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 403:tmk_core/common/action.c ****         case ACT_LAYER:
 404:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 405:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 406:tmk_core/common/action.c ****                 if (!event.pressed) {
 407:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 408:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 409:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 410:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 411:tmk_core/common/action.c ****                         case OP_BIT_AND:
 412:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 413:tmk_core/common/action.c ****                             break;
 414:tmk_core/common/action.c ****                         case OP_BIT_OR:
 415:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 416:tmk_core/common/action.c ****                             break;
 417:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 418:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 419:tmk_core/common/action.c ****                             break;
 420:tmk_core/common/action.c ****                         case OP_BIT_SET:
 421:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 422:tmk_core/common/action.c ****                             break;
 423:tmk_core/common/action.c ****                     }
 424:tmk_core/common/action.c ****                 }
 425:tmk_core/common/action.c ****             } else {
 426:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 427:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 428:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 429:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 430:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 431:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 432:tmk_core/common/action.c ****                         case OP_BIT_AND:
 433:tmk_core/common/action.c ****                             layer_and(bits | mask);
 434:tmk_core/common/action.c ****                             break;
 435:tmk_core/common/action.c ****                         case OP_BIT_OR:
 436:tmk_core/common/action.c ****                             layer_or(bits | mask);
 437:tmk_core/common/action.c ****                             break;
 438:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 439:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 440:tmk_core/common/action.c ****                             break;
 441:tmk_core/common/action.c ****                         case OP_BIT_SET:
 442:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 443:tmk_core/common/action.c ****                             break;
 444:tmk_core/common/action.c ****                     }
 445:tmk_core/common/action.c ****                 }
 446:tmk_core/common/action.c ****             }
 447:tmk_core/common/action.c ****             break;
 448:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 449:tmk_core/common/action.c ****             if (event.pressed) {
 450:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 451:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 452:tmk_core/common/action.c ****             } else {
 453:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 454:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 455:tmk_core/common/action.c ****             }
 456:tmk_core/common/action.c ****             break;
 457:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 458:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 459:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 460:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 461:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 462:tmk_core/common/action.c ****                     /* tap toggle */
 463:tmk_core/common/action.c ****                     if (event.pressed) {
 464:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 465:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 466:tmk_core/common/action.c ****                         }
 467:tmk_core/common/action.c ****                     } else {
 468:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 469:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 470:tmk_core/common/action.c ****                         }
 471:tmk_core/common/action.c ****                     }
 472:tmk_core/common/action.c ****                     break;
 473:tmk_core/common/action.c ****                 case OP_ON_OFF:
 474:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 475:tmk_core/common/action.c ****                     break;
 476:tmk_core/common/action.c ****                 case OP_OFF_ON:
 477:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 478:tmk_core/common/action.c ****                     break;
 479:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 480:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 481:tmk_core/common/action.c ****                     break;
 482:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 483:tmk_core/common/action.c ****                 case OP_ONESHOT:
 484:tmk_core/common/action.c ****                     // Oneshot modifier
 485:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 486:tmk_core/common/action.c ****                     do_release_oneshot = false;
 487:tmk_core/common/action.c ****                     if (event.pressed) {
 488:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 489:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 490:tmk_core/common/action.c ****                             reset_oneshot_layer();
 491:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 492:tmk_core/common/action.c ****                             break;
 493:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 494:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 495:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 496:tmk_core/common/action.c ****                         }
 497:tmk_core/common/action.c ****                     } else {
 498:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 499:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 500:tmk_core/common/action.c ****                             reset_oneshot_layer();
 501:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 502:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 503:tmk_core/common/action.c ****                         } else {
 504:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 505:tmk_core/common/action.c ****                         }
 506:tmk_core/common/action.c ****                     }
 507:tmk_core/common/action.c **** #            else
 508:tmk_core/common/action.c ****                     if (event.pressed) {
 509:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 510:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 511:tmk_core/common/action.c ****                     } else {
 512:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 513:tmk_core/common/action.c ****                         if (tap_count > 1) {
 514:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 515:tmk_core/common/action.c ****                         }
 516:tmk_core/common/action.c ****                     }
 517:tmk_core/common/action.c **** #            endif
 518:tmk_core/common/action.c ****                     break;
 519:tmk_core/common/action.c **** #        endif
 520:tmk_core/common/action.c ****                 default:
 521:tmk_core/common/action.c ****                     /* tap key */
 522:tmk_core/common/action.c ****                     if (event.pressed) {
 523:tmk_core/common/action.c ****                         if (tap_count > 0) {
 524:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 525:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 526:tmk_core/common/action.c ****                         } else {
 527:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 528:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 529:tmk_core/common/action.c ****                         }
 530:tmk_core/common/action.c ****                     } else {
 531:tmk_core/common/action.c ****                         if (tap_count > 0) {
 532:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 533:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 534:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 535:tmk_core/common/action.c ****                             } else {
 536:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 537:tmk_core/common/action.c ****                             }
 538:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 539:tmk_core/common/action.c ****                         } else {
 540:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 541:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 542:tmk_core/common/action.c ****                         }
 543:tmk_core/common/action.c ****                     }
 544:tmk_core/common/action.c ****                     break;
 545:tmk_core/common/action.c ****             }
 546:tmk_core/common/action.c ****             break;
 547:tmk_core/common/action.c **** #    endif
 548:tmk_core/common/action.c **** #endif
 549:tmk_core/common/action.c ****             /* Extentions */
 550:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 551:tmk_core/common/action.c ****         case ACT_MACRO:
 552:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 553:tmk_core/common/action.c ****             break;
 554:tmk_core/common/action.c **** #endif
 555:tmk_core/common/action.c **** #if defined(BACKLIGHT_ENABLE) | defined(LED_MATRIX_ENABLE)
 556:tmk_core/common/action.c ****         case ACT_BACKLIGHT:
 557:tmk_core/common/action.c ****             if (!event.pressed) {
 558:tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 559:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 560:tmk_core/common/action.c ****                         backlight_increase();
 561:tmk_core/common/action.c ****                         break;
 562:tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 563:tmk_core/common/action.c ****                         backlight_decrease();
 564:tmk_core/common/action.c ****                         break;
 565:tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 566:tmk_core/common/action.c ****                         backlight_toggle();
 567:tmk_core/common/action.c ****                         break;
 568:tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 569:tmk_core/common/action.c ****                         backlight_step();
 570:tmk_core/common/action.c ****                         break;
 571:tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 572:tmk_core/common/action.c ****                         backlight_level(BACKLIGHT_LEVELS);
 573:tmk_core/common/action.c ****                         break;
 574:tmk_core/common/action.c ****                     case BACKLIGHT_OFF:
 575:tmk_core/common/action.c ****                         backlight_level(0);
 576:tmk_core/common/action.c ****                         break;
 577:tmk_core/common/action.c ****                 }
 578:tmk_core/common/action.c ****             }
 579:tmk_core/common/action.c ****             break;
 580:tmk_core/common/action.c **** #endif
 581:tmk_core/common/action.c ****         case ACT_COMMAND:
 582:tmk_core/common/action.c ****             break;
 583:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 584:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 585:tmk_core/common/action.c ****             switch (action.swap.code) {
 586:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 587:tmk_core/common/action.c ****                     if (event.pressed) {
 588:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 589:tmk_core/common/action.c ****                     }
 590:tmk_core/common/action.c ****                     break;
 591:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 592:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 593:tmk_core/common/action.c ****                     break;
 594:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 595:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 596:tmk_core/common/action.c ****                     break;
 597:tmk_core/common/action.c ****                 case OP_SH_ON:
 598:tmk_core/common/action.c ****                     if (!event.pressed) {
 599:tmk_core/common/action.c ****                         swap_hands = true;
 600:tmk_core/common/action.c ****                     }
 601:tmk_core/common/action.c ****                     break;
 602:tmk_core/common/action.c ****                 case OP_SH_OFF:
 603:tmk_core/common/action.c ****                     if (!event.pressed) {
 604:tmk_core/common/action.c ****                         swap_hands = false;
 605:tmk_core/common/action.c ****                     }
 606:tmk_core/common/action.c ****                     break;
 607:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 608:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 609:tmk_core/common/action.c ****                     /* tap toggle */
 610:tmk_core/common/action.c **** 
 611:tmk_core/common/action.c ****                     if (event.pressed) {
 612:tmk_core/common/action.c ****                         if (swap_held) {
 613:tmk_core/common/action.c ****                             swap_held = false;
 614:tmk_core/common/action.c ****                         } else {
 615:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 616:tmk_core/common/action.c ****                         }
 617:tmk_core/common/action.c ****                     } else {
 618:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 619:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 620:tmk_core/common/action.c ****                         }
 621:tmk_core/common/action.c ****                     }
 622:tmk_core/common/action.c ****                     break;
 623:tmk_core/common/action.c ****                 default:
 624:tmk_core/common/action.c ****                     /* tap key */
 625:tmk_core/common/action.c ****                     if (tap_count > 0) {
 626:tmk_core/common/action.c ****                         if (swap_held) {
 627:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 628:tmk_core/common/action.c ****                             swap_held  = false;
 629:tmk_core/common/action.c ****                         }
 630:tmk_core/common/action.c ****                         if (event.pressed) {
 631:tmk_core/common/action.c ****                             register_code(action.swap.code);
 632:tmk_core/common/action.c ****                         } else {
 633:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 634:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 635:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 636:tmk_core/common/action.c ****                         }
 637:tmk_core/common/action.c ****                     } else {
 638:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 639:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 640:tmk_core/common/action.c ****                             swap_held  = false;
 641:tmk_core/common/action.c ****                         }
 642:tmk_core/common/action.c ****                     }
 643:tmk_core/common/action.c **** #    endif
 644:tmk_core/common/action.c ****             }
 645:tmk_core/common/action.c **** #endif
 646:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 647:tmk_core/common/action.c ****         case ACT_FUNCTION:
 648:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 649:tmk_core/common/action.c ****             break;
 650:tmk_core/common/action.c **** #endif
 651:tmk_core/common/action.c ****         default:
 652:tmk_core/common/action.c ****             break;
 653:tmk_core/common/action.c ****     }
 654:tmk_core/common/action.c **** 
 655:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 656:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 657:tmk_core/common/action.c ****     switch (action.kind.id) {
 658:tmk_core/common/action.c ****         case ACT_LAYER:
 659:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 660:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 661:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 662:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 663:tmk_core/common/action.c **** #    endif
 664:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 665:tmk_core/common/action.c ****             break;
 666:tmk_core/common/action.c ****         default:
 667:tmk_core/common/action.c ****             break;
 668:tmk_core/common/action.c ****     }
 669:tmk_core/common/action.c **** #endif
 670:tmk_core/common/action.c **** 
 671:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 672:tmk_core/common/action.c **** #    ifdef RETRO_TAPPING
 673:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 674:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 675:tmk_core/common/action.c ****     } else {
 676:tmk_core/common/action.c ****         if (event.pressed) {
 677:tmk_core/common/action.c ****             if (tap_count > 0) {
 678:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 679:tmk_core/common/action.c ****             } else {
 680:tmk_core/common/action.c ****             }
 681:tmk_core/common/action.c ****         } else {
 682:tmk_core/common/action.c ****             if (tap_count > 0) {
 683:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 684:tmk_core/common/action.c ****             } else {
 685:tmk_core/common/action.c ****                 if (retro_tapping_counter == 2) {
 686:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 687:tmk_core/common/action.c ****                 }
 688:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 689:tmk_core/common/action.c ****             }
 690:tmk_core/common/action.c ****         }
 691:tmk_core/common/action.c ****     }
 692:tmk_core/common/action.c **** #    endif
 693:tmk_core/common/action.c **** #endif
 694:tmk_core/common/action.c **** 
 695:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 696:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 697:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 698:tmk_core/common/action.c ****      */
 699:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 700:tmk_core/common/action.c ****         record->event.pressed = false;
 701:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 702:tmk_core/common/action.c ****         process_record(record);
 703:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 704:tmk_core/common/action.c ****     }
 705:tmk_core/common/action.c **** #endif
 706:tmk_core/common/action.c **** }
 707:tmk_core/common/action.c **** 
 708:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 709:tmk_core/common/action.c ****  *
 710:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 711:tmk_core/common/action.c ****  */
 712:tmk_core/common/action.c **** void register_code(uint8_t code) {
 137               		.loc 1 712 0
 138               		.cfi_startproc
 139               	.LVL9:
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 0 */
 143               	.L__stack_usage = 0
 713:tmk_core/common/action.c ****     if (code == KC_NO) {
 144               		.loc 1 713 0
 145 0000 8823      		tst r24
 146 0002 01F4      		brne .+2
 147 0004 00C0      		rjmp .L4
 148 0006 682F      		mov r22,r24
 714:tmk_core/common/action.c ****         return;
 715:tmk_core/common/action.c ****     }
 716:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 717:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 149               		.loc 1 717 0
 150 0008 8238      		cpi r24,lo8(-126)
 151 000a 01F4      		brne .L7
 718:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 719:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 720:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 152               		.loc 1 720 0
 153 000c 0E94 0000 		call host_keyboard_leds
 154               	.LVL10:
 155 0010 81FD      		sbrc r24,1
 156 0012 00C0      		rjmp .L4
 157               	.LVL11:
 158               	.LBB52:
 159               	.LBB53:
 160               		.file 2 "tmk_core/common/action_util.h"
   1:tmk_core/common/action_util.h **** /*
   2:tmk_core/common/action_util.h **** Copyright 2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action_util.h **** 
   4:tmk_core/common/action_util.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action_util.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action_util.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action_util.h **** (at your option) any later version.
   8:tmk_core/common/action_util.h **** 
   9:tmk_core/common/action_util.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action_util.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action_util.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action_util.h **** GNU General Public License for more details.
  13:tmk_core/common/action_util.h **** 
  14:tmk_core/common/action_util.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action_util.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action_util.h **** */
  17:tmk_core/common/action_util.h **** #ifndef ACTION_UTIL_H
  18:tmk_core/common/action_util.h **** #define ACTION_UTIL_H
  19:tmk_core/common/action_util.h **** 
  20:tmk_core/common/action_util.h **** #include <stdint.h>
  21:tmk_core/common/action_util.h **** #include "report.h"
  22:tmk_core/common/action_util.h **** 
  23:tmk_core/common/action_util.h **** #ifdef __cplusplus
  24:tmk_core/common/action_util.h **** extern "C" {
  25:tmk_core/common/action_util.h **** #endif
  26:tmk_core/common/action_util.h **** 
  27:tmk_core/common/action_util.h **** extern report_keyboard_t *keyboard_report;
  28:tmk_core/common/action_util.h **** 
  29:tmk_core/common/action_util.h **** void send_keyboard_report(void);
  30:tmk_core/common/action_util.h **** 
  31:tmk_core/common/action_util.h **** /* key */
  32:tmk_core/common/action_util.h **** inline void add_key(uint8_t key) { add_key_to_report(keyboard_report, key); }
 161               		.loc 2 32 0
 162 0014 69E3      		ldi r22,lo8(57)
 163 0016 8091 0000 		lds r24,keyboard_report
 164 001a 9091 0000 		lds r25,keyboard_report+1
 165 001e 0E94 0000 		call add_key_to_report
 166               	.LVL12:
 167               	.LBE53:
 168               	.LBE52:
 721:tmk_core/common/action.c **** #    endif
 722:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 723:tmk_core/common/action.c ****         send_keyboard_report();
 169               		.loc 1 723 0
 170 0022 0E94 0000 		call send_keyboard_report
 171               	.LVL13:
 172               	.LBB54:
 173               	.LBB55:
 174               		.file 3 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 175               		.loc 3 187 0
 176 0026 2FEF      		ldi r18,lo8(319999)
 177 0028 81EE      		ldi r24,hi8(319999)
 178 002a 94E0      		ldi r25,hlo8(319999)
 179 002c 2150      	1:	subi r18,1
 180 002e 8040      		sbci r24,0
 181 0030 9040      		sbci r25,0
 182 0032 01F4      		brne 1b
 183 0034 00C0      		rjmp .
 184 0036 0000      		nop
 185               	.LVL14:
 186               	.LBE55:
 187               	.LBE54:
 188               	.LBB56:
 189               	.LBB57:
  33:tmk_core/common/action_util.h **** 
  34:tmk_core/common/action_util.h **** inline void del_key(uint8_t key) { del_key_from_report(keyboard_report, key); }
 190               		.loc 2 34 0
 191 0038 69E3      		ldi r22,lo8(57)
 192 003a 00C0      		rjmp .L41
 193               	.LVL15:
 194               	.L7:
 195               	.LBE57:
 196               	.LBE56:
 724:tmk_core/common/action.c ****         wait_ms(100);
 725:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 726:tmk_core/common/action.c ****         send_keyboard_report();
 727:tmk_core/common/action.c ****     }
 728:tmk_core/common/action.c **** 
 729:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 197               		.loc 1 729 0
 198 003c 8338      		cpi r24,lo8(-125)
 199 003e 01F4      		brne .L9
 730:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 731:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 200               		.loc 1 731 0
 201 0040 0E94 0000 		call host_keyboard_leds
 202               	.LVL16:
 203 0044 80FD      		sbrc r24,0
 204 0046 00C0      		rjmp .L4
 205               	.LVL17:
 206               	.LBB58:
 207               	.LBB59:
  32:tmk_core/common/action_util.h **** 
 208               		.loc 2 32 0
 209 0048 63E5      		ldi r22,lo8(83)
 210 004a 8091 0000 		lds r24,keyboard_report
 211 004e 9091 0000 		lds r25,keyboard_report+1
 212 0052 0E94 0000 		call add_key_to_report
 213               	.LVL18:
 214               	.LBE59:
 215               	.LBE58:
 732:tmk_core/common/action.c **** #    endif
 733:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 734:tmk_core/common/action.c ****         send_keyboard_report();
 216               		.loc 1 734 0
 217 0056 0E94 0000 		call send_keyboard_report
 218               	.LVL19:
 219               	.LBB60:
 220               	.LBB61:
 221               		.loc 3 187 0
 222 005a 2FEF      		ldi r18,lo8(319999)
 223 005c 81EE      		ldi r24,hi8(319999)
 224 005e 94E0      		ldi r25,hlo8(319999)
 225 0060 2150      	1:	subi r18,1
 226 0062 8040      		sbci r24,0
 227 0064 9040      		sbci r25,0
 228 0066 01F4      		brne 1b
 229 0068 00C0      		rjmp .
 230 006a 0000      		nop
 231               	.LVL20:
 232               	.LBE61:
 233               	.LBE60:
 234               	.LBB62:
 235               	.LBB63:
 236               		.loc 2 34 0
 237 006c 63E5      		ldi r22,lo8(83)
 238               	.LVL21:
 239               	.L41:
 240 006e 8091 0000 		lds r24,keyboard_report
 241 0072 9091 0000 		lds r25,keyboard_report+1
 242 0076 0E94 0000 		call del_key_from_report
 243               	.LVL22:
 244               	.L42:
 245               	.LBE63:
 246               	.LBE62:
 735:tmk_core/common/action.c ****         wait_ms(100);
 736:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 737:tmk_core/common/action.c ****         send_keyboard_report();
 247               		.loc 1 737 0
 248 007a 0C94 0000 		jmp send_keyboard_report
 249               	.LVL23:
 250               	.L9:
 738:tmk_core/common/action.c ****     }
 739:tmk_core/common/action.c **** 
 740:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 251               		.loc 1 740 0
 252 007e 8438      		cpi r24,lo8(-124)
 253 0080 01F4      		brne .L10
 741:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 742:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 254               		.loc 1 742 0
 255 0082 0E94 0000 		call host_keyboard_leds
 256               	.LVL24:
 257 0086 82FD      		sbrc r24,2
 258 0088 00C0      		rjmp .L4
 259               	.LVL25:
 260               	.LBB64:
 261               	.LBB65:
  32:tmk_core/common/action_util.h **** 
 262               		.loc 2 32 0
 263 008a 67E4      		ldi r22,lo8(71)
 264 008c 8091 0000 		lds r24,keyboard_report
 265 0090 9091 0000 		lds r25,keyboard_report+1
 266 0094 0E94 0000 		call add_key_to_report
 267               	.LVL26:
 268               	.LBE65:
 269               	.LBE64:
 743:tmk_core/common/action.c **** #    endif
 744:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 745:tmk_core/common/action.c ****         send_keyboard_report();
 270               		.loc 1 745 0
 271 0098 0E94 0000 		call send_keyboard_report
 272               	.LVL27:
 273               	.LBB66:
 274               	.LBB67:
 275               		.loc 3 187 0
 276 009c 2FEF      		ldi r18,lo8(319999)
 277 009e 81EE      		ldi r24,hi8(319999)
 278 00a0 94E0      		ldi r25,hlo8(319999)
 279 00a2 2150      	1:	subi r18,1
 280 00a4 8040      		sbci r24,0
 281 00a6 9040      		sbci r25,0
 282 00a8 01F4      		brne 1b
 283 00aa 00C0      		rjmp .
 284 00ac 0000      		nop
 285               	.LVL28:
 286               	.LBE67:
 287               	.LBE66:
 288               	.LBB68:
 289               	.LBB69:
 290               		.loc 2 34 0
 291 00ae 67E4      		ldi r22,lo8(71)
 292 00b0 00C0      		rjmp .L41
 293               	.LVL29:
 294               	.L10:
 295               	.LBE69:
 296               	.LBE68:
 746:tmk_core/common/action.c ****         wait_ms(100);
 747:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 748:tmk_core/common/action.c ****         send_keyboard_report();
 749:tmk_core/common/action.c ****     }
 750:tmk_core/common/action.c **** #endif
 751:tmk_core/common/action.c **** 
 752:tmk_core/common/action.c ****     else if
 753:tmk_core/common/action.c ****         IS_KEY(code) {
 297               		.loc 1 753 0
 298 00b2 8CEF      		ldi r24,lo8(-4)
 299 00b4 860F      		add r24,r22
 300 00b6 813A      		cpi r24,lo8(-95)
 301 00b8 00F4      		brsh .L11
 302               	.LVL30:
 303               	.LBB70:
 304               	.LBB71:
  32:tmk_core/common/action_util.h **** 
 305               		.loc 2 32 0
 306 00ba 8091 0000 		lds r24,keyboard_report
 307 00be 9091 0000 		lds r25,keyboard_report+1
 308 00c2 0E94 0000 		call add_key_to_report
 309               	.LVL31:
 310 00c6 00C0      		rjmp .L42
 311               	.LVL32:
 312               	.L11:
 313               	.LBE71:
 314               	.LBE70:
 754:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 755:tmk_core/common/action.c ****             if (command_proc(code)) return;
 756:tmk_core/common/action.c **** 
 757:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 758:tmk_core/common/action.c **** /* TODO: remove
 759:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 760:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 761:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 762:tmk_core/common/action.c **** 
 763:tmk_core/common/action.c ****             add_key(code);
 764:tmk_core/common/action.c ****             send_keyboard_report();
 765:tmk_core/common/action.c **** 
 766:tmk_core/common/action.c ****             set_mods(tmp_mods);
 767:tmk_core/common/action.c ****             send_keyboard_report();
 768:tmk_core/common/action.c ****             oneshot_cancel();
 769:tmk_core/common/action.c ****         } else
 770:tmk_core/common/action.c **** */
 771:tmk_core/common/action.c **** #endif
 772:tmk_core/common/action.c ****             {
 773:tmk_core/common/action.c ****                 add_key(code);
 774:tmk_core/common/action.c ****                 send_keyboard_report();
 775:tmk_core/common/action.c ****             }
 776:tmk_core/common/action.c ****         }
 777:tmk_core/common/action.c ****     else if
 778:tmk_core/common/action.c ****         IS_MOD(code) {
 315               		.loc 1 778 0
 316 00c8 80E2      		ldi r24,lo8(32)
 317 00ca 860F      		add r24,r22
 318 00cc 8830      		cpi r24,lo8(8)
 319 00ce 00F4      		brsh .L12
 779:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 320               		.loc 1 779 0
 321 00d0 6770      		andi r22,lo8(7)
 322               	.LVL33:
 323 00d2 81E0      		ldi r24,lo8(1)
 324 00d4 00C0      		rjmp 2f
 325               		1:
 326 00d6 880F      		lsl r24
 327               		2:
 328 00d8 6A95      		dec r22
 329 00da 02F4      		brpl 1b
 330 00dc 0E94 0000 		call add_mods
 331               	.LVL34:
 332 00e0 00C0      		rjmp .L42
 333               	.LVL35:
 334               	.L12:
 780:tmk_core/common/action.c ****             send_keyboard_report();
 781:tmk_core/common/action.c ****         }
 782:tmk_core/common/action.c ****     else if
 783:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 335               		.loc 1 783 0
 336 00e2 8BE5      		ldi r24,lo8(91)
 337 00e4 860F      		add r24,r22
 338 00e6 8330      		cpi r24,lo8(3)
 339 00e8 00F4      		brsh .L13
 340               		.loc 1 783 0 is_stmt 0 discriminator 1
 341 00ea 653A      		cpi r22,lo8(-91)
 342 00ec 01F0      		breq .L16
 343               		.loc 1 783 0 discriminator 2
 344 00ee 663A      		cpi r22,lo8(-90)
 345 00f0 01F0      		breq .L17
 346               		.loc 1 783 0
 347 00f2 83E8      		ldi r24,lo8(-125)
 348 00f4 90E0      		ldi r25,0
 349 00f6 00C0      		rjmp .L14
 350               	.L16:
 351 00f8 81E8      		ldi r24,lo8(-127)
 352 00fa 90E0      		ldi r25,0
 353 00fc 00C0      		rjmp .L14
 354               	.L17:
 355 00fe 82E8      		ldi r24,lo8(-126)
 356 0100 90E0      		ldi r25,0
 357               	.L14:
 358               		.loc 1 783 0 discriminator 13
 359 0102 0C94 0000 		jmp host_system_send
 360               	.LVL36:
 361               	.L13:
 784:tmk_core/common/action.c ****     else if
 785:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 362               		.loc 1 785 0 is_stmt 1
 363 0106 88E5      		ldi r24,lo8(88)
 364 0108 860F      		add r24,r22
 365 010a 8731      		cpi r24,lo8(23)
 366 010c 00F0      		brlo .+2
 367 010e 00C0      		rjmp .L4
 368               		.loc 1 785 0 is_stmt 0 discriminator 1
 369 0110 683A      		cpi r22,lo8(-88)
 370 0112 01F4      		brne .+2
 371 0114 00C0      		rjmp .L18
 372               		.loc 1 785 0 discriminator 2
 373 0116 693A      		cpi r22,lo8(-87)
 374 0118 01F4      		brne .+2
 375 011a 00C0      		rjmp .L19
 376               		.loc 1 785 0 discriminator 4
 377 011c 6A3A      		cpi r22,lo8(-86)
 378 011e 01F4      		brne .+2
 379 0120 00C0      		rjmp .L20
 380               		.loc 1 785 0 discriminator 6
 381 0122 6B3A      		cpi r22,lo8(-85)
 382 0124 01F4      		brne .+2
 383 0126 00C0      		rjmp .L21
 384               		.loc 1 785 0 discriminator 8
 385 0128 6C3A      		cpi r22,lo8(-84)
 386 012a 01F4      		brne .+2
 387 012c 00C0      		rjmp .L22
 388               		.loc 1 785 0 discriminator 10
 389 012e 6B3B      		cpi r22,lo8(-69)
 390 0130 01F4      		brne .+2
 391 0132 00C0      		rjmp .L23
 392               		.loc 1 785 0 discriminator 12
 393 0134 6C3B      		cpi r22,lo8(-68)
 394 0136 01F4      		brne .+2
 395 0138 00C0      		rjmp .L24
 396               		.loc 1 785 0 discriminator 14
 397 013a 6D3A      		cpi r22,lo8(-83)
 398 013c 01F4      		brne .+2
 399 013e 00C0      		rjmp .L25
 400               		.loc 1 785 0 discriminator 16
 401 0140 603B      		cpi r22,lo8(-80)
 402 0142 01F4      		brne .+2
 403 0144 00C0      		rjmp .L26
 404               		.loc 1 785 0 discriminator 18
 405 0146 6E3A      		cpi r22,lo8(-82)
 406 0148 01F4      		brne .+2
 407 014a 00C0      		rjmp .L27
 408               		.loc 1 785 0 discriminator 20
 409 014c 6F3A      		cpi r22,lo8(-81)
 410 014e 01F4      		brne .+2
 411 0150 00C0      		rjmp .L28
 412               		.loc 1 785 0 discriminator 22
 413 0152 613B      		cpi r22,lo8(-79)
 414 0154 01F4      		brne .+2
 415 0156 00C0      		rjmp .L29
 416               		.loc 1 785 0 discriminator 24
 417 0158 623B      		cpi r22,lo8(-78)
 418 015a 01F4      		brne .+2
 419 015c 00C0      		rjmp .L30
 420               		.loc 1 785 0 discriminator 26
 421 015e 633B      		cpi r22,lo8(-77)
 422 0160 01F4      		brne .+2
 423 0162 00C0      		rjmp .L31
 424               		.loc 1 785 0 discriminator 28
 425 0164 643B      		cpi r22,lo8(-76)
 426 0166 01F4      		brne .+2
 427 0168 00C0      		rjmp .L32
 428               		.loc 1 785 0 discriminator 30
 429 016a 653B      		cpi r22,lo8(-75)
 430 016c 01F4      		brne .+2
 431 016e 00C0      		rjmp .L33
 432               		.loc 1 785 0 discriminator 32
 433 0170 663B      		cpi r22,lo8(-74)
 434 0172 01F4      		brne .+2
 435 0174 00C0      		rjmp .L34
 436               		.loc 1 785 0 discriminator 34
 437 0176 673B      		cpi r22,lo8(-73)
 438 0178 01F4      		brne .+2
 439 017a 00C0      		rjmp .L35
 440               		.loc 1 785 0 discriminator 36
 441 017c 683B      		cpi r22,lo8(-72)
 442 017e 01F4      		brne .+2
 443 0180 00C0      		rjmp .L36
 444               		.loc 1 785 0 discriminator 38
 445 0182 693B      		cpi r22,lo8(-71)
 446 0184 01F4      		brne .+2
 447 0186 00C0      		rjmp .L37
 448               		.loc 1 785 0 discriminator 40
 449 0188 6D3B      		cpi r22,lo8(-67)
 450 018a 01F4      		brne .+2
 451 018c 00C0      		rjmp .L38
 452               		.loc 1 785 0 discriminator 42
 453 018e 6E3B      		cpi r22,lo8(-66)
 454 0190 01F4      		brne .+2
 455 0192 00C0      		rjmp .L39
 456               		.loc 1 785 0 discriminator 44
 457 0194 6A3B      		cpi r22,lo8(-70)
 458 0196 01F4      		brne .+2
 459 0198 00C0      		rjmp .L40
 460               		.loc 1 785 0
 461 019a 80E0      		ldi r24,0
 462 019c 90E0      		ldi r25,0
 463 019e 00C0      		rjmp .L15
 464               	.L18:
 465 01a0 82EE      		ldi r24,lo8(-30)
 466 01a2 90E0      		ldi r25,0
 467 01a4 00C0      		rjmp .L15
 468               	.L19:
 469 01a6 89EE      		ldi r24,lo8(-23)
 470 01a8 90E0      		ldi r25,0
 471 01aa 00C0      		rjmp .L15
 472               	.L20:
 473 01ac 8AEE      		ldi r24,lo8(-22)
 474 01ae 90E0      		ldi r25,0
 475 01b0 00C0      		rjmp .L15
 476               	.L21:
 477 01b2 85EB      		ldi r24,lo8(-75)
 478 01b4 90E0      		ldi r25,0
 479 01b6 00C0      		rjmp .L15
 480               	.L22:
 481 01b8 86EB      		ldi r24,lo8(-74)
 482 01ba 90E0      		ldi r25,0
 483 01bc 00C0      		rjmp .L15
 484               	.L23:
 485 01be 83EB      		ldi r24,lo8(-77)
 486 01c0 90E0      		ldi r25,0
 487 01c2 00C0      		rjmp .L15
 488               	.L24:
 489 01c4 84EB      		ldi r24,lo8(-76)
 490 01c6 90E0      		ldi r25,0
 491 01c8 00C0      		rjmp .L15
 492               	.L25:
 493 01ca 87EB      		ldi r24,lo8(-73)
 494 01cc 90E0      		ldi r25,0
 495 01ce 00C0      		rjmp .L15
 496               	.L26:
 497 01d0 8CEC      		ldi r24,lo8(-52)
 498 01d2 90E0      		ldi r25,0
 499 01d4 00C0      		rjmp .L15
 500               	.L27:
 501 01d6 8DEC      		ldi r24,lo8(-51)
 502 01d8 90E0      		ldi r25,0
 503 01da 00C0      		rjmp .L15
 504               	.L28:
 505 01dc 83E8      		ldi r24,lo8(-125)
 506 01de 91E0      		ldi r25,lo8(1)
 507 01e0 00C0      		rjmp .L15
 508               	.L29:
 509 01e2 8AE8      		ldi r24,lo8(-118)
 510 01e4 91E0      		ldi r25,lo8(1)
 511 01e6 00C0      		rjmp .L15
 512               	.L30:
 513 01e8 82E9      		ldi r24,lo8(-110)
 514 01ea 91E0      		ldi r25,lo8(1)
 515 01ec 00C0      		rjmp .L15
 516               	.L31:
 517 01ee 84E9      		ldi r24,lo8(-108)
 518 01f0 91E0      		ldi r25,lo8(1)
 519 01f2 00C0      		rjmp .L15
 520               	.L32:
 521 01f4 81E2      		ldi r24,lo8(33)
 522 01f6 92E0      		ldi r25,lo8(2)
 523 01f8 00C0      		rjmp .L15
 524               	.L33:
 525 01fa 83E2      		ldi r24,lo8(35)
 526 01fc 92E0      		ldi r25,lo8(2)
 527 01fe 00C0      		rjmp .L15
 528               	.L34:
 529 0200 84E2      		ldi r24,lo8(36)
 530 0202 92E0      		ldi r25,lo8(2)
 531 0204 00C0      		rjmp .L15
 532               	.L35:
 533 0206 85E2      		ldi r24,lo8(37)
 534 0208 92E0      		ldi r25,lo8(2)
 535 020a 00C0      		rjmp .L15
 536               	.L36:
 537 020c 86E2      		ldi r24,lo8(38)
 538 020e 92E0      		ldi r25,lo8(2)
 539 0210 00C0      		rjmp .L15
 540               	.L37:
 541 0212 87E2      		ldi r24,lo8(39)
 542 0214 92E0      		ldi r25,lo8(2)
 543 0216 00C0      		rjmp .L15
 544               	.L38:
 545 0218 8FE6      		ldi r24,lo8(111)
 546 021a 90E0      		ldi r25,0
 547 021c 00C0      		rjmp .L15
 548               	.L39:
 549 021e 80E7      		ldi r24,lo8(112)
 550 0220 90E0      		ldi r25,0
 551 0222 00C0      		rjmp .L15
 552               	.L40:
 553 0224 8AE2      		ldi r24,lo8(42)
 554 0226 92E0      		ldi r25,lo8(2)
 555               	.L15:
 556               		.loc 1 785 0 discriminator 93
 557 0228 0C94 0000 		jmp host_consumer_send
 558               	.LVL37:
 559               	.L4:
 560 022c 0895      		ret
 561               		.cfi_endproc
 562               	.LFE19:
 564               		.section	.text.unregister_code,"ax",@progbits
 565               	.global	unregister_code
 567               	unregister_code:
 568               	.LFB20:
 786:tmk_core/common/action.c **** 
 787:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 788:tmk_core/common/action.c ****     else if
 789:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 790:tmk_core/common/action.c ****             mousekey_on(code);
 791:tmk_core/common/action.c ****             mousekey_send();
 792:tmk_core/common/action.c ****         }
 793:tmk_core/common/action.c **** #endif
 794:tmk_core/common/action.c **** }
 795:tmk_core/common/action.c **** 
 796:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 797:tmk_core/common/action.c ****  *
 798:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 799:tmk_core/common/action.c ****  */
 800:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 569               		.loc 1 800 0 is_stmt 1
 570               		.cfi_startproc
 571               	.LVL38:
 572               	/* prologue: function */
 573               	/* frame size = 0 */
 574               	/* stack size = 0 */
 575               	.L__stack_usage = 0
 801:tmk_core/common/action.c ****     if (code == KC_NO) {
 576               		.loc 1 801 0
 577 0000 8823      		tst r24
 578 0002 01F4      		brne .+2
 579 0004 00C0      		rjmp .L44
 580 0006 682F      		mov r22,r24
 802:tmk_core/common/action.c ****         return;
 803:tmk_core/common/action.c ****     }
 804:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 805:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 581               		.loc 1 805 0
 582 0008 8238      		cpi r24,lo8(-126)
 583 000a 01F4      		brne .L47
 806:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 807:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 808:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 584               		.loc 1 808 0
 585 000c 0E94 0000 		call host_keyboard_leds
 586               	.LVL39:
 587 0010 81FF      		sbrs r24,1
 588 0012 00C0      		rjmp .L44
 589               	.LVL40:
 590               	.LBB72:
 591               	.LBB73:
  32:tmk_core/common/action_util.h **** 
 592               		.loc 2 32 0
 593 0014 69E3      		ldi r22,lo8(57)
 594 0016 8091 0000 		lds r24,keyboard_report
 595 001a 9091 0000 		lds r25,keyboard_report+1
 596 001e 0E94 0000 		call add_key_to_report
 597               	.LVL41:
 598               	.LBE73:
 599               	.LBE72:
 809:tmk_core/common/action.c **** #    endif
 810:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 811:tmk_core/common/action.c ****         send_keyboard_report();
 600               		.loc 1 811 0
 601 0022 0E94 0000 		call send_keyboard_report
 602               	.LVL42:
 603               	.LBB74:
 604               	.LBB75:
 605               		.loc 2 34 0
 606 0026 69E3      		ldi r22,lo8(57)
 607 0028 00C0      		rjmp .L63
 608               	.LVL43:
 609               	.L47:
 610               	.LBE75:
 611               	.LBE74:
 812:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 813:tmk_core/common/action.c ****         send_keyboard_report();
 814:tmk_core/common/action.c ****     }
 815:tmk_core/common/action.c **** 
 816:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 612               		.loc 1 816 0
 613 002a 8338      		cpi r24,lo8(-125)
 614 002c 01F4      		brne .L49
 817:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 818:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 615               		.loc 1 818 0
 616 002e 0E94 0000 		call host_keyboard_leds
 617               	.LVL44:
 618 0032 80FF      		sbrs r24,0
 619 0034 00C0      		rjmp .L44
 620               	.LVL45:
 621               	.LBB76:
 622               	.LBB77:
  32:tmk_core/common/action_util.h **** 
 623               		.loc 2 32 0
 624 0036 63E5      		ldi r22,lo8(83)
 625 0038 8091 0000 		lds r24,keyboard_report
 626 003c 9091 0000 		lds r25,keyboard_report+1
 627 0040 0E94 0000 		call add_key_to_report
 628               	.LVL46:
 629               	.LBE77:
 630               	.LBE76:
 819:tmk_core/common/action.c **** #    endif
 820:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 821:tmk_core/common/action.c ****         send_keyboard_report();
 631               		.loc 1 821 0
 632 0044 0E94 0000 		call send_keyboard_report
 633               	.LVL47:
 634               	.LBB78:
 635               	.LBB79:
 636               		.loc 2 34 0
 637 0048 63E5      		ldi r22,lo8(83)
 638               	.LVL48:
 639               	.L63:
 640 004a 8091 0000 		lds r24,keyboard_report
 641 004e 9091 0000 		lds r25,keyboard_report+1
 642 0052 0E94 0000 		call del_key_from_report
 643               	.LVL49:
 644               	.L64:
 645               	.LBE79:
 646               	.LBE78:
 822:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 823:tmk_core/common/action.c ****         send_keyboard_report();
 647               		.loc 1 823 0
 648 0056 0C94 0000 		jmp send_keyboard_report
 649               	.LVL50:
 650               	.L49:
 824:tmk_core/common/action.c ****     }
 825:tmk_core/common/action.c **** 
 826:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 651               		.loc 1 826 0
 652 005a 8438      		cpi r24,lo8(-124)
 653 005c 01F4      		brne .L50
 827:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 828:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 654               		.loc 1 828 0
 655 005e 0E94 0000 		call host_keyboard_leds
 656               	.LVL51:
 657 0062 82FF      		sbrs r24,2
 658 0064 00C0      		rjmp .L44
 659               	.LVL52:
 660               	.LBB80:
 661               	.LBB81:
  32:tmk_core/common/action_util.h **** 
 662               		.loc 2 32 0
 663 0066 67E4      		ldi r22,lo8(71)
 664 0068 8091 0000 		lds r24,keyboard_report
 665 006c 9091 0000 		lds r25,keyboard_report+1
 666 0070 0E94 0000 		call add_key_to_report
 667               	.LVL53:
 668               	.LBE81:
 669               	.LBE80:
 829:tmk_core/common/action.c **** #    endif
 830:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 831:tmk_core/common/action.c ****         send_keyboard_report();
 670               		.loc 1 831 0
 671 0074 0E94 0000 		call send_keyboard_report
 672               	.LVL54:
 673               	.LBB82:
 674               	.LBB83:
 675               		.loc 2 34 0
 676 0078 67E4      		ldi r22,lo8(71)
 677 007a 00C0      		rjmp .L63
 678               	.LVL55:
 679               	.L50:
 680               	.LBE83:
 681               	.LBE82:
 832:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 833:tmk_core/common/action.c ****         send_keyboard_report();
 834:tmk_core/common/action.c ****     }
 835:tmk_core/common/action.c **** #endif
 836:tmk_core/common/action.c **** 
 837:tmk_core/common/action.c ****     else if
 838:tmk_core/common/action.c ****         IS_KEY(code) {
 682               		.loc 1 838 0
 683 007c 8CEF      		ldi r24,lo8(-4)
 684 007e 860F      		add r24,r22
 685 0080 813A      		cpi r24,lo8(-95)
 686 0082 00F0      		brlo .L63
 839:tmk_core/common/action.c ****             del_key(code);
 840:tmk_core/common/action.c ****             send_keyboard_report();
 841:tmk_core/common/action.c ****         }
 842:tmk_core/common/action.c ****     else if
 843:tmk_core/common/action.c ****         IS_MOD(code) {
 687               		.loc 1 843 0
 688 0084 80E2      		ldi r24,lo8(32)
 689 0086 860F      		add r24,r22
 690 0088 8830      		cpi r24,lo8(8)
 691 008a 00F4      		brsh .L52
 844:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 692               		.loc 1 844 0
 693 008c 6770      		andi r22,lo8(7)
 694               	.LVL56:
 695 008e 81E0      		ldi r24,lo8(1)
 696 0090 00C0      		rjmp 2f
 697               		1:
 698 0092 880F      		lsl r24
 699               		2:
 700 0094 6A95      		dec r22
 701 0096 02F4      		brpl 1b
 702 0098 0E94 0000 		call del_mods
 703               	.LVL57:
 704 009c 00C0      		rjmp .L64
 705               	.LVL58:
 706               	.L52:
 845:tmk_core/common/action.c ****             send_keyboard_report();
 846:tmk_core/common/action.c ****         }
 847:tmk_core/common/action.c ****     else if
 848:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(0); }
 707               		.loc 1 848 0
 708 009e 8BE5      		ldi r24,lo8(91)
 709 00a0 860F      		add r24,r22
 710 00a2 8330      		cpi r24,lo8(3)
 711 00a4 00F4      		brsh .L53
 712               		.loc 1 848 0 is_stmt 0 discriminator 1
 713 00a6 80E0      		ldi r24,0
 714 00a8 90E0      		ldi r25,0
 715 00aa 0C94 0000 		jmp host_system_send
 716               	.LVL59:
 717               	.L53:
 849:tmk_core/common/action.c ****     else if
 850:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(0); }
 718               		.loc 1 850 0 is_stmt 1
 719 00ae 685A      		subi r22,lo8(-(88))
 720               	.LVL60:
 721 00b0 6731      		cpi r22,lo8(23)
 722 00b2 00F4      		brsh .L44
 723               		.loc 1 850 0 is_stmt 0 discriminator 1
 724 00b4 80E0      		ldi r24,0
 725 00b6 90E0      		ldi r25,0
 726 00b8 0C94 0000 		jmp host_consumer_send
 727               	.LVL61:
 728               	.L44:
 729 00bc 0895      		ret
 730               		.cfi_endproc
 731               	.LFE20:
 733               		.section	.text.tap_code,"ax",@progbits
 734               	.global	tap_code
 736               	tap_code:
 737               	.LFB21:
 851:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 852:tmk_core/common/action.c ****     else if
 853:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 854:tmk_core/common/action.c ****             mousekey_off(code);
 855:tmk_core/common/action.c ****             mousekey_send();
 856:tmk_core/common/action.c ****         }
 857:tmk_core/common/action.c **** #endif
 858:tmk_core/common/action.c **** }
 859:tmk_core/common/action.c **** 
 860:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 861:tmk_core/common/action.c ****  *
 862:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 863:tmk_core/common/action.c ****  */
 864:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 738               		.loc 1 864 0 is_stmt 1
 739               		.cfi_startproc
 740               	.LVL62:
 741 0000 CF93      		push r28
 742               	.LCFI4:
 743               		.cfi_def_cfa_offset 3
 744               		.cfi_offset 28, -2
 745               	/* prologue: function */
 746               	/* frame size = 0 */
 747               	/* stack size = 1 */
 748               	.L__stack_usage = 1
 749 0002 C82F      		mov r28,r24
 865:tmk_core/common/action.c ****     register_code(code);
 750               		.loc 1 865 0
 751 0004 0E94 0000 		call register_code
 752               	.LVL63:
 866:tmk_core/common/action.c ****     if (code == KC_CAPS) {
 753               		.loc 1 866 0
 754 0008 C933      		cpi r28,lo8(57)
 755 000a 01F4      		brne .L67
 756               	.LVL64:
 757               	.LBB84:
 758               	.LBB85:
 759               		.loc 3 187 0
 760 000c 2FEF      		ldi r18,lo8(255999)
 761 000e 87EE      		ldi r24,hi8(255999)
 762 0010 93E0      		ldi r25,hlo8(255999)
 763 0012 2150      	1:	subi r18,1
 764 0014 8040      		sbci r24,0
 765 0016 9040      		sbci r25,0
 766 0018 01F4      		brne 1b
 767 001a 00C0      		rjmp .
 768 001c 0000      		nop
 769               	.LVL65:
 770               	.L67:
 771               	.LBE85:
 772               	.LBE84:
 867:tmk_core/common/action.c ****         wait_ms(TAP_HOLD_CAPS_DELAY);
 868:tmk_core/common/action.c ****     } else {
 869:tmk_core/common/action.c ****         wait_ms(TAP_CODE_DELAY);
 870:tmk_core/common/action.c ****     }
 871:tmk_core/common/action.c ****     unregister_code(code);
 773               		.loc 1 871 0
 774 001e 8C2F      		mov r24,r28
 775               	/* epilogue start */
 872:tmk_core/common/action.c **** }
 776               		.loc 1 872 0
 777 0020 CF91      		pop r28
 778               	.LVL66:
 871:tmk_core/common/action.c **** }
 779               		.loc 1 871 0
 780 0022 0C94 0000 		jmp unregister_code
 781               	.LVL67:
 782               		.cfi_endproc
 783               	.LFE21:
 785               		.section	.text.register_mods,"ax",@progbits
 786               	.global	register_mods
 788               	register_mods:
 789               	.LFB22:
 873:tmk_core/common/action.c **** 
 874:tmk_core/common/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 875:tmk_core/common/action.c ****  *
 876:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 877:tmk_core/common/action.c ****  */
 878:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 790               		.loc 1 878 0
 791               		.cfi_startproc
 792               	.LVL68:
 793               	/* prologue: function */
 794               	/* frame size = 0 */
 795               	/* stack size = 0 */
 796               	.L__stack_usage = 0
 879:tmk_core/common/action.c ****     if (mods) {
 797               		.loc 1 879 0
 798 0000 8823      		tst r24
 799 0002 01F0      		breq .L68
 880:tmk_core/common/action.c ****         add_mods(mods);
 800               		.loc 1 880 0
 801 0004 0E94 0000 		call add_mods
 802               	.LVL69:
 881:tmk_core/common/action.c ****         send_keyboard_report();
 803               		.loc 1 881 0
 804 0008 0C94 0000 		jmp send_keyboard_report
 805               	.LVL70:
 806               	.L68:
 807 000c 0895      		ret
 808               		.cfi_endproc
 809               	.LFE22:
 811               		.section	.text.unregister_mods,"ax",@progbits
 812               	.global	unregister_mods
 814               	unregister_mods:
 815               	.LFB23:
 882:tmk_core/common/action.c ****     }
 883:tmk_core/common/action.c **** }
 884:tmk_core/common/action.c **** 
 885:tmk_core/common/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 886:tmk_core/common/action.c ****  *
 887:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 888:tmk_core/common/action.c ****  */
 889:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 816               		.loc 1 889 0
 817               		.cfi_startproc
 818               	.LVL71:
 819               	/* prologue: function */
 820               	/* frame size = 0 */
 821               	/* stack size = 0 */
 822               	.L__stack_usage = 0
 890:tmk_core/common/action.c ****     if (mods) {
 823               		.loc 1 890 0
 824 0000 8823      		tst r24
 825 0002 01F0      		breq .L70
 891:tmk_core/common/action.c ****         del_mods(mods);
 826               		.loc 1 891 0
 827 0004 0E94 0000 		call del_mods
 828               	.LVL72:
 892:tmk_core/common/action.c ****         send_keyboard_report();
 829               		.loc 1 892 0
 830 0008 0C94 0000 		jmp send_keyboard_report
 831               	.LVL73:
 832               	.L70:
 833 000c 0895      		ret
 834               		.cfi_endproc
 835               	.LFE23:
 837               		.section	.text.process_action,"ax",@progbits
 838               	.global	process_action
 840               	process_action:
 841               	.LFB18:
 200:tmk_core/common/action.c ****     keyevent_t event = record->event;
 842               		.loc 1 200 0
 843               		.cfi_startproc
 844               	.LVL74:
 845 0000 CF92      		push r12
 846               	.LCFI5:
 847               		.cfi_def_cfa_offset 3
 848               		.cfi_offset 12, -2
 849 0002 DF92      		push r13
 850               	.LCFI6:
 851               		.cfi_def_cfa_offset 4
 852               		.cfi_offset 13, -3
 853 0004 EF92      		push r14
 854               	.LCFI7:
 855               		.cfi_def_cfa_offset 5
 856               		.cfi_offset 14, -4
 857 0006 FF92      		push r15
 858               	.LCFI8:
 859               		.cfi_def_cfa_offset 6
 860               		.cfi_offset 15, -5
 861 0008 0F93      		push r16
 862               	.LCFI9:
 863               		.cfi_def_cfa_offset 7
 864               		.cfi_offset 16, -6
 865 000a 1F93      		push r17
 866               	.LCFI10:
 867               		.cfi_def_cfa_offset 8
 868               		.cfi_offset 17, -7
 869 000c CF93      		push r28
 870               	.LCFI11:
 871               		.cfi_def_cfa_offset 9
 872               		.cfi_offset 28, -8
 873 000e DF93      		push r29
 874               	.LCFI12:
 875               		.cfi_def_cfa_offset 10
 876               		.cfi_offset 29, -9
 877               	/* prologue: function */
 878               	/* frame size = 0 */
 879               	/* stack size = 8 */
 880               	.L__stack_usage = 8
 881 0010 7C01      		movw r14,r24
 882 0012 062F      		mov r16,r22
 883 0014 C72F      		mov r28,r23
 884               	.LVL75:
 203:tmk_core/common/action.c **** #endif
 885               		.loc 1 203 0
 886 0016 FC01      		movw r30,r24
 887 0018 1581      		ldd r17,Z+5
 888 001a 1295      		swap r17
 889 001c 1F70      		andi r17,lo8(15)
 890               	.LVL76:
 206:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 891               		.loc 1 206 0
 892 001e D281      		ldd r29,Z+2
 893 0020 D111      		cpse r29,__zero_reg__
 208:tmk_core/common/action.c ****     }
 894               		.loc 1 208 0
 895 0022 0E94 0000 		call clear_weak_mods
 896               	.LVL77:
 897               	.L73:
 214:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 898               		.loc 1 214 0
 899 0026 0E94 0000 		call is_oneshot_layer_active
 900               	.LVL78:
 901 002a 8823      		tst r24
 902 002c 01F0      		breq .L155
 214:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 903               		.loc 1 214 0 is_stmt 0 discriminator 1
 904 002e DD23      		tst r29
 905 0030 01F0      		breq .L155
 214:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 906               		.loc 1 214 0 discriminator 2
 907 0032 80E2      		ldi r24,lo8(32)
 908 0034 800F      		add r24,r16
 909 0036 8830      		cpi r24,lo8(8)
 910 0038 00F0      		brlo .L155
 215:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 911               		.loc 1 215 0 is_stmt 1
 912 003a 82E0      		ldi r24,lo8(2)
 913 003c 0E94 0000 		call clear_oneshot_layer_state
 914               	.LVL79:
 216:tmk_core/common/action.c ****     }
 915               		.loc 1 216 0
 916 0040 0E94 0000 		call is_oneshot_layer_active
 917               	.LVL80:
 918 0044 91E0      		ldi r25,lo8(1)
 919 0046 D82E      		mov r13,r24
 920 0048 D926      		eor r13,r25
 921               	.LVL81:
 922 004a 00C0      		rjmp .L74
 923               	.LVL82:
 924               	.L155:
 212:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 925               		.loc 1 212 0
 926 004c D12C      		mov r13,__zero_reg__
 927               	.LVL83:
 928               	.L74:
 220:tmk_core/common/action.c ****         /* Key and Mods */
 929               		.loc 1 220 0
 930 004e CC2E      		mov r12,r28
 931 0050 C294      		swap r12
 932 0052 8FE0      		ldi r24,lo8(15)
 933 0054 C822      		and r12,r24
 934 0056 8C2D      		mov r24,r12
 935 0058 90E0      		ldi r25,0
 936 005a FC01      		movw r30,r24
 937 005c E050      		subi r30,lo8(-(gs(.L77)))
 938 005e F040      		sbci r31,hi8(-(gs(.L77)))
 939 0060 0C94 0000 		jmp __tablejump2__
 940               		.section	.progmem.gcc_sw_table.process_action,"a",@progbits
 941               		.p2align	1
 942               	.L77:
 943 0000 0000      		.word gs(.L76)
 944 0002 0000      		.word gs(.L76)
 945 0004 0000      		.word gs(.L78)
 946 0006 0000      		.word gs(.L78)
 947 0008 0000      		.word gs(.L79)
 948 000a 0000      		.word gs(.L75)
 949 000c 0000      		.word gs(.L75)
 950 000e 0000      		.word gs(.L75)
 951 0010 0000      		.word gs(.L80)
 952 0012 0000      		.word gs(.L81)
 953 0014 0000      		.word gs(.L82)
 954 0016 0000      		.word gs(.L82)
 955 0018 0000      		.word gs(.L83)
 956 001a 0000      		.word gs(.L75)
 957 001c 0000      		.word gs(.L75)
 958 001e 0000      		.word gs(.L84)
 959               		.section	.text.process_action
 960               	.L76:
 961               	.LBB86:
 224:tmk_core/common/action.c ****             if (event.pressed) {
 962               		.loc 1 224 0
 963 0064 8C2F      		mov r24,r28
 964 0066 807F      		andi r24,lo8(-16)
 965 0068 CF70      		andi r28,lo8(15)
 966               	.LVL84:
 967 006a 8823      		tst r24
 968 006c 01F0      		breq .L86
 224:tmk_core/common/action.c ****             if (event.pressed) {
 969               		.loc 1 224 0 is_stmt 0 discriminator 2
 970 006e C295      		swap r28
 971 0070 C07F      		andi r28,lo8(-16)
 972               	.L86:
 973               	.LVL85:
 225:tmk_core/common/action.c ****                 if (mods) {
 974               		.loc 1 225 0 is_stmt 1 discriminator 4
 975 0072 DD23      		tst r29
 976 0074 01F0      		breq .L87
 226:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 977               		.loc 1 226 0
 978 0076 CC23      		tst r28
 979 0078 01F4      		brne .+2
 980 007a 00C0      		rjmp .L181
 227:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 981               		.loc 1 227 0
 982 007c 80E2      		ldi r24,lo8(32)
 983 007e 800F      		add r24,r16
 984 0080 8830      		cpi r24,lo8(8)
 985 0082 00F0      		brlo .L89
 227:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 986               		.loc 1 227 0 is_stmt 0 discriminator 1
 987 0084 0111      		cpse r16,__zero_reg__
 988 0086 00C0      		rjmp .L90
 989               	.L89:
 231:tmk_core/common/action.c ****                     } else {
 990               		.loc 1 231 0 is_stmt 1
 991 0088 8C2F      		mov r24,r28
 992 008a 0E94 0000 		call add_mods
 993               	.LVL86:
 994 008e 00C0      		rjmp .L91
 995               	.L90:
 233:tmk_core/common/action.c ****                     }
 996               		.loc 1 233 0
 997 0090 8C2F      		mov r24,r28
 998 0092 0E94 0000 		call add_weak_mods
 999               	.LVL87:
 1000               	.L91:
 235:tmk_core/common/action.c ****                 }
 1001               		.loc 1 235 0
 1002 0096 0E94 0000 		call send_keyboard_report
 1003               	.LVL88:
 1004 009a 00C0      		rjmp .L181
 1005               	.L87:
 239:tmk_core/common/action.c ****                 if (mods) {
 1006               		.loc 1 239 0
 1007 009c 802F      		mov r24,r16
 1008 009e 0E94 0000 		call unregister_code
 1009               	.LVL89:
 240:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1010               		.loc 1 240 0
 1011 00a2 CC23      		tst r28
 1012 00a4 01F4      		brne .+2
 1013 00a6 00C0      		rjmp .L75
 241:tmk_core/common/action.c ****                         del_mods(mods);
 1014               		.loc 1 241 0
 1015 00a8 80E2      		ldi r24,lo8(32)
 1016 00aa 800F      		add r24,r16
 1017 00ac 8830      		cpi r24,lo8(8)
 1018 00ae 00F0      		brlo .L93
 241:tmk_core/common/action.c ****                         del_mods(mods);
 1019               		.loc 1 241 0 is_stmt 0 discriminator 1
 1020 00b0 0111      		cpse r16,__zero_reg__
 1021 00b2 00C0      		rjmp .L94
 1022               	.L93:
 242:tmk_core/common/action.c ****                     } else {
 1023               		.loc 1 242 0 is_stmt 1
 1024 00b4 8C2F      		mov r24,r28
 1025 00b6 0E94 0000 		call del_mods
 1026               	.LVL90:
 1027 00ba 00C0      		rjmp .L95
 1028               	.L94:
 244:tmk_core/common/action.c ****                     }
 1029               		.loc 1 244 0
 1030 00bc 8C2F      		mov r24,r28
 1031 00be 0E94 0000 		call del_weak_mods
 1032               	.LVL91:
 1033               	.L95:
 246:tmk_core/common/action.c ****                 }
 1034               		.loc 1 246 0
 1035 00c2 0E94 0000 		call send_keyboard_report
 1036               	.LVL92:
 1037 00c6 00C0      		rjmp .L75
 1038               	.LVL93:
 1039               	.L78:
 1040               	.LBE86:
 1041               	.LBB87:
 253:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1042               		.loc 1 253 0
 1043 00c8 8C2F      		mov r24,r28
 1044 00ca 807F      		andi r24,lo8(-16)
 1045 00cc CF70      		andi r28,lo8(15)
 1046               	.LVL94:
 1047 00ce 8032      		cpi r24,lo8(32)
 1048 00d0 01F0      		breq .L97
 253:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1049               		.loc 1 253 0 is_stmt 0 discriminator 2
 1050 00d2 C295      		swap r28
 1051 00d4 C07F      		andi r28,lo8(-16)
 1052               	.L97:
 1053               	.LVL95:
 254:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 1054               		.loc 1 254 0 is_stmt 1 discriminator 4
 1055 00d6 0023      		tst r16
 1056 00d8 01F0      		breq .L99
 1057 00da 0130      		cpi r16,lo8(1)
 1058 00dc 01F0      		breq .L100
 1059 00de 00C0      		rjmp .L187
 1060               	.L99:
 258:tmk_core/common/action.c ****                         if (tap_count == 0) {
 1061               		.loc 1 258 0
 1062 00e0 DD23      		tst r29
 1063 00e2 01F0      		breq .L101
 259:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1064               		.loc 1 259 0
 1065 00e4 1123      		tst r17
 1066 00e6 01F0      		breq .L103
 262:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1067               		.loc 1 262 0
 1068 00e8 1130      		cpi r17,lo8(1)
 1069 00ea 01F4      		brne .L103
 264:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1070               		.loc 1 264 0
 1071 00ec 0E94 0000 		call get_oneshot_mods
 1072               	.LVL96:
 1073 00f0 8C2B      		or r24,r28
 1074 00f2 0E94 0000 		call set_oneshot_mods
 1075               	.LVL97:
 1076 00f6 00C0      		rjmp .L75
 1077               	.L103:
 273:tmk_core/common/action.c ****                         }
 1078               		.loc 1 273 0
 1079 00f8 0E94 0000 		call get_oneshot_mods
 1080               	.LVL98:
 1081 00fc 8C2B      		or r24,r28
 1082 00fe 00C0      		rjmp .L180
 1083               	.L101:
 276:tmk_core/common/action.c ****                             clear_oneshot_mods();
 1084               		.loc 1 276 0
 1085 0100 1123      		tst r17
 1086 0102 01F0      		breq .L185
 279:tmk_core/common/action.c ****                             // Retain Oneshot mods
 1087               		.loc 1 279 0
 1088 0104 1130      		cpi r17,lo8(1)
 1089 0106 01F4      		brne .+2
 1090 0108 00C0      		rjmp .L75
 1091               	.L185:
 291:tmk_core/common/action.c ****                             unregister_mods(mods);
 1092               		.loc 1 291 0
 1093 010a 0E94 0000 		call clear_oneshot_mods
 1094               	.LVL99:
 1095 010e 00C0      		rjmp .L110
 1096               	.L100:
 298:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1097               		.loc 1 298 0
 1098 0110 DD23      		tst r29
 1099 0112 01F0      		breq .L106
 299:tmk_core/common/action.c ****                             register_mods(mods);
 1100               		.loc 1 299 0
 1101 0114 1630      		cpi r17,lo8(6)
 1102 0116 00F0      		brlo .+2
 1103 0118 00C0      		rjmp .L75
 1104 011a 00C0      		rjmp .L182
 1105               	.L106:
 303:tmk_core/common/action.c ****                             unregister_mods(mods);
 1106               		.loc 1 303 0
 1107 011c 1530      		cpi r17,lo8(5)
 1108 011e 00F0      		brlo .+2
 1109 0120 00C0      		rjmp .L75
 1110 0122 00C0      		rjmp .L110
 1111               	.L187:
 309:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1112               		.loc 1 309 0
 1113 0124 DD23      		tst r29
 1114 0126 01F0      		breq .L107
 310:tmk_core/common/action.c **** #    ifndef IGNORE_MOD_TAP_INTERRUPT
 1115               		.loc 1 310 0
 1116 0128 1123      		tst r17
 1117 012a 01F0      		breq .L182
 312:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 1118               		.loc 1 312 0
 1119 012c F701      		movw r30,r14
 1120 012e 8581      		ldd r24,Z+5
 1121 0130 80FF      		sbrs r24,0
 1122 0132 00C0      		rjmp .L181
 315:tmk_core/common/action.c ****                                 register_mods(mods);
 1123               		.loc 1 315 0
 1124 0134 8F70      		andi r24,lo8(15)
 1125 0136 8583      		std Z+5,r24
 1126               	.L182:
 316:tmk_core/common/action.c ****                             } else
 1127               		.loc 1 316 0
 1128 0138 8C2F      		mov r24,r28
 1129               	.L180:
 1130 013a 0E94 0000 		call register_mods
 1131               	.LVL100:
 1132 013e 00C0      		rjmp .L75
 1133               	.L107:
 328:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1134               		.loc 1 328 0
 1135 0140 1123      		tst r17
 1136 0142 01F0      		breq .L110
 330:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1137               		.loc 1 330 0
 1138 0144 0933      		cpi r16,lo8(57)
 1139 0146 01F0      		breq .+2
 1140 0148 00C0      		rjmp .L147
 1141               	.LVL101:
 1142               	.LBB88:
 1143               	.LBB89:
 1144               		.loc 3 187 0
 1145 014a FFEF      		ldi r31,lo8(255999)
 1146 014c 27EE      		ldi r18,hi8(255999)
 1147 014e 83E0      		ldi r24,hlo8(255999)
 1148 0150 F150      	1:	subi r31,1
 1149 0152 2040      		sbci r18,0
 1150 0154 8040      		sbci r24,0
 1151 0156 01F4      		brne 1b
 1152 0158 00C0      		rjmp .L186
 1153               	.LVL102:
 1154               	.L110:
 1155               	.LBE89:
 1156               	.LBE88:
 336:tmk_core/common/action.c ****                         }
 1157               		.loc 1 336 0
 1158 015a 8C2F      		mov r24,r28
 1159 015c 0E94 0000 		call unregister_mods
 1160               	.LVL103:
 1161 0160 00C0      		rjmp .L75
 1162               	.LVL104:
 1163               	.L79:
 1164               	.LBE87:
 346:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1165               		.loc 1 346 0
 1166 0162 8C2F      		mov r24,r28
 1167 0164 8695      		lsr r24
 1168 0166 8695      		lsr r24
 1169 0168 8370      		andi r24,lo8(3)
 1170 016a 01F0      		breq .L112
 1171 016c 8130      		cpi r24,lo8(1)
 1172 016e 01F0      		breq .L113
 1173 0170 00C0      		rjmp .L75
 1174               	.L112:
 348:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1175               		.loc 1 348 0
 1176 0172 DD23      		tst r29
 1177 0174 01F0      		breq .L114
 349:tmk_core/common/action.c ****                     } else {
 1178               		.loc 1 349 0
 1179 0176 802F      		mov r24,r16
 1180 0178 9C2F      		mov r25,r28
 1181 017a 9370      		andi r25,lo8(3)
 1182 017c 00C0      		rjmp .L183
 1183               	.L114:
 351:tmk_core/common/action.c ****                     }
 1184               		.loc 1 351 0
 1185 017e 80E0      		ldi r24,0
 1186 0180 90E0      		ldi r25,0
 1187               	.L183:
 1188 0182 0E94 0000 		call host_system_send
 1189               	.LVL105:
 1190 0186 00C0      		rjmp .L148
 1191               	.L113:
 355:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1192               		.loc 1 355 0
 1193 0188 DD23      		tst r29
 1194 018a 01F0      		breq .L116
 356:tmk_core/common/action.c ****                     } else {
 1195               		.loc 1 356 0
 1196 018c 802F      		mov r24,r16
 1197 018e 9C2F      		mov r25,r28
 1198 0190 9370      		andi r25,lo8(3)
 1199 0192 00C0      		rjmp .L184
 1200               	.L116:
 358:tmk_core/common/action.c ****                     }
 1201               		.loc 1 358 0
 1202 0194 80E0      		ldi r24,0
 1203 0196 90E0      		ldi r25,0
 1204               	.L184:
 1205 0198 0E94 0000 		call host_consumer_send
 1206               	.LVL106:
 1207 019c 00C0      		rjmp .L148
 1208               	.L80:
 404:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1209               		.loc 1 404 0
 1210 019e 8C2F      		mov r24,r28
 1211 01a0 8370      		andi r24,lo8(3)
 1212 01a2 01F0      		breq .+2
 1213 01a4 00C0      		rjmp .L117
 406:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1214               		.loc 1 406 0
 1215 01a6 D111      		cpse r29,__zero_reg__
 1216 01a8 00C0      		rjmp .L149
 1217               	.LVL107:
 1218               	.LBB90:
 407:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1219               		.loc 1 407 0
 1220 01aa 402F      		mov r20,r16
 1221 01ac 4295      		swap r20
 1222 01ae 4695      		lsr r20
 1223 01b0 4770      		andi r20,lo8(7)
 408:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1224               		.loc 1 408 0
 1225 01b2 440F      		lsl r20
 1226 01b4 440F      		lsl r20
 1227 01b6 602F      		mov r22,r16
 1228 01b8 6F70      		andi r22,lo8(15)
 1229 01ba 862F      		mov r24,r22
 1230 01bc 90E0      		ldi r25,0
 1231 01be A0E0      		ldi r26,0
 1232 01c0 B0E0      		ldi r27,0
 1233 01c2 042E      		mov r0,r20
 1234 01c4 00C0      		rjmp 2f
 1235               		1:
 1236 01c6 880F      		lsl r24
 1237 01c8 991F      		rol r25
 1238 01ca AA1F      		rol r26
 1239 01cc BB1F      		rol r27
 1240               		2:
 1241 01ce 0A94      		dec r0
 1242 01d0 02F4      		brpl 1b
 1243               	.LVL108:
 409:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1244               		.loc 1 409 0
 1245 01d2 04FF      		sbrs r16,4
 1246 01d4 00C0      		rjmp .L156
 409:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1247               		.loc 1 409 0 is_stmt 0 discriminator 1
 1248 01d6 0FE0      		ldi r16,lo8(15)
 1249 01d8 10E0      		ldi r17,0
 1250 01da 20E0      		ldi r18,0
 1251 01dc 30E0      		ldi r19,0
 1252               	.LVL109:
 1253 01de 00C0      		rjmp 2f
 1254               		1:
 1255 01e0 000F      		lsl r16
 1256 01e2 111F      		rol r17
 1257 01e4 221F      		rol r18
 1258 01e6 331F      		rol r19
 1259               		2:
 1260 01e8 4A95      		dec r20
 1261 01ea 02F4      		brpl 1b
 1262 01ec 0095      		com r16
 1263 01ee 1095      		com r17
 1264 01f0 2095      		com r18
 1265 01f2 3095      		com r19
 1266 01f4 00C0      		rjmp .L119
 1267               	.LVL110:
 1268               	.L156:
 409:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1269               		.loc 1 409 0
 1270 01f6 00E0      		ldi r16,0
 1271 01f8 10E0      		ldi r17,0
 1272 01fa 9801      		movw r18,r16
 1273               	.LVL111:
 1274               	.L119:
 410:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1275               		.loc 1 410 0 is_stmt 1 discriminator 4
 1276 01fc C695      		lsr r28
 1277 01fe C695      		lsr r28
 1278 0200 C370      		andi r28,lo8(3)
 1279 0202 BC01      		movw r22,r24
 1280 0204 CD01      		movw r24,r26
 1281 0206 602B      		or r22,r16
 1282 0208 712B      		or r23,r17
 1283 020a 822B      		or r24,r18
 1284 020c 932B      		or r25,r19
 1285 020e C230      		cpi r28,lo8(2)
 1286 0210 01F0      		breq .L121
 1287 0212 00F4      		brsh .L122
 1288 0214 C130      		cpi r28,lo8(1)
 1289 0216 01F0      		breq .L123
 412:tmk_core/common/action.c ****                             break;
 1290               		.loc 1 412 0 discriminator 4
 1291 0218 0E94 0000 		call default_layer_and
 1292               	.LVL112:
 413:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1293               		.loc 1 413 0 discriminator 4
 1294 021c 00C0      		rjmp .L149
 1295               	.LVL113:
 1296               	.L123:
 415:tmk_core/common/action.c ****                             break;
 1297               		.loc 1 415 0
 1298 021e 0E94 0000 		call default_layer_or
 1299               	.LVL114:
 416:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1300               		.loc 1 416 0
 1301 0222 00C0      		rjmp .L149
 1302               	.LVL115:
 1303               	.L121:
 418:tmk_core/common/action.c ****                             break;
 1304               		.loc 1 418 0
 1305 0224 0E94 0000 		call default_layer_xor
 1306               	.LVL116:
 419:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1307               		.loc 1 419 0
 1308 0228 00C0      		rjmp .L149
 1309               	.LVL117:
 1310               	.L122:
 421:tmk_core/common/action.c ****                             break;
 1311               		.loc 1 421 0
 1312 022a 0E94 0000 		call default_layer_set
 1313               	.LVL118:
 422:tmk_core/common/action.c ****                     }
 1314               		.loc 1 422 0
 1315 022e 00C0      		rjmp .L149
 1316               	.LVL119:
 1317               	.L117:
 1318               	.LBE90:
 427:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1319               		.loc 1 427 0
 1320 0230 DD23      		tst r29
 1321 0232 01F0      		breq .L124
 427:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1322               		.loc 1 427 0 is_stmt 0 discriminator 1
 1323 0234 8C2F      		mov r24,r28
 1324 0236 8170      		andi r24,lo8(1)
 1325 0238 00C0      		rjmp .L125
 1326               	.L124:
 427:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1327               		.loc 1 427 0 discriminator 2
 1328 023a 8695      		lsr r24
 1329               	.L125:
 427:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1330               		.loc 1 427 0 discriminator 4
 1331 023c 8823      		tst r24
 1332 023e 01F4      		brne .+2
 1333 0240 00C0      		rjmp .L149
 1334               	.LVL120:
 1335               	.LBB91:
 428:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1336               		.loc 1 428 0 is_stmt 1
 1337 0242 402F      		mov r20,r16
 1338 0244 4295      		swap r20
 1339 0246 4695      		lsr r20
 1340 0248 4770      		andi r20,lo8(7)
 429:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1341               		.loc 1 429 0
 1342 024a 440F      		lsl r20
 1343 024c 440F      		lsl r20
 1344 024e 602F      		mov r22,r16
 1345 0250 6F70      		andi r22,lo8(15)
 1346 0252 862F      		mov r24,r22
 1347 0254 90E0      		ldi r25,0
 1348 0256 A0E0      		ldi r26,0
 1349 0258 B0E0      		ldi r27,0
 1350 025a 042E      		mov r0,r20
 1351 025c 00C0      		rjmp 2f
 1352               		1:
 1353 025e 880F      		lsl r24
 1354 0260 991F      		rol r25
 1355 0262 AA1F      		rol r26
 1356 0264 BB1F      		rol r27
 1357               		2:
 1358 0266 0A94      		dec r0
 1359 0268 02F4      		brpl 1b
 1360               	.LVL121:
 430:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1361               		.loc 1 430 0
 1362 026a 04FF      		sbrs r16,4
 1363 026c 00C0      		rjmp .L157
 430:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1364               		.loc 1 430 0 is_stmt 0 discriminator 1
 1365 026e 0FE0      		ldi r16,lo8(15)
 1366 0270 10E0      		ldi r17,0
 1367 0272 20E0      		ldi r18,0
 1368 0274 30E0      		ldi r19,0
 1369               	.LVL122:
 1370 0276 00C0      		rjmp 2f
 1371               		1:
 1372 0278 000F      		lsl r16
 1373 027a 111F      		rol r17
 1374 027c 221F      		rol r18
 1375 027e 331F      		rol r19
 1376               		2:
 1377 0280 4A95      		dec r20
 1378 0282 02F4      		brpl 1b
 1379 0284 0095      		com r16
 1380 0286 1095      		com r17
 1381 0288 2095      		com r18
 1382 028a 3095      		com r19
 1383 028c 00C0      		rjmp .L126
 1384               	.LVL123:
 1385               	.L157:
 430:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1386               		.loc 1 430 0
 1387 028e 00E0      		ldi r16,0
 1388 0290 10E0      		ldi r17,0
 1389 0292 9801      		movw r18,r16
 1390               	.LVL124:
 1391               	.L126:
 431:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1392               		.loc 1 431 0 is_stmt 1 discriminator 4
 1393 0294 C695      		lsr r28
 1394 0296 C695      		lsr r28
 1395 0298 C370      		andi r28,lo8(3)
 1396 029a BC01      		movw r22,r24
 1397 029c CD01      		movw r24,r26
 1398 029e 602B      		or r22,r16
 1399 02a0 712B      		or r23,r17
 1400 02a2 822B      		or r24,r18
 1401 02a4 932B      		or r25,r19
 1402 02a6 C230      		cpi r28,lo8(2)
 1403 02a8 01F0      		breq .L128
 1404 02aa 00F4      		brsh .L129
 1405 02ac C130      		cpi r28,lo8(1)
 1406 02ae 01F0      		breq .L130
 433:tmk_core/common/action.c ****                             break;
 1407               		.loc 1 433 0 discriminator 4
 1408 02b0 0E94 0000 		call layer_and
 1409               	.LVL125:
 434:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1410               		.loc 1 434 0 discriminator 4
 1411 02b4 00C0      		rjmp .L149
 1412               	.LVL126:
 1413               	.L130:
 436:tmk_core/common/action.c ****                             break;
 1414               		.loc 1 436 0
 1415 02b6 0E94 0000 		call layer_or
 1416               	.LVL127:
 437:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1417               		.loc 1 437 0
 1418 02ba 00C0      		rjmp .L149
 1419               	.LVL128:
 1420               	.L128:
 439:tmk_core/common/action.c ****                             break;
 1421               		.loc 1 439 0
 1422 02bc 0E94 0000 		call layer_xor
 1423               	.LVL129:
 440:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1424               		.loc 1 440 0
 1425 02c0 00C0      		rjmp .L149
 1426               	.LVL130:
 1427               	.L129:
 442:tmk_core/common/action.c ****                             break;
 1428               		.loc 1 442 0
 1429 02c2 0E94 0000 		call layer_state_set
 1430               	.LVL131:
 443:tmk_core/common/action.c ****                     }
 1431               		.loc 1 443 0
 1432 02c6 00C0      		rjmp .L149
 1433               	.LVL132:
 1434               	.L81:
 1435 02c8 CF70      		andi r28,lo8(15)
 1436               	.LVL133:
 1437               	.LBE91:
 449:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1438               		.loc 1 449 0
 1439 02ca DD23      		tst r29
 1440 02cc 01F0      		breq .L131
 450:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1441               		.loc 1 450 0
 1442 02ce 8C2F      		mov r24,r28
 1443 02d0 0E94 0000 		call layer_on
 1444               	.LVL134:
 451:tmk_core/common/action.c ****             } else {
 1445               		.loc 1 451 0
 1446 02d4 802F      		mov r24,r16
 1447 02d6 0E94 0000 		call register_mods
 1448               	.LVL135:
 1449 02da 00C0      		rjmp .L149
 1450               	.L131:
 453:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1451               		.loc 1 453 0
 1452 02dc 802F      		mov r24,r16
 1453 02de 0E94 0000 		call unregister_mods
 1454               	.LVL136:
 454:tmk_core/common/action.c ****             }
 1455               		.loc 1 454 0
 1456 02e2 8C2F      		mov r24,r28
 1457 02e4 0E94 0000 		call layer_off
 1458               	.LVL137:
 1459 02e8 00C0      		rjmp .L149
 1460               	.LVL138:
 1461               	.L82:
 460:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1462               		.loc 1 460 0
 1463 02ea 023F      		cpi r16,lo8(-14)
 1464 02ec 01F0      		breq .L133
 1465 02ee 00F4      		brsh .L134
 1466 02f0 003F      		cpi r16,lo8(-16)
 1467 02f2 01F0      		breq .L135
 1468 02f4 013F      		cpi r16,lo8(-15)
 1469 02f6 01F0      		breq .L136
 1470 02f8 00C0      		rjmp .L132
 1471               	.L134:
 1472 02fa 033F      		cpi r16,lo8(-13)
 1473 02fc 01F0      		breq .L137
 1474 02fe 043F      		cpi r16,lo8(-12)
 1475 0300 01F0      		breq .L138
 1476 0302 00C0      		rjmp .L132
 1477               	.L135:
 463:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1478               		.loc 1 463 0
 1479 0304 DD23      		tst r29
 1480 0306 01F0      		breq .L139
 464:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1481               		.loc 1 464 0
 1482 0308 1530      		cpi r17,lo8(5)
 1483 030a 00F0      		brlo .+2
 1484 030c 00C0      		rjmp .L75
 1485               	.L140:
 465:tmk_core/common/action.c ****                         }
 1486               		.loc 1 465 0
 1487 030e 8C2F      		mov r24,r28
 1488 0310 8F71      		andi r24,lo8(31)
 1489 0312 0E94 0000 		call layer_invert
 1490               	.LVL139:
 1491 0316 00C0      		rjmp .L75
 1492               	.L139:
 468:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1493               		.loc 1 468 0
 1494 0318 1630      		cpi r17,lo8(6)
 1495 031a 00F0      		brlo .+2
 1496 031c 00C0      		rjmp .L75
 1497 031e 00C0      		rjmp .L140
 1498               	.L136:
 474:tmk_core/common/action.c ****                     break;
 1499               		.loc 1 474 0
 1500 0320 DD23      		tst r29
 1501 0322 01F0      		breq .L141
 1502               	.L142:
 474:tmk_core/common/action.c ****                     break;
 1503               		.loc 1 474 0 is_stmt 0 discriminator 1
 1504 0324 8C2F      		mov r24,r28
 1505 0326 8F71      		andi r24,lo8(31)
 1506 0328 0E94 0000 		call layer_on
 1507               	.LVL140:
 1508 032c 00C0      		rjmp .L75
 1509               	.L133:
 477:tmk_core/common/action.c ****                     break;
 1510               		.loc 1 477 0 is_stmt 1
 1511 032e DD23      		tst r29
 1512 0330 01F0      		breq .L142
 1513               	.L141:
 474:tmk_core/common/action.c ****                     break;
 1514               		.loc 1 474 0 discriminator 2
 1515 0332 8C2F      		mov r24,r28
 1516 0334 8F71      		andi r24,lo8(31)
 1517 0336 0E94 0000 		call layer_off
 1518               	.LVL141:
 1519 033a 00C0      		rjmp .L75
 1520               	.L137:
 480:tmk_core/common/action.c ****                     break;
 1521               		.loc 1 480 0
 1522 033c DD23      		tst r29
 1523 033e 01F0      		breq .L143
 480:tmk_core/common/action.c ****                     break;
 1524               		.loc 1 480 0 is_stmt 0 discriminator 1
 1525 0340 8C2F      		mov r24,r28
 1526 0342 8F71      		andi r24,lo8(31)
 1527 0344 0E94 0000 		call layer_move
 1528               	.LVL142:
 1529 0348 00C0      		rjmp .L75
 1530               	.L143:
 480:tmk_core/common/action.c ****                     break;
 1531               		.loc 1 480 0 discriminator 2
 1532 034a 0E94 0000 		call layer_clear
 1533               	.LVL143:
 1534 034e 00C0      		rjmp .L75
 1535               	.L138:
 508:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1536               		.loc 1 508 0 is_stmt 1
 1537 0350 DD23      		tst r29
 1538 0352 01F0      		breq .L144
 509:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1539               		.loc 1 509 0
 1540 0354 CF71      		andi r28,lo8(31)
 1541               	.LVL144:
 1542 0356 8C2F      		mov r24,r28
 1543 0358 0E94 0000 		call layer_on
 1544               	.LVL145:
 510:tmk_core/common/action.c ****                     } else {
 1545               		.loc 1 510 0
 1546 035c 63E0      		ldi r22,lo8(3)
 1547 035e 8C2F      		mov r24,r28
 1548 0360 0E94 0000 		call set_oneshot_layer
 1549               	.LVL146:
 1550 0364 00C0      		rjmp .L75
 1551               	.LVL147:
 1552               	.L144:
 512:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1553               		.loc 1 512 0
 1554 0366 81E0      		ldi r24,lo8(1)
 1555 0368 0E94 0000 		call clear_oneshot_layer_state
 1556               	.LVL148:
 513:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1557               		.loc 1 513 0
 1558 036c 1230      		cpi r17,lo8(2)
 1559 036e 00F0      		brlo .L75
 514:tmk_core/common/action.c ****                         }
 1560               		.loc 1 514 0
 1561 0370 82E0      		ldi r24,lo8(2)
 1562 0372 0E94 0000 		call clear_oneshot_layer_state
 1563               	.LVL149:
 1564 0376 00C0      		rjmp .L75
 1565               	.L132:
 522:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1566               		.loc 1 522 0
 1567 0378 DD23      		tst r29
 1568 037a 01F0      		breq .L145
 523:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1569               		.loc 1 523 0
 1570 037c 1123      		tst r17
 1571 037e 01F0      		breq .L142
 1572               	.L181:
 525:tmk_core/common/action.c ****                         } else {
 1573               		.loc 1 525 0
 1574 0380 802F      		mov r24,r16
 1575 0382 0E94 0000 		call register_code
 1576               	.LVL150:
 1577 0386 00C0      		rjmp .L75
 1578               	.L145:
 531:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1579               		.loc 1 531 0
 1580 0388 1123      		tst r17
 1581 038a 01F0      		breq .L141
 533:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1582               		.loc 1 533 0
 1583 038c 0933      		cpi r16,lo8(57)
 1584 038e 01F4      		brne .L147
 1585               	.LVL151:
 1586               	.LBB92:
 1587               	.LBB93:
 1588               		.loc 3 187 0
 1589 0390 9FEF      		ldi r25,lo8(255999)
 1590 0392 E7EE      		ldi r30,hi8(255999)
 1591 0394 F3E0      		ldi r31,hlo8(255999)
 1592 0396 9150      	1:	subi r25,1
 1593 0398 E040      		sbci r30,0
 1594 039a F040      		sbci r31,0
 1595 039c 01F4      		brne 1b
 1596               	.LVL152:
 1597               	.L186:
 1598 039e 00C0      		rjmp .
 1599 03a0 0000      		nop
 1600               	.L147:
 1601               	.LBE93:
 1602               	.LBE92:
 538:tmk_core/common/action.c ****                         } else {
 1603               		.loc 1 538 0
 1604 03a2 802F      		mov r24,r16
 1605 03a4 0E94 0000 		call unregister_code
 1606               	.LVL153:
 1607 03a8 00C0      		rjmp .L75
 1608               	.L83:
 552:tmk_core/common/action.c ****             break;
 1609               		.loc 1 552 0
 1610 03aa 4C2F      		mov r20,r28
 1611 03ac 4F70      		andi r20,lo8(15)
 1612 03ae 602F      		mov r22,r16
 1613 03b0 C701      		movw r24,r14
 1614 03b2 0E94 0000 		call action_get_macro
 1615               	.LVL154:
 1616 03b6 0E94 0000 		call action_macro_play
 1617               	.LVL155:
 553:tmk_core/common/action.c **** #endif
 1618               		.loc 1 553 0
 1619 03ba 00C0      		rjmp .L148
 1620               	.L84:
 648:tmk_core/common/action.c ****             break;
 1621               		.loc 1 648 0
 1622 03bc 4C2F      		mov r20,r28
 1623 03be 4F70      		andi r20,lo8(15)
 1624 03c0 602F      		mov r22,r16
 1625 03c2 C701      		movw r24,r14
 1626 03c4 0E94 0000 		call action_function
 1627               	.LVL156:
 649:tmk_core/common/action.c **** #endif
 1628               		.loc 1 649 0
 1629 03c8 00C0      		rjmp .L148
 1630               	.L75:
 657:tmk_core/common/action.c ****         case ACT_LAYER:
 1631               		.loc 1 657 0
 1632 03ca 88EF      		ldi r24,lo8(-8)
 1633 03cc 8C0D      		add r24,r12
 1634 03ce 8430      		cpi r24,lo8(4)
 1635 03d0 00F4      		brsh .L148
 1636               	.L149:
 664:tmk_core/common/action.c ****             break;
 1637               		.loc 1 664 0
 1638 03d2 0E94 0000 		call host_keyboard_leds
 1639               	.LVL157:
 1640 03d6 0E94 0000 		call led_set
 1641               	.LVL158:
 1642               	.L148:
 699:tmk_core/common/action.c ****         record->event.pressed = false;
 1643               		.loc 1 699 0
 1644 03da DD20      		tst r13
 1645 03dc 01F0      		breq .L72
 699:tmk_core/common/action.c ****         record->event.pressed = false;
 1646               		.loc 1 699 0 is_stmt 0 discriminator 1
 1647 03de 0E94 0000 		call get_oneshot_layer_state
 1648               	.LVL159:
 1649 03e2 80FD      		sbrc r24,0
 1650 03e4 00C0      		rjmp .L72
 700:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1651               		.loc 1 700 0 is_stmt 1
 1652 03e6 F701      		movw r30,r14
 1653 03e8 1282      		std Z+2,__zero_reg__
 701:tmk_core/common/action.c ****         process_record(record);
 1654               		.loc 1 701 0
 1655 03ea 0E94 0000 		call get_oneshot_layer
 1656               	.LVL160:
 1657 03ee 0E94 0000 		call layer_on
 1658               	.LVL161:
 702:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 1659               		.loc 1 702 0
 1660 03f2 C701      		movw r24,r14
 1661 03f4 0E94 0000 		call process_record
 1662               	.LVL162:
 703:tmk_core/common/action.c ****     }
 1663               		.loc 1 703 0
 1664 03f8 0E94 0000 		call get_oneshot_layer
 1665               	.LVL163:
 1666               	/* epilogue start */
 706:tmk_core/common/action.c **** 
 1667               		.loc 1 706 0
 1668 03fc DF91      		pop r29
 1669               	.LVL164:
 1670 03fe CF91      		pop r28
 1671               	.LVL165:
 1672 0400 1F91      		pop r17
 1673               	.LVL166:
 1674 0402 0F91      		pop r16
 1675 0404 FF90      		pop r15
 1676 0406 EF90      		pop r14
 1677               	.LVL167:
 1678 0408 DF90      		pop r13
 1679               	.LVL168:
 1680 040a CF90      		pop r12
 703:tmk_core/common/action.c ****     }
 1681               		.loc 1 703 0
 1682 040c 0C94 0000 		jmp layer_off
 1683               	.LVL169:
 1684               	.L72:
 1685               	/* epilogue start */
 706:tmk_core/common/action.c **** 
 1686               		.loc 1 706 0
 1687 0410 DF91      		pop r29
 1688               	.LVL170:
 1689 0412 CF91      		pop r28
 1690               	.LVL171:
 1691 0414 1F91      		pop r17
 1692               	.LVL172:
 1693 0416 0F91      		pop r16
 1694 0418 FF90      		pop r15
 1695 041a EF90      		pop r14
 1696               	.LVL173:
 1697 041c DF90      		pop r13
 1698               	.LVL174:
 1699 041e CF90      		pop r12
 1700 0420 0895      		ret
 1701               		.cfi_endproc
 1702               	.LFE18:
 1704               		.section	.text.process_record,"ax",@progbits
 1705               	.global	process_record
 1707               	process_record:
 1708               	.LFB17:
 175:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1709               		.loc 1 175 0
 1710               		.cfi_startproc
 1711               	.LVL175:
 1712 0000 0F93      		push r16
 1713               	.LCFI13:
 1714               		.cfi_def_cfa_offset 3
 1715               		.cfi_offset 16, -2
 1716 0002 1F93      		push r17
 1717               	.LCFI14:
 1718               		.cfi_def_cfa_offset 4
 1719               		.cfi_offset 17, -3
 1720 0004 CF93      		push r28
 1721               	.LCFI15:
 1722               		.cfi_def_cfa_offset 5
 1723               		.cfi_offset 28, -4
 1724 0006 DF93      		push r29
 1725               	.LCFI16:
 1726               		.cfi_def_cfa_offset 6
 1727               		.cfi_offset 29, -5
 1728               	/* prologue: function */
 1729               	/* frame size = 0 */
 1730               	/* stack size = 4 */
 1731               	.L__stack_usage = 4
 1732 0008 EC01      		movw r28,r24
 1733 000a 9881      		ld r25,Y
 1734 000c 8981      		ldd r24,Y+1
 1735               	.LVL176:
 1736               	.LBB96:
 1737               	.LBB97:
 1738               		.file 4 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  25:tmk_core/common/keyboard.h **** extern "C" {
  26:tmk_core/common/keyboard.h **** #endif
  27:tmk_core/common/keyboard.h **** 
  28:tmk_core/common/keyboard.h **** /* key matrix position */
  29:tmk_core/common/keyboard.h **** typedef struct {
  30:tmk_core/common/keyboard.h ****     uint8_t col;
  31:tmk_core/common/keyboard.h ****     uint8_t row;
  32:tmk_core/common/keyboard.h **** } keypos_t;
  33:tmk_core/common/keyboard.h **** 
  34:tmk_core/common/keyboard.h **** /* key event */
  35:tmk_core/common/keyboard.h **** typedef struct {
  36:tmk_core/common/keyboard.h ****     keypos_t key;
  37:tmk_core/common/keyboard.h ****     bool     pressed;
  38:tmk_core/common/keyboard.h ****     uint16_t time;
  39:tmk_core/common/keyboard.h **** } keyevent_t;
  40:tmk_core/common/keyboard.h **** 
  41:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  42:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  43:tmk_core/common/keyboard.h **** 
  44:tmk_core/common/keyboard.h **** /* Rules for No Event:
  45:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  46:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  47:tmk_core/common/keyboard.h ****  */
  48:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1739               		.loc 4 48 0
 1740 000e 2B81      		ldd r18,Y+3
 1741 0010 3C81      		ldd r19,Y+4
 1742 0012 232B      		or r18,r19
 1743 0014 01F0      		breq .L193
 1744 0016 8F3F      		cpi r24,lo8(-1)
 1745 0018 01F4      		brne .L194
 1746 001a 81E0      		ldi r24,lo8(1)
 1747 001c 9F3F      		cpi r25,lo8(-1)
 1748 001e 01F4      		brne .L194
 1749 0020 00C0      		rjmp .L189
 1750               	.L193:
 1751 0022 81E0      		ldi r24,lo8(1)
 1752 0024 00C0      		rjmp .L189
 1753               	.L194:
 1754 0026 80E0      		ldi r24,0
 1755               	.L189:
 1756               	.LBE97:
 1757               	.LBE96:
 176:tmk_core/common/action.c ****         return;
 1758               		.loc 1 176 0
 1759 0028 80FD      		sbrc r24,0
 1760 002a 00C0      		rjmp .L188
 180:tmk_core/common/action.c **** 
 1761               		.loc 1 180 0
 1762 002c CE01      		movw r24,r28
 1763 002e 0E94 0000 		call process_record_quantum
 1764               	.LVL177:
 1765 0032 8823      		tst r24
 1766 0034 01F0      		breq .L188
 182:tmk_core/common/action.c ****     dprint("ACTION: ");
 1767               		.loc 1 182 0
 1768 0036 6881      		ld r22,Y
 1769 0038 7981      		ldd r23,Y+1
 1770 003a 8A81      		ldd r24,Y+2
 1771 003c 0E94 0000 		call store_or_get_action
 1772               	.LVL178:
 1773 0040 8C01      		movw r16,r24
 1774               	.LVL179:
 187:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 1775               		.loc 1 187 0
 1776 0042 0E94 0000 		call layer_debug
 1777               	.LVL180:
 189:tmk_core/common/action.c **** #endif
 1778               		.loc 1 189 0
 1779 0046 0E94 0000 		call default_layer_debug
 1780               	.LVL181:
 193:tmk_core/common/action.c **** }
 1781               		.loc 1 193 0
 1782 004a B801      		movw r22,r16
 1783 004c CE01      		movw r24,r28
 1784 004e 0E94 0000 		call process_action
 1785               	.LVL182:
 1786               	.L188:
 1787               	/* epilogue start */
 194:tmk_core/common/action.c **** 
 1788               		.loc 1 194 0
 1789 0052 DF91      		pop r29
 1790 0054 CF91      		pop r28
 1791               	.LVL183:
 1792 0056 1F91      		pop r17
 1793 0058 0F91      		pop r16
 1794               	.LVL184:
 1795 005a 0895      		ret
 1796               		.cfi_endproc
 1797               	.LFE17:
 1799               		.section	.text.process_record_nocache,"ax",@progbits
 1800               	.global	process_record_nocache
 1802               	process_record_nocache:
 1803               	.LFB14:
 137:tmk_core/common/action.c ****     disable_action_cache = true;
 1804               		.loc 1 137 0
 1805               		.cfi_startproc
 1806               	.LVL185:
 1807               	/* prologue: function */
 1808               	/* frame size = 0 */
 1809               	/* stack size = 0 */
 1810               	.L__stack_usage = 0
 138:tmk_core/common/action.c ****     process_record(record);
 1811               		.loc 1 138 0
 1812 0000 21E0      		ldi r18,lo8(1)
 1813 0002 2093 0000 		sts disable_action_cache,r18
 139:tmk_core/common/action.c ****     disable_action_cache = false;
 1814               		.loc 1 139 0
 1815 0006 0E94 0000 		call process_record
 1816               	.LVL186:
 140:tmk_core/common/action.c **** }
 1817               		.loc 1 140 0
 1818 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 1819 000e 0895      		ret
 1820               		.cfi_endproc
 1821               	.LFE14:
 1823               		.section	.text.register_weak_mods,"ax",@progbits
 1824               	.global	register_weak_mods
 1826               	register_weak_mods:
 1827               	.LFB24:
 893:tmk_core/common/action.c ****     }
 894:tmk_core/common/action.c **** }
 895:tmk_core/common/action.c **** 
 896:tmk_core/common/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 897:tmk_core/common/action.c ****  *
 898:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 899:tmk_core/common/action.c ****  */
 900:tmk_core/common/action.c **** void register_weak_mods(uint8_t mods) {
 1828               		.loc 1 900 0
 1829               		.cfi_startproc
 1830               	.LVL187:
 1831               	/* prologue: function */
 1832               	/* frame size = 0 */
 1833               	/* stack size = 0 */
 1834               	.L__stack_usage = 0
 901:tmk_core/common/action.c ****     if (mods) {
 1835               		.loc 1 901 0
 1836 0000 8823      		tst r24
 1837 0002 01F0      		breq .L202
 902:tmk_core/common/action.c ****         add_weak_mods(mods);
 1838               		.loc 1 902 0
 1839 0004 0E94 0000 		call add_weak_mods
 1840               	.LVL188:
 903:tmk_core/common/action.c ****         send_keyboard_report();
 1841               		.loc 1 903 0
 1842 0008 0C94 0000 		jmp send_keyboard_report
 1843               	.LVL189:
 1844               	.L202:
 1845 000c 0895      		ret
 1846               		.cfi_endproc
 1847               	.LFE24:
 1849               		.section	.text.unregister_weak_mods,"ax",@progbits
 1850               	.global	unregister_weak_mods
 1852               	unregister_weak_mods:
 1853               	.LFB25:
 904:tmk_core/common/action.c ****     }
 905:tmk_core/common/action.c **** }
 906:tmk_core/common/action.c **** 
 907:tmk_core/common/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 908:tmk_core/common/action.c ****  *
 909:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 910:tmk_core/common/action.c ****  */
 911:tmk_core/common/action.c **** void unregister_weak_mods(uint8_t mods) {
 1854               		.loc 1 911 0
 1855               		.cfi_startproc
 1856               	.LVL190:
 1857               	/* prologue: function */
 1858               	/* frame size = 0 */
 1859               	/* stack size = 0 */
 1860               	.L__stack_usage = 0
 912:tmk_core/common/action.c ****     if (mods) {
 1861               		.loc 1 912 0
 1862 0000 8823      		tst r24
 1863 0002 01F0      		breq .L204
 913:tmk_core/common/action.c ****         del_weak_mods(mods);
 1864               		.loc 1 913 0
 1865 0004 0E94 0000 		call del_weak_mods
 1866               	.LVL191:
 914:tmk_core/common/action.c ****         send_keyboard_report();
 1867               		.loc 1 914 0
 1868 0008 0C94 0000 		jmp send_keyboard_report
 1869               	.LVL192:
 1870               	.L204:
 1871 000c 0895      		ret
 1872               		.cfi_endproc
 1873               	.LFE25:
 1875               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 1876               	.global	clear_keyboard_but_mods_and_keys
 1878               	clear_keyboard_but_mods_and_keys:
 1879               	.LFB28:
 915:tmk_core/common/action.c ****     }
 916:tmk_core/common/action.c **** }
 917:tmk_core/common/action.c **** 
 918:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 919:tmk_core/common/action.c ****  *
 920:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 921:tmk_core/common/action.c ****  */
 922:tmk_core/common/action.c **** void clear_keyboard(void) {
 923:tmk_core/common/action.c ****     clear_mods();
 924:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 925:tmk_core/common/action.c **** }
 926:tmk_core/common/action.c **** 
 927:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 928:tmk_core/common/action.c ****  *
 929:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 930:tmk_core/common/action.c ****  */
 931:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
 932:tmk_core/common/action.c ****     clear_keys();
 933:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 934:tmk_core/common/action.c **** }
 935:tmk_core/common/action.c **** 
 936:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 937:tmk_core/common/action.c ****  *
 938:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 939:tmk_core/common/action.c ****  */
 940:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 1880               		.loc 1 940 0
 1881               		.cfi_startproc
 1882               	/* prologue: function */
 1883               	/* frame size = 0 */
 1884               	/* stack size = 0 */
 1885               	.L__stack_usage = 0
 941:tmk_core/common/action.c ****     clear_weak_mods();
 1886               		.loc 1 941 0
 1887 0000 0E94 0000 		call clear_weak_mods
 1888               	.LVL193:
 942:tmk_core/common/action.c ****     clear_macro_mods();
 1889               		.loc 1 942 0
 1890 0004 0E94 0000 		call clear_macro_mods
 1891               	.LVL194:
 943:tmk_core/common/action.c ****     send_keyboard_report();
 1892               		.loc 1 943 0
 1893 0008 0E94 0000 		call send_keyboard_report
 1894               	.LVL195:
 944:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 945:tmk_core/common/action.c ****     mousekey_clear();
 946:tmk_core/common/action.c ****     mousekey_send();
 947:tmk_core/common/action.c **** #endif
 948:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 949:tmk_core/common/action.c ****     host_system_send(0);
 1895               		.loc 1 949 0
 1896 000c 80E0      		ldi r24,0
 1897 000e 90E0      		ldi r25,0
 1898 0010 0E94 0000 		call host_system_send
 1899               	.LVL196:
 950:tmk_core/common/action.c ****     host_consumer_send(0);
 1900               		.loc 1 950 0
 1901 0014 80E0      		ldi r24,0
 1902 0016 90E0      		ldi r25,0
 1903 0018 0C94 0000 		jmp host_consumer_send
 1904               	.LVL197:
 1905               		.cfi_endproc
 1906               	.LFE28:
 1908               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 1909               	.global	clear_keyboard_but_mods
 1911               	clear_keyboard_but_mods:
 1912               	.LFB27:
 931:tmk_core/common/action.c ****     clear_keys();
 1913               		.loc 1 931 0
 1914               		.cfi_startproc
 1915               	/* prologue: function */
 1916               	/* frame size = 0 */
 1917               	/* stack size = 0 */
 1918               	.L__stack_usage = 0
 1919               	.LBB98:
 1920               	.LBB99:
  35:tmk_core/common/action_util.h **** 
  36:tmk_core/common/action_util.h **** inline void clear_keys(void) { clear_keys_from_report(keyboard_report); }
 1921               		.loc 2 36 0
 1922 0000 8091 0000 		lds r24,keyboard_report
 1923 0004 9091 0000 		lds r25,keyboard_report+1
 1924 0008 0E94 0000 		call clear_keys_from_report
 1925               	.LVL198:
 1926               	.LBE99:
 1927               	.LBE98:
 933:tmk_core/common/action.c **** }
 1928               		.loc 1 933 0
 1929 000c 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 1930               	.LVL199:
 1931               		.cfi_endproc
 1932               	.LFE27:
 1934               		.section	.text.clear_keyboard,"ax",@progbits
 1935               	.global	clear_keyboard
 1937               	clear_keyboard:
 1938               	.LFB26:
 922:tmk_core/common/action.c ****     clear_mods();
 1939               		.loc 1 922 0
 1940               		.cfi_startproc
 1941               	/* prologue: function */
 1942               	/* frame size = 0 */
 1943               	/* stack size = 0 */
 1944               	.L__stack_usage = 0
 923:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 1945               		.loc 1 923 0
 1946 0000 0E94 0000 		call clear_mods
 1947               	.LVL200:
 924:tmk_core/common/action.c **** }
 1948               		.loc 1 924 0
 1949 0004 0C94 0000 		jmp clear_keyboard_but_mods
 1950               	.LVL201:
 1951               		.cfi_endproc
 1952               	.LFE26:
 1954               		.section	.text.is_tap_action,"ax",@progbits
 1955               	.global	is_tap_action
 1957               	is_tap_action:
 1958               	.LFB30:
 951:tmk_core/common/action.c **** #endif
 952:tmk_core/common/action.c **** }
 953:tmk_core/common/action.c **** 
 954:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 955:tmk_core/common/action.c ****  *
 956:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 957:tmk_core/common/action.c ****  */
 958:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
 959:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 960:tmk_core/common/action.c ****     return is_tap_action(action);
 961:tmk_core/common/action.c **** }
 962:tmk_core/common/action.c **** 
 963:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 964:tmk_core/common/action.c ****  *
 965:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 966:tmk_core/common/action.c ****  */
 967:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 1959               		.loc 1 967 0
 1960               		.cfi_startproc
 1961               	.LVL202:
 1962               	/* prologue: function */
 1963               	/* frame size = 0 */
 1964               	/* stack size = 0 */
 1965               	.L__stack_usage = 0
 968:tmk_core/common/action.c ****     switch (action.kind.id) {
 1966               		.loc 1 968 0
 1967 0000 E92F      		mov r30,r25
 1968 0002 E295      		swap r30
 1969 0004 EF70      		andi r30,lo8(15)
 1970 0006 4E2F      		mov r20,r30
 1971 0008 50E0      		ldi r21,0
 1972 000a FA01      		movw r30,r20
 1973 000c 3297      		sbiw r30,2
 1974 000e EE30      		cpi r30,14
 1975 0010 F105      		cpc r31,__zero_reg__
 1976 0012 00F4      		brsh .L218
 1977 0014 E050      		subi r30,lo8(-(gs(.L212)))
 1978 0016 F040      		sbci r31,hi8(-(gs(.L212)))
 1979 0018 0C94 0000 		jmp __tablejump2__
 1980               		.section	.progmem.gcc_sw_table.is_tap_action,"a",@progbits
 1981               		.p2align	1
 1982               	.L212:
 1983 0000 0000      		.word gs(.L211)
 1984 0002 0000      		.word gs(.L211)
 1985 0004 0000      		.word gs(.L218)
 1986 0006 0000      		.word gs(.L218)
 1987 0008 0000      		.word gs(.L213)
 1988 000a 0000      		.word gs(.L218)
 1989 000c 0000      		.word gs(.L218)
 1990 000e 0000      		.word gs(.L218)
 1991 0010 0000      		.word gs(.L211)
 1992 0012 0000      		.word gs(.L211)
 1993 0014 0000      		.word gs(.L214)
 1994 0016 0000      		.word gs(.L218)
 1995 0018 0000      		.word gs(.L218)
 1996 001a 0000      		.word gs(.L214)
 1997               		.section	.text.is_tap_action
 1998               	.L211:
 969:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 970:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 971:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 972:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 973:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1999               		.loc 1 973 0
 2000 001c 803F      		cpi r24,lo8(-16)
 2001 001e 01F0      		breq .L220
 2002 0020 00F4      		brsh .L216
 2003 0022 883E      		cpi r24,lo8(-24)
 2004 0024 00F4      		brsh .L218
 2005 0026 00C0      		rjmp .L220
 2006               	.L216:
 2007 0028 843F      		cpi r24,lo8(-12)
 2008 002a 01F4      		brne .L218
 2009 002c 00C0      		rjmp .L220
 2010               	.L213:
 974:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 975:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 976:tmk_core/common/action.c ****                 case OP_ONESHOT:
 977:tmk_core/common/action.c ****                     return true;
 978:tmk_core/common/action.c ****             }
 979:tmk_core/common/action.c ****             return false;
 980:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 981:tmk_core/common/action.c ****             switch (action.swap.code) {
 2011               		.loc 1 981 0
 2012 002e 883E      		cpi r24,lo8(-24)
 2013 0030 00F0      		brlo .L220
 2014 0032 813F      		cpi r24,lo8(-15)
 2015 0034 01F4      		brne .L218
 2016 0036 00C0      		rjmp .L220
 2017               	.L214:
 982:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 983:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 984:tmk_core/common/action.c ****                     return true;
 985:tmk_core/common/action.c ****             }
 986:tmk_core/common/action.c ****             return false;
 987:tmk_core/common/action.c ****         case ACT_MACRO:
 988:tmk_core/common/action.c ****         case ACT_FUNCTION:
 989:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
 2018               		.loc 1 989 0
 2019 0038 93FB      		bst r25,3
 2020 003a 8827      		clr r24
 2021 003c 80F9      		bld r24,0
 2022               	.LVL203:
 2023 003e 0895      		ret
 2024               	.LVL204:
 2025               	.L218:
 990:tmk_core/common/action.c ****                 return true;
 991:tmk_core/common/action.c ****             }
 992:tmk_core/common/action.c ****             return false;
 993:tmk_core/common/action.c ****     }
 994:tmk_core/common/action.c ****     return false;
 2026               		.loc 1 994 0
 2027 0040 80E0      		ldi r24,0
 2028               	.LVL205:
 2029 0042 0895      		ret
 2030               	.LVL206:
 2031               	.L220:
 984:tmk_core/common/action.c ****             }
 2032               		.loc 1 984 0
 2033 0044 81E0      		ldi r24,lo8(1)
 2034               	.LVL207:
 995:tmk_core/common/action.c **** }
 2035               		.loc 1 995 0
 2036 0046 0895      		ret
 2037               		.cfi_endproc
 2038               	.LFE30:
 2040               		.section	.text.is_tap_key,"ax",@progbits
 2041               	.global	is_tap_key
 2043               	is_tap_key:
 2044               	.LFB29:
 958:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 2045               		.loc 1 958 0
 2046               		.cfi_startproc
 2047               	.LVL208:
 2048               	/* prologue: function */
 2049               	/* frame size = 0 */
 2050               	/* stack size = 0 */
 2051               	.L__stack_usage = 0
 959:tmk_core/common/action.c ****     return is_tap_action(action);
 2052               		.loc 1 959 0
 2053 0000 0E94 0000 		call layer_switch_get_action
 2054               	.LVL209:
 960:tmk_core/common/action.c **** }
 2055               		.loc 1 960 0
 2056 0004 0E94 0000 		call is_tap_action
 2057               	.LVL210:
 961:tmk_core/common/action.c **** 
 2058               		.loc 1 961 0
 2059 0008 0895      		ret
 2060               		.cfi_endproc
 2061               	.LFE29:
 2063               		.section	.text.debug_event,"ax",@progbits
 2064               	.global	debug_event
 2066               	debug_event:
 2067               	.LFB31:
 996:tmk_core/common/action.c **** 
 997:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 998:tmk_core/common/action.c ****  *
 999:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1000:tmk_core/common/action.c ****  */
1001:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 2068               		.loc 1 1001 0
 2069               		.cfi_startproc
 2070 0000 CF93      		push r28
 2071               	.LCFI17:
 2072               		.cfi_def_cfa_offset 3
 2073               		.cfi_offset 28, -2
 2074 0002 DF93      		push r29
 2075               	.LCFI18:
 2076               		.cfi_def_cfa_offset 4
 2077               		.cfi_offset 29, -3
 2078 0004 00D0      		rcall .
 2079 0006 00D0      		rcall .
 2080 0008 1F92      		push __zero_reg__
 2081               	.LCFI19:
 2082               		.cfi_def_cfa_offset 9
 2083 000a CDB7      		in r28,__SP_L__
 2084 000c DEB7      		in r29,__SP_H__
 2085               	.LCFI20:
 2086               		.cfi_def_cfa_register 28
 2087               	/* prologue: function */
 2088               	/* frame size = 5 */
 2089               	/* stack size = 7 */
 2090               	.L__stack_usage = 7
 2091               	/* epilogue start */
 2092               		.loc 1 1001 0
 2093 000e 0F90      		pop __tmp_reg__
 2094 0010 0F90      		pop __tmp_reg__
 2095 0012 0F90      		pop __tmp_reg__
 2096 0014 0F90      		pop __tmp_reg__
 2097 0016 0F90      		pop __tmp_reg__
 2098 0018 DF91      		pop r29
 2099 001a CF91      		pop r28
 2100 001c 0895      		ret
 2101               		.cfi_endproc
 2102               	.LFE31:
 2104               		.section	.text.debug_record,"ax",@progbits
 2105               	.global	debug_record
 2107               	debug_record:
 2108               	.LFB32:
1002:tmk_core/common/action.c **** 
1003:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1004:tmk_core/common/action.c ****  *
1005:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1006:tmk_core/common/action.c ****  */
1007:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 2109               		.loc 1 1007 0
 2110               		.cfi_startproc
 2111 0000 CF93      		push r28
 2112               	.LCFI21:
 2113               		.cfi_def_cfa_offset 3
 2114               		.cfi_offset 28, -2
 2115 0002 DF93      		push r29
 2116               	.LCFI22:
 2117               		.cfi_def_cfa_offset 4
 2118               		.cfi_offset 29, -3
 2119 0004 00D0      		rcall .
 2120 0006 00D0      		rcall .
 2121 0008 00D0      		rcall .
 2122               	.LCFI23:
 2123               		.cfi_def_cfa_offset 10
 2124 000a CDB7      		in r28,__SP_L__
 2125 000c DEB7      		in r29,__SP_H__
 2126               	.LCFI24:
 2127               		.cfi_def_cfa_register 28
 2128               	/* prologue: function */
 2129               	/* frame size = 6 */
 2130               	/* stack size = 8 */
 2131               	.L__stack_usage = 8
 2132               	/* epilogue start */
1008:tmk_core/common/action.c ****     debug_event(record.event);
1009:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
1010:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
1011:tmk_core/common/action.c **** #endif
1012:tmk_core/common/action.c **** }
 2133               		.loc 1 1012 0
 2134 000e 2696      		adiw r28,6
 2135 0010 0FB6      		in __tmp_reg__,__SREG__
 2136 0012 F894      		cli
 2137 0014 DEBF      		out __SP_H__,r29
 2138 0016 0FBE      		out __SREG__,__tmp_reg__
 2139 0018 CDBF      		out __SP_L__,r28
 2140 001a DF91      		pop r29
 2141 001c CF91      		pop r28
 2142 001e 0895      		ret
 2143               		.cfi_endproc
 2144               	.LFE32:
 2146               		.section	.text.debug_action,"ax",@progbits
 2147               	.global	debug_action
 2149               	debug_action:
 2150               	.LFB33:
1013:tmk_core/common/action.c **** 
1014:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1015:tmk_core/common/action.c ****  *
1016:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1017:tmk_core/common/action.c ****  */
1018:tmk_core/common/action.c **** void debug_action(action_t action) {
 2151               		.loc 1 1018 0
 2152               		.cfi_startproc
 2153               	.LVL211:
 2154               	/* prologue: function */
 2155               	/* frame size = 0 */
 2156               	/* stack size = 0 */
 2157               	.L__stack_usage = 0
 2158 0000 0895      		ret
 2159               		.cfi_endproc
 2160               	.LFE33:
 2162               	.global	disable_action_cache
 2163               		.section	.bss.disable_action_cache,"aw",@nobits
 2166               	disable_action_cache:
 2167 0000 00        		.zero	1
 2168               		.comm	tp_buttons,2,1
 2169               		.text
 2170               	.Letext0:
 2171               		.file 5 "/usr/lib/avr/include/stdint.h"
 2172               		.file 6 "tmk_core/common/keycode.h"
 2173               		.file 7 "tmk_core/common/report.h"
 2174               		.file 8 "tmk_core/common/action_code.h"
 2175               		.file 9 "tmk_core/common/action.h"
 2176               		.file 10 "tmk_core/common/action_layer.h"
 2177               		.file 11 "tmk_core/common/action_tapping.h"
 2178               		.file 12 "tmk_core/common/host.h"
 2179               		.file 13 "tmk_core/common/action_macro.h"
 2180               		.file 14 "tmk_core/common/led.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
     /tmp/cclrOKXG.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cclrOKXG.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cclrOKXG.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cclrOKXG.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cclrOKXG.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cclrOKXG.s:13     .text.action_exec:0000000000000000 action_exec
     /tmp/cclrOKXG.s:93     .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/cclrOKXG.s:112    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
     /tmp/cclrOKXG.s:135    .text.register_code:0000000000000000 register_code
     /tmp/cclrOKXG.s:567    .text.unregister_code:0000000000000000 unregister_code
     /tmp/cclrOKXG.s:736    .text.tap_code:0000000000000000 tap_code
     /tmp/cclrOKXG.s:788    .text.register_mods:0000000000000000 register_mods
     /tmp/cclrOKXG.s:814    .text.unregister_mods:0000000000000000 unregister_mods
     /tmp/cclrOKXG.s:840    .text.process_action:0000000000000000 process_action
     /tmp/cclrOKXG.s:1707   .text.process_record:0000000000000000 process_record
     /tmp/cclrOKXG.s:1802   .text.process_record_nocache:0000000000000000 process_record_nocache
     /tmp/cclrOKXG.s:2166   .bss.disable_action_cache:0000000000000000 disable_action_cache
     /tmp/cclrOKXG.s:1826   .text.register_weak_mods:0000000000000000 register_weak_mods
     /tmp/cclrOKXG.s:1852   .text.unregister_weak_mods:0000000000000000 unregister_weak_mods
     /tmp/cclrOKXG.s:1878   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
     /tmp/cclrOKXG.s:1911   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
     /tmp/cclrOKXG.s:1937   .text.clear_keyboard:0000000000000000 clear_keyboard
     /tmp/cclrOKXG.s:1957   .text.is_tap_action:0000000000000000 is_tap_action
     /tmp/cclrOKXG.s:2043   .text.is_tap_key:0000000000000000 is_tap_key
     /tmp/cclrOKXG.s:2066   .text.debug_event:0000000000000000 debug_event
     /tmp/cclrOKXG.s:2107   .text.debug_record:0000000000000000 debug_record
     /tmp/cclrOKXG.s:2149   .text.debug_action:0000000000000000 debug_action
                            *COM*:0000000000000002 tp_buttons

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
host_keyboard_leds
keyboard_report
add_key_to_report
send_keyboard_report
del_key_from_report
add_mods
host_system_send
host_consumer_send
del_mods
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
layer_on
layer_off
layer_invert
layer_move
layer_clear
set_oneshot_layer
action_get_macro
action_macro_play
action_function
led_set
get_oneshot_layer_state
get_oneshot_layer
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
clear_keys_from_report
clear_mods
__do_clear_bss
