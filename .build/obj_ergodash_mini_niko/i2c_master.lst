   1               		.file	"i2c_master.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.i2c_init,"ax",@progbits
  11               	.global	i2c_init
  13               	i2c_init:
  14               	.LFB8:
  15               		.file 1 "drivers/avr/i2c_master.c"
   1:drivers/avr/i2c_master.c **** /*  Copyright (C) 2019 Elia Ritterbusch
   2:drivers/avr/i2c_master.c ****  +
   3:drivers/avr/i2c_master.c ****  *  This program is free software: you can redistribute it and/or modify
   4:drivers/avr/i2c_master.c ****  *  it under the terms of the GNU General Public License as published by
   5:drivers/avr/i2c_master.c ****  *  the Free Software Foundation, either version 3 of the License, or
   6:drivers/avr/i2c_master.c ****  *  (at your option) any later version.
   7:drivers/avr/i2c_master.c ****  *
   8:drivers/avr/i2c_master.c ****  *  This program is distributed in the hope that it will be useful,
   9:drivers/avr/i2c_master.c ****  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:drivers/avr/i2c_master.c ****  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:drivers/avr/i2c_master.c ****  *  GNU General Public License for more details.
  12:drivers/avr/i2c_master.c ****  *
  13:drivers/avr/i2c_master.c ****  *  You should have received a copy of the GNU General Public License
  14:drivers/avr/i2c_master.c ****  *  along with this program.  If not, see <https://www.gnu.org/licenses/>.
  15:drivers/avr/i2c_master.c ****  */
  16:drivers/avr/i2c_master.c **** /* Library made by: g4lvanix
  17:drivers/avr/i2c_master.c ****  * Github repository: https://github.com/g4lvanix/I2C-master-lib
  18:drivers/avr/i2c_master.c ****  */
  19:drivers/avr/i2c_master.c **** 
  20:drivers/avr/i2c_master.c **** #include <avr/io.h>
  21:drivers/avr/i2c_master.c **** #include <util/twi.h>
  22:drivers/avr/i2c_master.c **** 
  23:drivers/avr/i2c_master.c **** #include "i2c_master.h"
  24:drivers/avr/i2c_master.c **** #include "timer.h"
  25:drivers/avr/i2c_master.c **** #include "wait.h"
  26:drivers/avr/i2c_master.c **** 
  27:drivers/avr/i2c_master.c **** #ifndef F_SCL
  28:drivers/avr/i2c_master.c **** #    define F_SCL 400000UL  // SCL frequency
  29:drivers/avr/i2c_master.c **** #endif
  30:drivers/avr/i2c_master.c **** 
  31:drivers/avr/i2c_master.c **** #define TWBR_val (((F_CPU / F_SCL) - 16) / 2)
  32:drivers/avr/i2c_master.c **** 
  33:drivers/avr/i2c_master.c **** void i2c_init(void) {
  16               		.loc 1 33 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  34:drivers/avr/i2c_master.c ****     TWSR = 0; /* no prescaler */
  22               		.loc 1 34 0
  23 0000 1092 B900 		sts 185,__zero_reg__
  35:drivers/avr/i2c_master.c ****     TWBR = (uint8_t)TWBR_val;
  24               		.loc 1 35 0
  25 0004 8CE0      		ldi r24,lo8(12)
  26 0006 8093 B800 		sts 184,r24
  27 000a 0895      		ret
  28               		.cfi_endproc
  29               	.LFE8:
  31               		.section	.text.i2c_start,"ax",@progbits
  32               	.global	i2c_start
  34               	i2c_start:
  35               	.LFB9:
  36:drivers/avr/i2c_master.c **** 
  37:drivers/avr/i2c_master.c **** #ifdef __AVR_ATmega32A__
  38:drivers/avr/i2c_master.c ****     // set pull-up resistors on I2C bus pins
  39:drivers/avr/i2c_master.c ****     PORTC |= 0b11;
  40:drivers/avr/i2c_master.c **** 
  41:drivers/avr/i2c_master.c ****     // enable TWI (two-wire interface)
  42:drivers/avr/i2c_master.c ****     TWCR |= (1 << TWEN);
  43:drivers/avr/i2c_master.c **** 
  44:drivers/avr/i2c_master.c ****     // enable TWI interrupt and slave address ACK
  45:drivers/avr/i2c_master.c ****     TWCR |= (1 << TWIE);
  46:drivers/avr/i2c_master.c ****     TWCR |= (1 << TWEA);
  47:drivers/avr/i2c_master.c **** #endif
  48:drivers/avr/i2c_master.c **** }
  49:drivers/avr/i2c_master.c **** 
  50:drivers/avr/i2c_master.c **** i2c_status_t i2c_start(uint8_t address, uint16_t timeout) {
  36               		.loc 1 50 0
  37               		.cfi_startproc
  38               	.LVL0:
  39 0000 EF92      		push r14
  40               	.LCFI0:
  41               		.cfi_def_cfa_offset 3
  42               		.cfi_offset 14, -2
  43 0002 FF92      		push r15
  44               	.LCFI1:
  45               		.cfi_def_cfa_offset 4
  46               		.cfi_offset 15, -3
  47 0004 0F93      		push r16
  48               	.LCFI2:
  49               		.cfi_def_cfa_offset 5
  50               		.cfi_offset 16, -4
  51 0006 1F93      		push r17
  52               	.LCFI3:
  53               		.cfi_def_cfa_offset 6
  54               		.cfi_offset 17, -5
  55 0008 CF93      		push r28
  56               	.LCFI4:
  57               		.cfi_def_cfa_offset 7
  58               		.cfi_offset 28, -6
  59 000a DF93      		push r29
  60               	.LCFI5:
  61               		.cfi_def_cfa_offset 8
  62               		.cfi_offset 29, -7
  63               	/* prologue: function */
  64               	/* frame size = 0 */
  65               	/* stack size = 6 */
  66               	.L__stack_usage = 6
  67 000c 182F      		mov r17,r24
  68 000e EB01      		movw r28,r22
  51:drivers/avr/i2c_master.c ****     // reset TWI control register
  52:drivers/avr/i2c_master.c ****     TWCR = 0;
  69               		.loc 1 52 0
  70 0010 1092 BC00 		sts 188,__zero_reg__
  53:drivers/avr/i2c_master.c ****     // transmit START condition
  54:drivers/avr/i2c_master.c ****     TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
  71               		.loc 1 54 0
  72 0014 84EA      		ldi r24,lo8(-92)
  73               	.LVL1:
  74 0016 8093 BC00 		sts 188,r24
  55:drivers/avr/i2c_master.c **** 
  56:drivers/avr/i2c_master.c ****     uint16_t timeout_timer = timer_read();
  75               		.loc 1 56 0
  76 001a 0E94 0000 		call timer_read
  77               	.LVL2:
  78 001e 7C01      		movw r14,r24
  79               	.LVL3:
  80               	.L4:
  57:drivers/avr/i2c_master.c ****     while (!(TWCR & (1 << TWINT))) {
  81               		.loc 1 57 0
  82 0020 8091 BC00 		lds r24,188
  83 0024 87FD      		sbrc r24,7
  84 0026 00C0      		rjmp .L26
  58:drivers/avr/i2c_master.c ****         if ((timeout != I2C_TIMEOUT_INFINITE) && ((timer_read() - timeout_timer) >= timeout)) {
  85               		.loc 1 58 0
  86 0028 CF3F      		cpi r28,-1
  87 002a 8FEF      		ldi r24,-1
  88 002c D807      		cpc r29,r24
  89 002e 01F0      		breq .L4
  90               		.loc 1 58 0 is_stmt 0 discriminator 1
  91 0030 0E94 0000 		call timer_read
  92               	.LVL4:
  93 0034 8E19      		sub r24,r14
  94 0036 9F09      		sbc r25,r15
  95 0038 8C17      		cp r24,r28
  96 003a 9D07      		cpc r25,r29
  97 003c 00F0      		brlo .L4
  98               	.LVL5:
  99               	.L10:
  59:drivers/avr/i2c_master.c ****             return I2C_STATUS_TIMEOUT;
 100               		.loc 1 59 0 is_stmt 1
 101 003e 8EEF      		ldi r24,lo8(-2)
 102 0040 9FEF      		ldi r25,lo8(-1)
 103 0042 00C0      		rjmp .L5
 104               	.LVL6:
 105               	.L26:
  60:drivers/avr/i2c_master.c ****         }
  61:drivers/avr/i2c_master.c ****     }
  62:drivers/avr/i2c_master.c **** 
  63:drivers/avr/i2c_master.c ****     // check if the start condition was successfully transmitted
  64:drivers/avr/i2c_master.c ****     if (((TW_STATUS & 0xF8) != TW_START) && ((TW_STATUS & 0xF8) != TW_REP_START)) {
 106               		.loc 1 64 0
 107 0044 8091 B900 		lds r24,185
 108 0048 887F      		andi r24,lo8(-8)
 109 004a 8830      		cpi r24,lo8(8)
 110 004c 01F0      		breq .L7
 111               		.loc 1 64 0 is_stmt 0 discriminator 1
 112 004e 8091 B900 		lds r24,185
 113 0052 887F      		andi r24,lo8(-8)
 114 0054 8031      		cpi r24,lo8(16)
 115 0056 01F0      		breq .L7
 116               	.LVL7:
 117               	.L12:
  65:drivers/avr/i2c_master.c ****         return I2C_STATUS_ERROR;
 118               		.loc 1 65 0 is_stmt 1
 119 0058 8FEF      		ldi r24,lo8(-1)
 120 005a 9FEF      		ldi r25,lo8(-1)
 121 005c 00C0      		rjmp .L5
 122               	.LVL8:
 123               	.L7:
  66:drivers/avr/i2c_master.c ****     }
  67:drivers/avr/i2c_master.c **** 
  68:drivers/avr/i2c_master.c ****     // load slave address into data register
  69:drivers/avr/i2c_master.c ****     TWDR = address;
 124               		.loc 1 69 0
 125 005e 1093 BB00 		sts 187,r17
  70:drivers/avr/i2c_master.c ****     // start transmission of address
  71:drivers/avr/i2c_master.c ****     TWCR = (1 << TWINT) | (1 << TWEN);
 126               		.loc 1 71 0
 127 0062 84E8      		ldi r24,lo8(-124)
 128 0064 8093 BC00 		sts 188,r24
  72:drivers/avr/i2c_master.c **** 
  73:drivers/avr/i2c_master.c ****     timeout_timer = timer_read();
 129               		.loc 1 73 0
 130 0068 0E94 0000 		call timer_read
 131               	.LVL9:
 132 006c 8C01      		movw r16,r24
 133               	.LVL10:
 134               	.L9:
  74:drivers/avr/i2c_master.c ****     while (!(TWCR & (1 << TWINT))) {
 135               		.loc 1 74 0
 136 006e 8091 BC00 		lds r24,188
 137 0072 87FD      		sbrc r24,7
 138 0074 00C0      		rjmp .L27
  75:drivers/avr/i2c_master.c ****         if ((timeout != I2C_TIMEOUT_INFINITE) && ((timer_read() - timeout_timer) >= timeout)) {
 139               		.loc 1 75 0
 140 0076 CF3F      		cpi r28,-1
 141 0078 8FEF      		ldi r24,-1
 142 007a D807      		cpc r29,r24
 143 007c 01F0      		breq .L9
 144               		.loc 1 75 0 is_stmt 0 discriminator 1
 145 007e 0E94 0000 		call timer_read
 146               	.LVL11:
 147 0082 801B      		sub r24,r16
 148 0084 910B      		sbc r25,r17
 149 0086 8C17      		cp r24,r28
 150 0088 9D07      		cpc r25,r29
 151 008a 00F0      		brlo .L9
 152 008c 00C0      		rjmp .L10
 153               	.L27:
  76:drivers/avr/i2c_master.c ****             return I2C_STATUS_TIMEOUT;
  77:drivers/avr/i2c_master.c ****         }
  78:drivers/avr/i2c_master.c ****     }
  79:drivers/avr/i2c_master.c **** 
  80:drivers/avr/i2c_master.c ****     // check if the device has acknowledged the READ / WRITE mode
  81:drivers/avr/i2c_master.c ****     uint8_t twst = TW_STATUS & 0xF8;
 154               		.loc 1 81 0 is_stmt 1
 155 008e 8091 B900 		lds r24,185
 156 0092 887F      		andi r24,lo8(-8)
 157               	.LVL12:
  82:drivers/avr/i2c_master.c ****     if ((twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK)) {
 158               		.loc 1 82 0
 159 0094 8831      		cpi r24,lo8(24)
 160 0096 01F0      		breq .L13
 161               		.loc 1 82 0 is_stmt 0 discriminator 1
 162 0098 8034      		cpi r24,lo8(64)
 163 009a 01F4      		brne .L12
 164               	.L13:
  83:drivers/avr/i2c_master.c ****         return I2C_STATUS_ERROR;
  84:drivers/avr/i2c_master.c ****     }
  85:drivers/avr/i2c_master.c **** 
  86:drivers/avr/i2c_master.c ****     return I2C_STATUS_SUCCESS;
 165               		.loc 1 86 0 is_stmt 1
 166 009c 80E0      		ldi r24,0
 167 009e 90E0      		ldi r25,0
 168               	.LVL13:
 169               	.L5:
 170               	/* epilogue start */
  87:drivers/avr/i2c_master.c **** }
 171               		.loc 1 87 0
 172 00a0 DF91      		pop r29
 173 00a2 CF91      		pop r28
 174               	.LVL14:
 175 00a4 1F91      		pop r17
 176               	.LVL15:
 177 00a6 0F91      		pop r16
 178 00a8 FF90      		pop r15
 179 00aa EF90      		pop r14
 180 00ac 0895      		ret
 181               		.cfi_endproc
 182               	.LFE9:
 184               		.section	.text.i2c_write,"ax",@progbits
 185               	.global	i2c_write
 187               	i2c_write:
 188               	.LFB10:
  88:drivers/avr/i2c_master.c **** 
  89:drivers/avr/i2c_master.c **** i2c_status_t i2c_write(uint8_t data, uint16_t timeout) {
 189               		.loc 1 89 0
 190               		.cfi_startproc
 191               	.LVL16:
 192 0000 0F93      		push r16
 193               	.LCFI6:
 194               		.cfi_def_cfa_offset 3
 195               		.cfi_offset 16, -2
 196 0002 1F93      		push r17
 197               	.LCFI7:
 198               		.cfi_def_cfa_offset 4
 199               		.cfi_offset 17, -3
 200 0004 CF93      		push r28
 201               	.LCFI8:
 202               		.cfi_def_cfa_offset 5
 203               		.cfi_offset 28, -4
 204 0006 DF93      		push r29
 205               	.LCFI9:
 206               		.cfi_def_cfa_offset 6
 207               		.cfi_offset 29, -5
 208               	/* prologue: function */
 209               	/* frame size = 0 */
 210               	/* stack size = 4 */
 211               	.L__stack_usage = 4
 212 0008 EB01      		movw r28,r22
  90:drivers/avr/i2c_master.c ****     // load data into data register
  91:drivers/avr/i2c_master.c ****     TWDR = data;
 213               		.loc 1 91 0
 214 000a 8093 BB00 		sts 187,r24
  92:drivers/avr/i2c_master.c ****     // start transmission of data
  93:drivers/avr/i2c_master.c ****     TWCR = (1 << TWINT) | (1 << TWEN);
 215               		.loc 1 93 0
 216 000e 84E8      		ldi r24,lo8(-124)
 217               	.LVL17:
 218 0010 8093 BC00 		sts 188,r24
 219               	.LVL18:
  94:drivers/avr/i2c_master.c **** 
  95:drivers/avr/i2c_master.c ****     uint16_t timeout_timer = timer_read();
 220               		.loc 1 95 0
 221 0014 0E94 0000 		call timer_read
 222               	.LVL19:
 223 0018 8C01      		movw r16,r24
 224               	.LVL20:
 225               	.L30:
  96:drivers/avr/i2c_master.c ****     while (!(TWCR & (1 << TWINT))) {
 226               		.loc 1 96 0
 227 001a 8091 BC00 		lds r24,188
 228 001e 87FD      		sbrc r24,7
 229 0020 00C0      		rjmp .L37
  97:drivers/avr/i2c_master.c ****         if ((timeout != I2C_TIMEOUT_INFINITE) && ((timer_read() - timeout_timer) >= timeout)) {
 230               		.loc 1 97 0
 231 0022 CF3F      		cpi r28,-1
 232 0024 8FEF      		ldi r24,-1
 233 0026 D807      		cpc r29,r24
 234 0028 01F0      		breq .L30
 235               		.loc 1 97 0 is_stmt 0 discriminator 1
 236 002a 0E94 0000 		call timer_read
 237               	.LVL21:
 238 002e 801B      		sub r24,r16
 239 0030 910B      		sbc r25,r17
 240 0032 8C17      		cp r24,r28
 241 0034 9D07      		cpc r25,r29
 242 0036 00F0      		brlo .L30
  98:drivers/avr/i2c_master.c ****             return I2C_STATUS_TIMEOUT;
 243               		.loc 1 98 0 is_stmt 1
 244 0038 8EEF      		ldi r24,lo8(-2)
 245 003a 9FEF      		ldi r25,lo8(-1)
 246 003c 00C0      		rjmp .L31
 247               	.L37:
  99:drivers/avr/i2c_master.c ****         }
 100:drivers/avr/i2c_master.c ****     }
 101:drivers/avr/i2c_master.c **** 
 102:drivers/avr/i2c_master.c ****     if ((TW_STATUS & 0xF8) != TW_MT_DATA_ACK) {
 248               		.loc 1 102 0
 249 003e 2091 B900 		lds r18,185
 250 0042 287F      		andi r18,lo8(-8)
 251 0044 81E0      		ldi r24,lo8(1)
 252 0046 90E0      		ldi r25,0
 253 0048 2832      		cpi r18,lo8(40)
 254 004a 01F4      		brne .L33
 255 004c 80E0      		ldi r24,0
 256 004e 90E0      		ldi r25,0
 257               	.L33:
 258 0050 9195      		neg r25
 259 0052 8195      		neg r24
 260 0054 9109      		sbc r25,__zero_reg__
 261               	.L31:
 262               	/* epilogue start */
 103:drivers/avr/i2c_master.c ****         return I2C_STATUS_ERROR;
 104:drivers/avr/i2c_master.c ****     }
 105:drivers/avr/i2c_master.c **** 
 106:drivers/avr/i2c_master.c ****     return I2C_STATUS_SUCCESS;
 107:drivers/avr/i2c_master.c **** }
 263               		.loc 1 107 0
 264 0056 DF91      		pop r29
 265 0058 CF91      		pop r28
 266               	.LVL22:
 267 005a 1F91      		pop r17
 268 005c 0F91      		pop r16
 269               	.LVL23:
 270 005e 0895      		ret
 271               		.cfi_endproc
 272               	.LFE10:
 274               		.section	.text.i2c_read_ack,"ax",@progbits
 275               	.global	i2c_read_ack
 277               	i2c_read_ack:
 278               	.LFB11:
 108:drivers/avr/i2c_master.c **** 
 109:drivers/avr/i2c_master.c **** int16_t i2c_read_ack(uint16_t timeout) {
 279               		.loc 1 109 0
 280               		.cfi_startproc
 281               	.LVL24:
 282 0000 0F93      		push r16
 283               	.LCFI10:
 284               		.cfi_def_cfa_offset 3
 285               		.cfi_offset 16, -2
 286 0002 1F93      		push r17
 287               	.LCFI11:
 288               		.cfi_def_cfa_offset 4
 289               		.cfi_offset 17, -3
 290 0004 CF93      		push r28
 291               	.LCFI12:
 292               		.cfi_def_cfa_offset 5
 293               		.cfi_offset 28, -4
 294 0006 DF93      		push r29
 295               	.LCFI13:
 296               		.cfi_def_cfa_offset 6
 297               		.cfi_offset 29, -5
 298               	/* prologue: function */
 299               	/* frame size = 0 */
 300               	/* stack size = 4 */
 301               	.L__stack_usage = 4
 302 0008 EC01      		movw r28,r24
 110:drivers/avr/i2c_master.c ****     // start TWI module and acknowledge data after reception
 111:drivers/avr/i2c_master.c ****     TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);
 303               		.loc 1 111 0
 304 000a 84EC      		ldi r24,lo8(-60)
 305               	.LVL25:
 306 000c 8093 BC00 		sts 188,r24
 112:drivers/avr/i2c_master.c **** 
 113:drivers/avr/i2c_master.c ****     uint16_t timeout_timer = timer_read();
 307               		.loc 1 113 0
 308 0010 0E94 0000 		call timer_read
 309               	.LVL26:
 310 0014 8C01      		movw r16,r24
 311               	.LVL27:
 312               	.L40:
 114:drivers/avr/i2c_master.c ****     while (!(TWCR & (1 << TWINT))) {
 313               		.loc 1 114 0
 314 0016 8091 BC00 		lds r24,188
 315 001a 87FD      		sbrc r24,7
 316 001c 00C0      		rjmp .L46
 115:drivers/avr/i2c_master.c ****         if ((timeout != I2C_TIMEOUT_INFINITE) && ((timer_read() - timeout_timer) >= timeout)) {
 317               		.loc 1 115 0
 318 001e CF3F      		cpi r28,-1
 319 0020 8FEF      		ldi r24,-1
 320 0022 D807      		cpc r29,r24
 321 0024 01F0      		breq .L40
 322               		.loc 1 115 0 is_stmt 0 discriminator 1
 323 0026 0E94 0000 		call timer_read
 324               	.LVL28:
 325 002a 801B      		sub r24,r16
 326 002c 910B      		sbc r25,r17
 327 002e 8C17      		cp r24,r28
 328 0030 9D07      		cpc r25,r29
 329 0032 00F0      		brlo .L40
 116:drivers/avr/i2c_master.c ****             return I2C_STATUS_TIMEOUT;
 330               		.loc 1 116 0 is_stmt 1
 331 0034 8EEF      		ldi r24,lo8(-2)
 332 0036 9FEF      		ldi r25,lo8(-1)
 333 0038 00C0      		rjmp .L41
 334               	.L46:
 117:drivers/avr/i2c_master.c ****         }
 118:drivers/avr/i2c_master.c ****     }
 119:drivers/avr/i2c_master.c **** 
 120:drivers/avr/i2c_master.c ****     // return received data from TWDR
 121:drivers/avr/i2c_master.c ****     return TWDR;
 335               		.loc 1 121 0
 336 003a 8091 BB00 		lds r24,187
 337 003e 90E0      		ldi r25,0
 338               	.L41:
 339               	/* epilogue start */
 122:drivers/avr/i2c_master.c **** }
 340               		.loc 1 122 0
 341 0040 DF91      		pop r29
 342 0042 CF91      		pop r28
 343               	.LVL29:
 344 0044 1F91      		pop r17
 345 0046 0F91      		pop r16
 346               	.LVL30:
 347 0048 0895      		ret
 348               		.cfi_endproc
 349               	.LFE11:
 351               		.section	.text.i2c_read_nack,"ax",@progbits
 352               	.global	i2c_read_nack
 354               	i2c_read_nack:
 355               	.LFB12:
 123:drivers/avr/i2c_master.c **** 
 124:drivers/avr/i2c_master.c **** int16_t i2c_read_nack(uint16_t timeout) {
 356               		.loc 1 124 0
 357               		.cfi_startproc
 358               	.LVL31:
 359 0000 0F93      		push r16
 360               	.LCFI14:
 361               		.cfi_def_cfa_offset 3
 362               		.cfi_offset 16, -2
 363 0002 1F93      		push r17
 364               	.LCFI15:
 365               		.cfi_def_cfa_offset 4
 366               		.cfi_offset 17, -3
 367 0004 CF93      		push r28
 368               	.LCFI16:
 369               		.cfi_def_cfa_offset 5
 370               		.cfi_offset 28, -4
 371 0006 DF93      		push r29
 372               	.LCFI17:
 373               		.cfi_def_cfa_offset 6
 374               		.cfi_offset 29, -5
 375               	/* prologue: function */
 376               	/* frame size = 0 */
 377               	/* stack size = 4 */
 378               	.L__stack_usage = 4
 379 0008 EC01      		movw r28,r24
 125:drivers/avr/i2c_master.c ****     // start receiving without acknowledging reception
 126:drivers/avr/i2c_master.c ****     TWCR = (1 << TWINT) | (1 << TWEN);
 380               		.loc 1 126 0
 381 000a 84E8      		ldi r24,lo8(-124)
 382               	.LVL32:
 383 000c 8093 BC00 		sts 188,r24
 127:drivers/avr/i2c_master.c **** 
 128:drivers/avr/i2c_master.c ****     uint16_t timeout_timer = timer_read();
 384               		.loc 1 128 0
 385 0010 0E94 0000 		call timer_read
 386               	.LVL33:
 387 0014 8C01      		movw r16,r24
 388               	.LVL34:
 389               	.L49:
 129:drivers/avr/i2c_master.c ****     while (!(TWCR & (1 << TWINT))) {
 390               		.loc 1 129 0
 391 0016 8091 BC00 		lds r24,188
 392 001a 87FD      		sbrc r24,7
 393 001c 00C0      		rjmp .L55
 130:drivers/avr/i2c_master.c ****         if ((timeout != I2C_TIMEOUT_INFINITE) && ((timer_read() - timeout_timer) >= timeout)) {
 394               		.loc 1 130 0
 395 001e CF3F      		cpi r28,-1
 396 0020 8FEF      		ldi r24,-1
 397 0022 D807      		cpc r29,r24
 398 0024 01F0      		breq .L49
 399               		.loc 1 130 0 is_stmt 0 discriminator 1
 400 0026 0E94 0000 		call timer_read
 401               	.LVL35:
 402 002a 801B      		sub r24,r16
 403 002c 910B      		sbc r25,r17
 404 002e 8C17      		cp r24,r28
 405 0030 9D07      		cpc r25,r29
 406 0032 00F0      		brlo .L49
 131:drivers/avr/i2c_master.c ****             return I2C_STATUS_TIMEOUT;
 407               		.loc 1 131 0 is_stmt 1
 408 0034 8EEF      		ldi r24,lo8(-2)
 409 0036 9FEF      		ldi r25,lo8(-1)
 410 0038 00C0      		rjmp .L50
 411               	.L55:
 132:drivers/avr/i2c_master.c ****         }
 133:drivers/avr/i2c_master.c ****     }
 134:drivers/avr/i2c_master.c **** 
 135:drivers/avr/i2c_master.c ****     // return received data from TWDR
 136:drivers/avr/i2c_master.c ****     return TWDR;
 412               		.loc 1 136 0
 413 003a 8091 BB00 		lds r24,187
 414 003e 90E0      		ldi r25,0
 415               	.L50:
 416               	/* epilogue start */
 137:drivers/avr/i2c_master.c **** }
 417               		.loc 1 137 0
 418 0040 DF91      		pop r29
 419 0042 CF91      		pop r28
 420               	.LVL36:
 421 0044 1F91      		pop r17
 422 0046 0F91      		pop r16
 423               	.LVL37:
 424 0048 0895      		ret
 425               		.cfi_endproc
 426               	.LFE12:
 428               		.section	.text.i2c_transmit,"ax",@progbits
 429               	.global	i2c_transmit
 431               	i2c_transmit:
 432               	.LFB13:
 138:drivers/avr/i2c_master.c **** 
 139:drivers/avr/i2c_master.c **** i2c_status_t i2c_transmit(uint8_t address, const uint8_t* data, uint16_t length, uint16_t timeout) 
 433               		.loc 1 139 0
 434               		.cfi_startproc
 435               	.LVL38:
 436 0000 CF92      		push r12
 437               	.LCFI18:
 438               		.cfi_def_cfa_offset 3
 439               		.cfi_offset 12, -2
 440 0002 DF92      		push r13
 441               	.LCFI19:
 442               		.cfi_def_cfa_offset 4
 443               		.cfi_offset 13, -3
 444 0004 EF92      		push r14
 445               	.LCFI20:
 446               		.cfi_def_cfa_offset 5
 447               		.cfi_offset 14, -4
 448 0006 FF92      		push r15
 449               	.LCFI21:
 450               		.cfi_def_cfa_offset 6
 451               		.cfi_offset 15, -5
 452 0008 0F93      		push r16
 453               	.LCFI22:
 454               		.cfi_def_cfa_offset 7
 455               		.cfi_offset 16, -6
 456 000a 1F93      		push r17
 457               	.LCFI23:
 458               		.cfi_def_cfa_offset 8
 459               		.cfi_offset 17, -7
 460 000c CF93      		push r28
 461               	.LCFI24:
 462               		.cfi_def_cfa_offset 9
 463               		.cfi_offset 28, -8
 464 000e DF93      		push r29
 465               	.LCFI25:
 466               		.cfi_def_cfa_offset 10
 467               		.cfi_offset 29, -9
 468               	/* prologue: function */
 469               	/* frame size = 0 */
 470               	/* stack size = 8 */
 471               	.L__stack_usage = 8
 472 0010 6B01      		movw r12,r22
 473 0012 8A01      		movw r16,r20
 474 0014 7901      		movw r14,r18
 140:drivers/avr/i2c_master.c ****     i2c_status_t status = i2c_start(address | I2C_WRITE, timeout);
 475               		.loc 1 140 0
 476 0016 B901      		movw r22,r18
 477               	.LVL39:
 478 0018 0E94 0000 		call i2c_start
 479               	.LVL40:
 480 001c E601      		movw r28,r12
 481 001e 0C0D      		add r16,r12
 482 0020 1D1D      		adc r17,r13
 483               	.LVL41:
 484               	.L57:
 485               	.LBB5:
 141:drivers/avr/i2c_master.c **** 
 142:drivers/avr/i2c_master.c ****     for (uint16_t i = 0; i < length && status >= 0; i++) {
 486               		.loc 1 142 0 discriminator 1
 487 0022 C017      		cp r28,r16
 488 0024 D107      		cpc r29,r17
 489 0026 01F4      		brne .L58
 490               	.L60:
 491               	.LBE5:
 492               	.LBB6:
 493               	.LBB7:
 143:drivers/avr/i2c_master.c ****         status = i2c_write(data[i], timeout);
 144:drivers/avr/i2c_master.c ****     }
 145:drivers/avr/i2c_master.c **** 
 146:drivers/avr/i2c_master.c ****     i2c_stop();
 147:drivers/avr/i2c_master.c **** 
 148:drivers/avr/i2c_master.c ****     return status;
 149:drivers/avr/i2c_master.c **** }
 150:drivers/avr/i2c_master.c **** 
 151:drivers/avr/i2c_master.c **** i2c_status_t i2c_receive(uint8_t address, uint8_t* data, uint16_t length, uint16_t timeout) {
 152:drivers/avr/i2c_master.c ****     i2c_status_t status = i2c_start(address | I2C_READ, timeout);
 153:drivers/avr/i2c_master.c **** 
 154:drivers/avr/i2c_master.c ****     for (uint16_t i = 0; i < (length - 1) && status >= 0; i++) {
 155:drivers/avr/i2c_master.c ****         status = i2c_read_ack(timeout);
 156:drivers/avr/i2c_master.c ****         if (status >= 0) {
 157:drivers/avr/i2c_master.c ****             data[i] = status;
 158:drivers/avr/i2c_master.c ****         }
 159:drivers/avr/i2c_master.c ****     }
 160:drivers/avr/i2c_master.c **** 
 161:drivers/avr/i2c_master.c ****     if (status >= 0) {
 162:drivers/avr/i2c_master.c ****         status = i2c_read_nack(timeout);
 163:drivers/avr/i2c_master.c ****         if (status >= 0) {
 164:drivers/avr/i2c_master.c ****             data[(length - 1)] = status;
 165:drivers/avr/i2c_master.c ****         }
 166:drivers/avr/i2c_master.c ****     }
 167:drivers/avr/i2c_master.c **** 
 168:drivers/avr/i2c_master.c ****     i2c_stop();
 169:drivers/avr/i2c_master.c **** 
 170:drivers/avr/i2c_master.c ****     return (status < 0) ? status : I2C_STATUS_SUCCESS;
 171:drivers/avr/i2c_master.c **** }
 172:drivers/avr/i2c_master.c **** 
 173:drivers/avr/i2c_master.c **** i2c_status_t i2c_writeReg(uint8_t devaddr, uint8_t regaddr, const uint8_t* data, uint16_t length, u
 174:drivers/avr/i2c_master.c ****     i2c_status_t status = i2c_start(devaddr | 0x00, timeout);
 175:drivers/avr/i2c_master.c ****     if (status >= 0) {
 176:drivers/avr/i2c_master.c ****         status = i2c_write(regaddr, timeout);
 177:drivers/avr/i2c_master.c **** 
 178:drivers/avr/i2c_master.c ****         for (uint16_t i = 0; i < length && status >= 0; i++) {
 179:drivers/avr/i2c_master.c ****             status = i2c_write(data[i], timeout);
 180:drivers/avr/i2c_master.c ****         }
 181:drivers/avr/i2c_master.c ****     }
 182:drivers/avr/i2c_master.c **** 
 183:drivers/avr/i2c_master.c ****     i2c_stop();
 184:drivers/avr/i2c_master.c **** 
 185:drivers/avr/i2c_master.c ****     return status;
 186:drivers/avr/i2c_master.c **** }
 187:drivers/avr/i2c_master.c **** 
 188:drivers/avr/i2c_master.c **** i2c_status_t i2c_readReg(uint8_t devaddr, uint8_t regaddr, uint8_t* data, uint16_t length, uint16_t
 189:drivers/avr/i2c_master.c ****     i2c_status_t status = i2c_start(devaddr, timeout);
 190:drivers/avr/i2c_master.c ****     if (status < 0) {
 191:drivers/avr/i2c_master.c ****         goto error;
 192:drivers/avr/i2c_master.c ****     }
 193:drivers/avr/i2c_master.c **** 
 194:drivers/avr/i2c_master.c ****     status = i2c_write(regaddr, timeout);
 195:drivers/avr/i2c_master.c ****     if (status < 0) {
 196:drivers/avr/i2c_master.c ****         goto error;
 197:drivers/avr/i2c_master.c ****     }
 198:drivers/avr/i2c_master.c **** 
 199:drivers/avr/i2c_master.c ****     status = i2c_start(devaddr | 0x01, timeout);
 200:drivers/avr/i2c_master.c **** 
 201:drivers/avr/i2c_master.c ****     for (uint16_t i = 0; i < (length - 1) && status >= 0; i++) {
 202:drivers/avr/i2c_master.c ****         status = i2c_read_ack(timeout);
 203:drivers/avr/i2c_master.c ****         if (status >= 0) {
 204:drivers/avr/i2c_master.c ****             data[i] = status;
 205:drivers/avr/i2c_master.c ****         }
 206:drivers/avr/i2c_master.c ****     }
 207:drivers/avr/i2c_master.c **** 
 208:drivers/avr/i2c_master.c ****     if (status >= 0) {
 209:drivers/avr/i2c_master.c ****         status = i2c_read_nack(timeout);
 210:drivers/avr/i2c_master.c ****         if (status >= 0) {
 211:drivers/avr/i2c_master.c ****             data[(length - 1)] = status;
 212:drivers/avr/i2c_master.c ****         }
 213:drivers/avr/i2c_master.c ****     }
 214:drivers/avr/i2c_master.c **** 
 215:drivers/avr/i2c_master.c **** error:
 216:drivers/avr/i2c_master.c ****     i2c_stop();
 217:drivers/avr/i2c_master.c **** 
 218:drivers/avr/i2c_master.c ****     return (status < 0) ? status : I2C_STATUS_SUCCESS;
 219:drivers/avr/i2c_master.c **** }
 220:drivers/avr/i2c_master.c **** 
 221:drivers/avr/i2c_master.c **** void i2c_stop(void) {
 222:drivers/avr/i2c_master.c ****     // transmit STOP condition
 223:drivers/avr/i2c_master.c ****     TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
 494               		.loc 1 223 0
 495 0028 24E9      		ldi r18,lo8(-108)
 496 002a 2093 BC00 		sts 188,r18
 497               	/* epilogue start */
 498               	.LBE7:
 499               	.LBE6:
 149:drivers/avr/i2c_master.c **** 
 500               		.loc 1 149 0
 501 002e DF91      		pop r29
 502 0030 CF91      		pop r28
 503               	.LVL42:
 504 0032 1F91      		pop r17
 505 0034 0F91      		pop r16
 506 0036 FF90      		pop r15
 507 0038 EF90      		pop r14
 508               	.LVL43:
 509 003a DF90      		pop r13
 510 003c CF90      		pop r12
 511               	.LVL44:
 512 003e 0895      		ret
 513               	.LVL45:
 514               	.L58:
 515               	.LBB8:
 142:drivers/avr/i2c_master.c ****         status = i2c_write(data[i], timeout);
 516               		.loc 1 142 0 discriminator 3
 517 0040 97FD      		sbrc r25,7
 518 0042 00C0      		rjmp .L60
 143:drivers/avr/i2c_master.c ****         status = i2c_write(data[i], timeout);
 519               		.loc 1 143 0 discriminator 4
 520 0044 B701      		movw r22,r14
 521 0046 8991      		ld r24,Y+
 522               	.LVL46:
 523 0048 0E94 0000 		call i2c_write
 524               	.LVL47:
 525 004c 00C0      		rjmp .L57
 526               	.LBE8:
 527               		.cfi_endproc
 528               	.LFE13:
 530               		.section	.text.i2c_receive,"ax",@progbits
 531               	.global	i2c_receive
 533               	i2c_receive:
 534               	.LFB14:
 151:drivers/avr/i2c_master.c ****     i2c_status_t status = i2c_start(address | I2C_READ, timeout);
 535               		.loc 1 151 0
 536               		.cfi_startproc
 537               	.LVL48:
 538 0000 CF92      		push r12
 539               	.LCFI26:
 540               		.cfi_def_cfa_offset 3
 541               		.cfi_offset 12, -2
 542 0002 DF92      		push r13
 543               	.LCFI27:
 544               		.cfi_def_cfa_offset 4
 545               		.cfi_offset 13, -3
 546 0004 EF92      		push r14
 547               	.LCFI28:
 548               		.cfi_def_cfa_offset 5
 549               		.cfi_offset 14, -4
 550 0006 FF92      		push r15
 551               	.LCFI29:
 552               		.cfi_def_cfa_offset 6
 553               		.cfi_offset 15, -5
 554 0008 0F93      		push r16
 555               	.LCFI30:
 556               		.cfi_def_cfa_offset 7
 557               		.cfi_offset 16, -6
 558 000a 1F93      		push r17
 559               	.LCFI31:
 560               		.cfi_def_cfa_offset 8
 561               		.cfi_offset 17, -7
 562 000c CF93      		push r28
 563               	.LCFI32:
 564               		.cfi_def_cfa_offset 9
 565               		.cfi_offset 28, -8
 566 000e DF93      		push r29
 567               	.LCFI33:
 568               		.cfi_def_cfa_offset 10
 569               		.cfi_offset 29, -9
 570               	/* prologue: function */
 571               	/* frame size = 0 */
 572               	/* stack size = 8 */
 573               	.L__stack_usage = 8
 574 0010 7B01      		movw r14,r22
 575 0012 EA01      		movw r28,r20
 576 0014 6901      		movw r12,r18
 152:drivers/avr/i2c_master.c **** 
 577               		.loc 1 152 0
 578 0016 B901      		movw r22,r18
 579               	.LVL49:
 580 0018 8160      		ori r24,lo8(1)
 581               	.LVL50:
 582 001a 0E94 0000 		call i2c_start
 583               	.LVL51:
 584               	.LBB12:
 154:drivers/avr/i2c_master.c ****         status = i2c_read_ack(timeout);
 585               		.loc 1 154 0
 586 001e 8701      		movw r16,r14
 587 0020 2197      		sbiw r28,1
 588               	.LVL52:
 589               	.L63:
 154:drivers/avr/i2c_master.c ****         status = i2c_read_ack(timeout);
 590               		.loc 1 154 0 is_stmt 0 discriminator 1
 591 0022 9801      		movw r18,r16
 592 0024 2E19      		sub r18,r14
 593 0026 3F09      		sbc r19,r15
 594               	.LVL53:
 595 0028 2C17      		cp r18,r28
 596 002a 3D07      		cpc r19,r29
 597 002c 00F4      		brsh .L65
 154:drivers/avr/i2c_master.c ****         status = i2c_read_ack(timeout);
 598               		.loc 1 154 0 discriminator 3
 599 002e 97FD      		sbrc r25,7
 600 0030 00C0      		rjmp .L67
 155:drivers/avr/i2c_master.c ****         if (status >= 0) {
 601               		.loc 1 155 0 is_stmt 1
 602 0032 C601      		movw r24,r12
 603               	.LVL54:
 604 0034 0E94 0000 		call i2c_read_ack
 605               	.LVL55:
 156:drivers/avr/i2c_master.c ****             data[i] = status;
 606               		.loc 1 156 0
 607 0038 97FD      		sbrc r25,7
 608 003a 00C0      		rjmp .L64
 157:drivers/avr/i2c_master.c ****         }
 609               		.loc 1 157 0
 610 003c F801      		movw r30,r16
 611 003e 8083      		st Z,r24
 612               	.L64:
 613               	.LVL56:
 614 0040 0F5F      		subi r16,-1
 615 0042 1F4F      		sbci r17,-1
 616               	.LVL57:
 617 0044 00C0      		rjmp .L63
 618               	.LVL58:
 619               	.L65:
 620               	.LBE12:
 161:drivers/avr/i2c_master.c ****         status = i2c_read_nack(timeout);
 621               		.loc 1 161 0
 622 0046 97FD      		sbrc r25,7
 623 0048 00C0      		rjmp .L67
 162:drivers/avr/i2c_master.c ****         if (status >= 0) {
 624               		.loc 1 162 0
 625 004a C601      		movw r24,r12
 626               	.LVL59:
 627 004c 0E94 0000 		call i2c_read_nack
 628               	.LVL60:
 163:drivers/avr/i2c_master.c ****             data[(length - 1)] = status;
 629               		.loc 1 163 0
 630 0050 97FD      		sbrc r25,7
 631 0052 00C0      		rjmp .L67
 164:drivers/avr/i2c_master.c ****         }
 632               		.loc 1 164 0
 633 0054 CE0D      		add r28,r14
 634 0056 DF1D      		adc r29,r15
 635               	.LVL61:
 636 0058 8883      		st Y,r24
 637               	.L67:
 638               	.LBB13:
 639               	.LBB14:
 640               		.loc 1 223 0
 641 005a 24E9      		ldi r18,lo8(-108)
 642 005c 2093 BC00 		sts 188,r18
 643               	.LBE14:
 644               	.LBE13:
 170:drivers/avr/i2c_master.c **** }
 645               		.loc 1 170 0
 646 0060 1816      		cp __zero_reg__,r24
 647 0062 1906      		cpc __zero_reg__,r25
 648 0064 04F4      		brge .L68
 649 0066 80E0      		ldi r24,0
 650 0068 90E0      		ldi r25,0
 651               	.LVL62:
 652               	.L68:
 653               	/* epilogue start */
 171:drivers/avr/i2c_master.c **** 
 654               		.loc 1 171 0
 655 006a DF91      		pop r29
 656 006c CF91      		pop r28
 657 006e 1F91      		pop r17
 658 0070 0F91      		pop r16
 659               	.LVL63:
 660 0072 FF90      		pop r15
 661 0074 EF90      		pop r14
 662               	.LVL64:
 663 0076 DF90      		pop r13
 664 0078 CF90      		pop r12
 665               	.LVL65:
 666 007a 0895      		ret
 667               		.cfi_endproc
 668               	.LFE14:
 670               		.section	.text.i2c_writeReg,"ax",@progbits
 671               	.global	i2c_writeReg
 673               	i2c_writeReg:
 674               	.LFB15:
 173:drivers/avr/i2c_master.c ****     i2c_status_t status = i2c_start(devaddr | 0x00, timeout);
 675               		.loc 1 173 0
 676               		.cfi_startproc
 677               	.LVL66:
 678 0000 CF92      		push r12
 679               	.LCFI34:
 680               		.cfi_def_cfa_offset 3
 681               		.cfi_offset 12, -2
 682 0002 DF92      		push r13
 683               	.LCFI35:
 684               		.cfi_def_cfa_offset 4
 685               		.cfi_offset 13, -3
 686 0004 EF92      		push r14
 687               	.LCFI36:
 688               		.cfi_def_cfa_offset 5
 689               		.cfi_offset 14, -4
 690 0006 FF92      		push r15
 691               	.LCFI37:
 692               		.cfi_def_cfa_offset 6
 693               		.cfi_offset 15, -5
 694 0008 0F93      		push r16
 695               	.LCFI38:
 696               		.cfi_def_cfa_offset 7
 697               		.cfi_offset 16, -6
 698 000a 1F93      		push r17
 699               	.LCFI39:
 700               		.cfi_def_cfa_offset 8
 701               		.cfi_offset 17, -7
 702 000c CF93      		push r28
 703               	.LCFI40:
 704               		.cfi_def_cfa_offset 9
 705               		.cfi_offset 28, -8
 706 000e DF93      		push r29
 707               	.LCFI41:
 708               		.cfi_def_cfa_offset 10
 709               		.cfi_offset 29, -9
 710               	/* prologue: function */
 711               	/* frame size = 0 */
 712               	/* stack size = 8 */
 713               	.L__stack_usage = 8
 714 0010 C62F      		mov r28,r22
 715 0012 6A01      		movw r12,r20
 716 0014 7901      		movw r14,r18
 174:drivers/avr/i2c_master.c ****     if (status >= 0) {
 717               		.loc 1 174 0
 718 0016 B801      		movw r22,r16
 719               	.LVL67:
 720 0018 0E94 0000 		call i2c_start
 721               	.LVL68:
 175:drivers/avr/i2c_master.c ****         status = i2c_write(regaddr, timeout);
 722               		.loc 1 175 0
 723 001c 97FD      		sbrc r25,7
 724 001e 00C0      		rjmp .L70
 176:drivers/avr/i2c_master.c **** 
 725               		.loc 1 176 0
 726 0020 B801      		movw r22,r16
 727 0022 8C2F      		mov r24,r28
 728               	.LVL69:
 729 0024 0E94 0000 		call i2c_write
 730               	.LVL70:
 731 0028 E601      		movw r28,r12
 732               	.LVL71:
 733 002a EC0C      		add r14,r12
 734 002c FD1C      		adc r15,r13
 735               	.LVL72:
 736               	.L71:
 737               	.LBB18:
 178:drivers/avr/i2c_master.c ****             status = i2c_write(data[i], timeout);
 738               		.loc 1 178 0 discriminator 1
 739 002e CE15      		cp r28,r14
 740 0030 DF05      		cpc r29,r15
 741 0032 01F0      		breq .L70
 178:drivers/avr/i2c_master.c ****             status = i2c_write(data[i], timeout);
 742               		.loc 1 178 0 is_stmt 0 discriminator 3
 743 0034 97FD      		sbrc r25,7
 744 0036 00C0      		rjmp .L70
 179:drivers/avr/i2c_master.c ****         }
 745               		.loc 1 179 0 is_stmt 1 discriminator 4
 746 0038 B801      		movw r22,r16
 747 003a 8991      		ld r24,Y+
 748               	.LVL73:
 749 003c 0E94 0000 		call i2c_write
 750               	.LVL74:
 751 0040 00C0      		rjmp .L71
 752               	.LVL75:
 753               	.L70:
 754               	.LBE18:
 755               	.LBB19:
 756               	.LBB20:
 757               		.loc 1 223 0
 758 0042 24E9      		ldi r18,lo8(-108)
 759 0044 2093 BC00 		sts 188,r18
 760               	/* epilogue start */
 761               	.LBE20:
 762               	.LBE19:
 186:drivers/avr/i2c_master.c **** 
 763               		.loc 1 186 0
 764 0048 DF91      		pop r29
 765 004a CF91      		pop r28
 766 004c 1F91      		pop r17
 767 004e 0F91      		pop r16
 768               	.LVL76:
 769 0050 FF90      		pop r15
 770 0052 EF90      		pop r14
 771 0054 DF90      		pop r13
 772 0056 CF90      		pop r12
 773               	.LVL77:
 774 0058 0895      		ret
 775               		.cfi_endproc
 776               	.LFE15:
 778               		.section	.text.i2c_readReg,"ax",@progbits
 779               	.global	i2c_readReg
 781               	i2c_readReg:
 782               	.LFB16:
 188:drivers/avr/i2c_master.c ****     i2c_status_t status = i2c_start(devaddr, timeout);
 783               		.loc 1 188 0
 784               		.cfi_startproc
 785               	.LVL78:
 786 0000 CF92      		push r12
 787               	.LCFI42:
 788               		.cfi_def_cfa_offset 3
 789               		.cfi_offset 12, -2
 790 0002 DF92      		push r13
 791               	.LCFI43:
 792               		.cfi_def_cfa_offset 4
 793               		.cfi_offset 13, -3
 794 0004 EF92      		push r14
 795               	.LCFI44:
 796               		.cfi_def_cfa_offset 5
 797               		.cfi_offset 14, -4
 798 0006 FF92      		push r15
 799               	.LCFI45:
 800               		.cfi_def_cfa_offset 6
 801               		.cfi_offset 15, -5
 802 0008 0F93      		push r16
 803               	.LCFI46:
 804               		.cfi_def_cfa_offset 7
 805               		.cfi_offset 16, -6
 806 000a 1F93      		push r17
 807               	.LCFI47:
 808               		.cfi_def_cfa_offset 8
 809               		.cfi_offset 17, -7
 810 000c CF93      		push r28
 811               	.LCFI48:
 812               		.cfi_def_cfa_offset 9
 813               		.cfi_offset 28, -8
 814 000e DF93      		push r29
 815               	.LCFI49:
 816               		.cfi_def_cfa_offset 10
 817               		.cfi_offset 29, -9
 818               	/* prologue: function */
 819               	/* frame size = 0 */
 820               	/* stack size = 8 */
 821               	.L__stack_usage = 8
 822 0010 D82E      		mov r13,r24
 823 0012 C62E      		mov r12,r22
 824 0014 7A01      		movw r14,r20
 825 0016 E901      		movw r28,r18
 189:drivers/avr/i2c_master.c ****     if (status < 0) {
 826               		.loc 1 189 0
 827 0018 B801      		movw r22,r16
 828               	.LVL79:
 829 001a 0E94 0000 		call i2c_start
 830               	.LVL80:
 190:drivers/avr/i2c_master.c ****         goto error;
 831               		.loc 1 190 0
 832 001e 97FD      		sbrc r25,7
 833 0020 00C0      		rjmp .L74
 194:drivers/avr/i2c_master.c ****     if (status < 0) {
 834               		.loc 1 194 0
 835 0022 B801      		movw r22,r16
 836 0024 8C2D      		mov r24,r12
 837               	.LVL81:
 838 0026 0E94 0000 		call i2c_write
 839               	.LVL82:
 195:drivers/avr/i2c_master.c ****         goto error;
 840               		.loc 1 195 0
 841 002a 97FD      		sbrc r25,7
 842 002c 00C0      		rjmp .L74
 199:drivers/avr/i2c_master.c **** 
 843               		.loc 1 199 0
 844 002e B801      		movw r22,r16
 845 0030 8D2D      		mov r24,r13
 846               	.LVL83:
 847 0032 8160      		ori r24,lo8(1)
 848 0034 0E94 0000 		call i2c_start
 849               	.LVL84:
 850               	.LBB24:
 201:drivers/avr/i2c_master.c ****         status = i2c_read_ack(timeout);
 851               		.loc 1 201 0
 852 0038 6701      		movw r12,r14
 853               	.LVL85:
 854 003a 2197      		sbiw r28,1
 855               	.LVL86:
 856               	.L75:
 201:drivers/avr/i2c_master.c ****         status = i2c_read_ack(timeout);
 857               		.loc 1 201 0 is_stmt 0 discriminator 1
 858 003c 9601      		movw r18,r12
 859 003e 2E19      		sub r18,r14
 860 0040 3F09      		sbc r19,r15
 861               	.LVL87:
 862 0042 2C17      		cp r18,r28
 863 0044 3D07      		cpc r19,r29
 864 0046 00F4      		brsh .L77
 201:drivers/avr/i2c_master.c ****         status = i2c_read_ack(timeout);
 865               		.loc 1 201 0 discriminator 3
 866 0048 97FD      		sbrc r25,7
 867 004a 00C0      		rjmp .L74
 202:drivers/avr/i2c_master.c ****         if (status >= 0) {
 868               		.loc 1 202 0 is_stmt 1
 869 004c C801      		movw r24,r16
 870               	.LVL88:
 871 004e 0E94 0000 		call i2c_read_ack
 872               	.LVL89:
 203:drivers/avr/i2c_master.c ****             data[i] = status;
 873               		.loc 1 203 0
 874 0052 97FD      		sbrc r25,7
 875 0054 00C0      		rjmp .L76
 204:drivers/avr/i2c_master.c ****         }
 876               		.loc 1 204 0
 877 0056 F601      		movw r30,r12
 878 0058 8083      		st Z,r24
 879               	.L76:
 880               	.LVL90:
 881 005a FFEF      		ldi r31,-1
 882 005c CF1A      		sub r12,r31
 883 005e DF0A      		sbc r13,r31
 884               	.LVL91:
 885 0060 00C0      		rjmp .L75
 886               	.LVL92:
 887               	.L77:
 888               	.LBE24:
 208:drivers/avr/i2c_master.c ****         status = i2c_read_nack(timeout);
 889               		.loc 1 208 0
 890 0062 97FD      		sbrc r25,7
 891 0064 00C0      		rjmp .L74
 209:drivers/avr/i2c_master.c ****         if (status >= 0) {
 892               		.loc 1 209 0
 893 0066 C801      		movw r24,r16
 894               	.LVL93:
 895 0068 0E94 0000 		call i2c_read_nack
 896               	.LVL94:
 210:drivers/avr/i2c_master.c ****             data[(length - 1)] = status;
 897               		.loc 1 210 0
 898 006c 97FD      		sbrc r25,7
 899 006e 00C0      		rjmp .L74
 211:drivers/avr/i2c_master.c ****         }
 900               		.loc 1 211 0
 901 0070 CE0D      		add r28,r14
 902 0072 DF1D      		adc r29,r15
 903               	.LVL95:
 904 0074 8883      		st Y,r24
 905               	.LVL96:
 906               	.L74:
 907               	.LBB25:
 908               	.LBB26:
 909               		.loc 1 223 0
 910 0076 24E9      		ldi r18,lo8(-108)
 911 0078 2093 BC00 		sts 188,r18
 912               	.LBE26:
 913               	.LBE25:
 218:drivers/avr/i2c_master.c **** }
 914               		.loc 1 218 0
 915 007c 1816      		cp __zero_reg__,r24
 916 007e 1906      		cpc __zero_reg__,r25
 917 0080 04F4      		brge .L79
 918 0082 80E0      		ldi r24,0
 919 0084 90E0      		ldi r25,0
 920               	.LVL97:
 921               	.L79:
 922               	/* epilogue start */
 219:drivers/avr/i2c_master.c **** 
 923               		.loc 1 219 0
 924 0086 DF91      		pop r29
 925 0088 CF91      		pop r28
 926 008a 1F91      		pop r17
 927 008c 0F91      		pop r16
 928               	.LVL98:
 929 008e FF90      		pop r15
 930 0090 EF90      		pop r14
 931               	.LVL99:
 932 0092 DF90      		pop r13
 933               	.LVL100:
 934 0094 CF90      		pop r12
 935 0096 0895      		ret
 936               		.cfi_endproc
 937               	.LFE16:
 939               		.section	.text.i2c_stop,"ax",@progbits
 940               	.global	i2c_stop
 942               	i2c_stop:
 943               	.LFB17:
 221:drivers/avr/i2c_master.c ****     // transmit STOP condition
 944               		.loc 1 221 0
 945               		.cfi_startproc
 946               	/* prologue: function */
 947               	/* frame size = 0 */
 948               	/* stack size = 0 */
 949               	.L__stack_usage = 0
 950               		.loc 1 223 0
 951 0000 84E9      		ldi r24,lo8(-108)
 952 0002 8093 BC00 		sts 188,r24
 953 0006 0895      		ret
 954               		.cfi_endproc
 955               	.LFE17:
 957               		.text
 958               	.Letext0:
 959               		.file 2 "/usr/lib/avr/include/stdint.h"
 960               		.file 3 "drivers/avr/i2c_master.h"
 961               		.file 4 "tmk_core/common/timer.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 i2c_master.c
     /tmp/cclImwN4.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cclImwN4.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cclImwN4.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cclImwN4.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cclImwN4.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cclImwN4.s:13     .text.i2c_init:0000000000000000 i2c_init
     /tmp/cclImwN4.s:34     .text.i2c_start:0000000000000000 i2c_start
     /tmp/cclImwN4.s:187    .text.i2c_write:0000000000000000 i2c_write
     /tmp/cclImwN4.s:277    .text.i2c_read_ack:0000000000000000 i2c_read_ack
     /tmp/cclImwN4.s:354    .text.i2c_read_nack:0000000000000000 i2c_read_nack
     /tmp/cclImwN4.s:431    .text.i2c_transmit:0000000000000000 i2c_transmit
     /tmp/cclImwN4.s:533    .text.i2c_receive:0000000000000000 i2c_receive
     /tmp/cclImwN4.s:673    .text.i2c_writeReg:0000000000000000 i2c_writeReg
     /tmp/cclImwN4.s:781    .text.i2c_readReg:0000000000000000 i2c_readReg
     /tmp/cclImwN4.s:942    .text.i2c_stop:0000000000000000 i2c_stop

UNDEFINED SYMBOLS
timer_read
