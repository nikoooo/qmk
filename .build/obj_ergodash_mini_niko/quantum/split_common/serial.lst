   1               		.file	"serial.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.sync_recv,"ax",@progbits
  12               	sync_recv:
  13               	.LFB16:
  14               		.file 1 "quantum/split_common/serial.c"
   1:quantum/split_common/serial.c **** /*
   2:quantum/split_common/serial.c ****  * WARNING: be careful changing this code, it is very timing dependent
   3:quantum/split_common/serial.c ****  *
   4:quantum/split_common/serial.c ****  * 2018-10-28 checked
   5:quantum/split_common/serial.c ****  *  avr-gcc 4.9.2
   6:quantum/split_common/serial.c ****  *  avr-gcc 5.4.0
   7:quantum/split_common/serial.c ****  *  avr-gcc 7.3.0
   8:quantum/split_common/serial.c ****  */
   9:quantum/split_common/serial.c **** 
  10:quantum/split_common/serial.c **** #ifndef F_CPU
  11:quantum/split_common/serial.c **** #    define F_CPU 16000000
  12:quantum/split_common/serial.c **** #endif
  13:quantum/split_common/serial.c **** 
  14:quantum/split_common/serial.c **** #include <avr/io.h>
  15:quantum/split_common/serial.c **** #include <avr/interrupt.h>
  16:quantum/split_common/serial.c **** #include <util/delay.h>
  17:quantum/split_common/serial.c **** #include <stddef.h>
  18:quantum/split_common/serial.c **** #include <stdbool.h>
  19:quantum/split_common/serial.c **** #include "serial.h"
  20:quantum/split_common/serial.c **** 
  21:quantum/split_common/serial.c **** #ifdef SOFT_SERIAL_PIN
  22:quantum/split_common/serial.c **** 
  23:quantum/split_common/serial.c **** #    ifdef __AVR_ATmega32U4__
  24:quantum/split_common/serial.c **** // if using ATmega32U4 I2C, can not use PD0 and PD1 in soft serial.
  25:quantum/split_common/serial.c **** #        ifdef USE_AVR_I2C
  26:quantum/split_common/serial.c **** #            if SOFT_SERIAL_PIN == D0 || SOFT_SERIAL_PIN == D1
  27:quantum/split_common/serial.c **** #                error Using ATmega32U4 I2C, so can not use PD0, PD1
  28:quantum/split_common/serial.c **** #            endif
  29:quantum/split_common/serial.c **** #        endif
  30:quantum/split_common/serial.c **** 
  31:quantum/split_common/serial.c **** #        define setPinInputHigh(pin) (DDRx_ADDRESS(pin) &= ~_BV((pin)&0xF), PORTx_ADDRESS(pin) |= _
  32:quantum/split_common/serial.c **** #        define setPinOutput(pin) (DDRx_ADDRESS(pin) |= _BV((pin)&0xF))
  33:quantum/split_common/serial.c **** #        define writePinHigh(pin) (PORTx_ADDRESS(pin) |= _BV((pin)&0xF))
  34:quantum/split_common/serial.c **** #        define writePinLow(pin) (PORTx_ADDRESS(pin) &= ~_BV((pin)&0xF))
  35:quantum/split_common/serial.c **** #        define readPin(pin) ((bool)(PINx_ADDRESS(pin) & _BV((pin)&0xF)))
  36:quantum/split_common/serial.c **** 
  37:quantum/split_common/serial.c **** #        if SOFT_SERIAL_PIN >= D0 && SOFT_SERIAL_PIN <= D3
  38:quantum/split_common/serial.c **** #            if SOFT_SERIAL_PIN == D0
  39:quantum/split_common/serial.c **** #                define EIMSK_BIT _BV(INT0)
  40:quantum/split_common/serial.c **** #                define EICRx_BIT (~(_BV(ISC00) | _BV(ISC01)))
  41:quantum/split_common/serial.c **** #                define SERIAL_PIN_INTERRUPT INT0_vect
  42:quantum/split_common/serial.c **** #            elif SOFT_SERIAL_PIN == D1
  43:quantum/split_common/serial.c **** #                define EIMSK_BIT _BV(INT1)
  44:quantum/split_common/serial.c **** #                define EICRx_BIT (~(_BV(ISC10) | _BV(ISC11)))
  45:quantum/split_common/serial.c **** #                define SERIAL_PIN_INTERRUPT INT1_vect
  46:quantum/split_common/serial.c **** #            elif SOFT_SERIAL_PIN == D2
  47:quantum/split_common/serial.c **** #                define EIMSK_BIT _BV(INT2)
  48:quantum/split_common/serial.c **** #                define EICRx_BIT (~(_BV(ISC20) | _BV(ISC21)))
  49:quantum/split_common/serial.c **** #                define SERIAL_PIN_INTERRUPT INT2_vect
  50:quantum/split_common/serial.c **** #            elif SOFT_SERIAL_PIN == D3
  51:quantum/split_common/serial.c **** #                define EIMSK_BIT _BV(INT3)
  52:quantum/split_common/serial.c **** #                define EICRx_BIT (~(_BV(ISC30) | _BV(ISC31)))
  53:quantum/split_common/serial.c **** #                define SERIAL_PIN_INTERRUPT INT3_vect
  54:quantum/split_common/serial.c **** #            endif
  55:quantum/split_common/serial.c **** #        elif SOFT_SERIAL_PIN == E6
  56:quantum/split_common/serial.c **** #            define EIMSK_BIT _BV(INT6)
  57:quantum/split_common/serial.c **** #            define EICRx_BIT (~(_BV(ISC60) | _BV(ISC61)))
  58:quantum/split_common/serial.c **** #            define SERIAL_PIN_INTERRUPT INT6_vect
  59:quantum/split_common/serial.c **** #        else
  60:quantum/split_common/serial.c **** #            error invalid SOFT_SERIAL_PIN value
  61:quantum/split_common/serial.c **** #        endif
  62:quantum/split_common/serial.c **** 
  63:quantum/split_common/serial.c **** #    else
  64:quantum/split_common/serial.c **** #        error serial.c now support ATmega32U4 only
  65:quantum/split_common/serial.c **** #    endif
  66:quantum/split_common/serial.c **** 
  67:quantum/split_common/serial.c **** #    define ALWAYS_INLINE __attribute__((always_inline))
  68:quantum/split_common/serial.c **** #    define NO_INLINE __attribute__((noinline))
  69:quantum/split_common/serial.c **** #    define _delay_sub_us(x) __builtin_avr_delay_cycles(x)
  70:quantum/split_common/serial.c **** 
  71:quantum/split_common/serial.c **** // parity check
  72:quantum/split_common/serial.c **** #    define ODD_PARITY 1
  73:quantum/split_common/serial.c **** #    define EVEN_PARITY 0
  74:quantum/split_common/serial.c **** #    define PARITY EVEN_PARITY
  75:quantum/split_common/serial.c **** 
  76:quantum/split_common/serial.c **** #    ifdef SERIAL_DELAY
  77:quantum/split_common/serial.c **** // custom setup in config.h
  78:quantum/split_common/serial.c **** // #define TID_SEND_ADJUST 2
  79:quantum/split_common/serial.c **** // #define SERIAL_DELAY 6             // micro sec
  80:quantum/split_common/serial.c **** // #define READ_WRITE_START_ADJUST 30 // cycles
  81:quantum/split_common/serial.c **** // #define READ_WRITE_WIDTH_ADJUST 8 // cycles
  82:quantum/split_common/serial.c **** #    else
  83:quantum/split_common/serial.c **** // ============ Standard setups ============
  84:quantum/split_common/serial.c **** 
  85:quantum/split_common/serial.c **** #        ifndef SELECT_SOFT_SERIAL_SPEED
  86:quantum/split_common/serial.c **** #            define SELECT_SOFT_SERIAL_SPEED 1
  87:quantum/split_common/serial.c **** //  0: about 189kbps (Experimental only)
  88:quantum/split_common/serial.c **** //  1: about 137kbps (default)
  89:quantum/split_common/serial.c **** //  2: about 75kbps
  90:quantum/split_common/serial.c **** //  3: about 39kbps
  91:quantum/split_common/serial.c **** //  4: about 26kbps
  92:quantum/split_common/serial.c **** //  5: about 20kbps
  93:quantum/split_common/serial.c **** #        endif
  94:quantum/split_common/serial.c **** 
  95:quantum/split_common/serial.c **** #        if __GNUC__ < 6
  96:quantum/split_common/serial.c **** #            define TID_SEND_ADJUST 14
  97:quantum/split_common/serial.c **** #        else
  98:quantum/split_common/serial.c **** #            define TID_SEND_ADJUST 2
  99:quantum/split_common/serial.c **** #        endif
 100:quantum/split_common/serial.c **** 
 101:quantum/split_common/serial.c **** #        if SELECT_SOFT_SERIAL_SPEED == 0
 102:quantum/split_common/serial.c **** // Very High speed
 103:quantum/split_common/serial.c **** #            define SERIAL_DELAY 4  // micro sec
 104:quantum/split_common/serial.c **** #            if __GNUC__ < 6
 105:quantum/split_common/serial.c **** #                define READ_WRITE_START_ADJUST 33  // cycles
 106:quantum/split_common/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 3   // cycles
 107:quantum/split_common/serial.c **** #            else
 108:quantum/split_common/serial.c **** #                define READ_WRITE_START_ADJUST 34  // cycles
 109:quantum/split_common/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 7   // cycles
 110:quantum/split_common/serial.c **** #            endif
 111:quantum/split_common/serial.c **** #        elif SELECT_SOFT_SERIAL_SPEED == 1
 112:quantum/split_common/serial.c **** // High speed
 113:quantum/split_common/serial.c **** #            define SERIAL_DELAY 6  // micro sec
 114:quantum/split_common/serial.c **** #            if __GNUC__ < 6
 115:quantum/split_common/serial.c **** #                define READ_WRITE_START_ADJUST 30  // cycles
 116:quantum/split_common/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 3   // cycles
 117:quantum/split_common/serial.c **** #            else
 118:quantum/split_common/serial.c **** #                define READ_WRITE_START_ADJUST 33  // cycles
 119:quantum/split_common/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 7   // cycles
 120:quantum/split_common/serial.c **** #            endif
 121:quantum/split_common/serial.c **** #        elif SELECT_SOFT_SERIAL_SPEED == 2
 122:quantum/split_common/serial.c **** // Middle speed
 123:quantum/split_common/serial.c **** #            define SERIAL_DELAY 12             // micro sec
 124:quantum/split_common/serial.c **** #            define READ_WRITE_START_ADJUST 30  // cycles
 125:quantum/split_common/serial.c **** #            if __GNUC__ < 6
 126:quantum/split_common/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 3  // cycles
 127:quantum/split_common/serial.c **** #            else
 128:quantum/split_common/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 7  // cycles
 129:quantum/split_common/serial.c **** #            endif
 130:quantum/split_common/serial.c **** #        elif SELECT_SOFT_SERIAL_SPEED == 3
 131:quantum/split_common/serial.c **** // Low speed
 132:quantum/split_common/serial.c **** #            define SERIAL_DELAY 24             // micro sec
 133:quantum/split_common/serial.c **** #            define READ_WRITE_START_ADJUST 30  // cycles
 134:quantum/split_common/serial.c **** #            if __GNUC__ < 6
 135:quantum/split_common/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 3  // cycles
 136:quantum/split_common/serial.c **** #            else
 137:quantum/split_common/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 7  // cycles
 138:quantum/split_common/serial.c **** #            endif
 139:quantum/split_common/serial.c **** #        elif SELECT_SOFT_SERIAL_SPEED == 4
 140:quantum/split_common/serial.c **** // Very Low speed
 141:quantum/split_common/serial.c **** #            define SERIAL_DELAY 36             // micro sec
 142:quantum/split_common/serial.c **** #            define READ_WRITE_START_ADJUST 30  // cycles
 143:quantum/split_common/serial.c **** #            if __GNUC__ < 6
 144:quantum/split_common/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 3  // cycles
 145:quantum/split_common/serial.c **** #            else
 146:quantum/split_common/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 7  // cycles
 147:quantum/split_common/serial.c **** #            endif
 148:quantum/split_common/serial.c **** #        elif SELECT_SOFT_SERIAL_SPEED == 5
 149:quantum/split_common/serial.c **** // Ultra Low speed
 150:quantum/split_common/serial.c **** #            define SERIAL_DELAY 48             // micro sec
 151:quantum/split_common/serial.c **** #            define READ_WRITE_START_ADJUST 30  // cycles
 152:quantum/split_common/serial.c **** #            if __GNUC__ < 6
 153:quantum/split_common/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 3  // cycles
 154:quantum/split_common/serial.c **** #            else
 155:quantum/split_common/serial.c **** #                define READ_WRITE_WIDTH_ADJUST 7  // cycles
 156:quantum/split_common/serial.c **** #            endif
 157:quantum/split_common/serial.c **** #        else
 158:quantum/split_common/serial.c **** #            error invalid SELECT_SOFT_SERIAL_SPEED value
 159:quantum/split_common/serial.c **** #        endif /* SELECT_SOFT_SERIAL_SPEED */
 160:quantum/split_common/serial.c **** #    endif     /* SERIAL_DELAY */
 161:quantum/split_common/serial.c **** 
 162:quantum/split_common/serial.c **** #    define SERIAL_DELAY_HALF1 (SERIAL_DELAY / 2)
 163:quantum/split_common/serial.c **** #    define SERIAL_DELAY_HALF2 (SERIAL_DELAY - SERIAL_DELAY / 2)
 164:quantum/split_common/serial.c **** 
 165:quantum/split_common/serial.c **** #    define SLAVE_INT_WIDTH_US 1
 166:quantum/split_common/serial.c **** #    ifndef SERIAL_USE_MULTI_TRANSACTION
 167:quantum/split_common/serial.c **** #        define SLAVE_INT_RESPONSE_TIME SERIAL_DELAY
 168:quantum/split_common/serial.c **** #    else
 169:quantum/split_common/serial.c **** #        define SLAVE_INT_ACK_WIDTH_UNIT 2
 170:quantum/split_common/serial.c **** #        define SLAVE_INT_ACK_WIDTH 4
 171:quantum/split_common/serial.c **** #    endif
 172:quantum/split_common/serial.c **** 
 173:quantum/split_common/serial.c **** static SSTD_t *Transaction_table      = NULL;
 174:quantum/split_common/serial.c **** static uint8_t Transaction_table_size = 0;
 175:quantum/split_common/serial.c **** 
 176:quantum/split_common/serial.c **** inline static void serial_delay(void) ALWAYS_INLINE;
 177:quantum/split_common/serial.c **** inline static void serial_delay(void) { _delay_us(SERIAL_DELAY); }
 178:quantum/split_common/serial.c **** 
 179:quantum/split_common/serial.c **** inline static void serial_delay_half1(void) ALWAYS_INLINE;
 180:quantum/split_common/serial.c **** inline static void serial_delay_half1(void) { _delay_us(SERIAL_DELAY_HALF1); }
 181:quantum/split_common/serial.c **** 
 182:quantum/split_common/serial.c **** inline static void serial_delay_half2(void) ALWAYS_INLINE;
 183:quantum/split_common/serial.c **** inline static void serial_delay_half2(void) { _delay_us(SERIAL_DELAY_HALF2); }
 184:quantum/split_common/serial.c **** 
 185:quantum/split_common/serial.c **** inline static void serial_output(void) ALWAYS_INLINE;
 186:quantum/split_common/serial.c **** inline static void serial_output(void) { setPinOutput(SOFT_SERIAL_PIN); }
 187:quantum/split_common/serial.c **** 
 188:quantum/split_common/serial.c **** // make the serial pin an input with pull-up resistor
 189:quantum/split_common/serial.c **** inline static void serial_input_with_pullup(void) ALWAYS_INLINE;
 190:quantum/split_common/serial.c **** inline static void serial_input_with_pullup(void) { setPinInputHigh(SOFT_SERIAL_PIN); }
 191:quantum/split_common/serial.c **** 
 192:quantum/split_common/serial.c **** inline static uint8_t serial_read_pin(void) ALWAYS_INLINE;
 193:quantum/split_common/serial.c **** inline static uint8_t serial_read_pin(void) { return !!readPin(SOFT_SERIAL_PIN); }
 194:quantum/split_common/serial.c **** 
 195:quantum/split_common/serial.c **** inline static void serial_low(void) ALWAYS_INLINE;
 196:quantum/split_common/serial.c **** inline static void serial_low(void) { writePinLow(SOFT_SERIAL_PIN); }
 197:quantum/split_common/serial.c **** 
 198:quantum/split_common/serial.c **** inline static void serial_high(void) ALWAYS_INLINE;
 199:quantum/split_common/serial.c **** inline static void serial_high(void) { writePinHigh(SOFT_SERIAL_PIN); }
 200:quantum/split_common/serial.c **** 
 201:quantum/split_common/serial.c **** void soft_serial_initiator_init(SSTD_t *sstd_table, int sstd_table_size) {
 202:quantum/split_common/serial.c ****     Transaction_table      = sstd_table;
 203:quantum/split_common/serial.c ****     Transaction_table_size = (uint8_t)sstd_table_size;
 204:quantum/split_common/serial.c ****     serial_output();
 205:quantum/split_common/serial.c ****     serial_high();
 206:quantum/split_common/serial.c **** }
 207:quantum/split_common/serial.c **** 
 208:quantum/split_common/serial.c **** void soft_serial_target_init(SSTD_t *sstd_table, int sstd_table_size) {
 209:quantum/split_common/serial.c ****     Transaction_table      = sstd_table;
 210:quantum/split_common/serial.c ****     Transaction_table_size = (uint8_t)sstd_table_size;
 211:quantum/split_common/serial.c ****     serial_input_with_pullup();
 212:quantum/split_common/serial.c **** 
 213:quantum/split_common/serial.c ****     // Enable INT0-INT3,INT6
 214:quantum/split_common/serial.c ****     EIMSK |= EIMSK_BIT;
 215:quantum/split_common/serial.c **** #    if SOFT_SERIAL_PIN == E6
 216:quantum/split_common/serial.c ****     // Trigger on falling edge of INT6
 217:quantum/split_common/serial.c ****     EICRB &= EICRx_BIT;
 218:quantum/split_common/serial.c **** #    else
 219:quantum/split_common/serial.c ****     // Trigger on falling edge of INT0-INT3
 220:quantum/split_common/serial.c ****     EICRA &= EICRx_BIT;
 221:quantum/split_common/serial.c **** #    endif
 222:quantum/split_common/serial.c **** }
 223:quantum/split_common/serial.c **** 
 224:quantum/split_common/serial.c **** // Used by the sender to synchronize timing with the reciver.
 225:quantum/split_common/serial.c **** static void sync_recv(void) NO_INLINE;
 226:quantum/split_common/serial.c **** static void sync_recv(void) {
  15               		.loc 1 226 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.LVL0:
  22               		.loc 1 226 0
  23 0000 8EE1      		ldi r24,lo8(30)
  24               	.LVL1:
  25               	.L2:
  26               	.LBB129:
 227:quantum/split_common/serial.c ****     for (uint8_t i = 0; i < SERIAL_DELAY * 5 && serial_read_pin(); i++) {
  27               		.loc 1 227 0
  28 0002 489B      		sbis 0x9,0
  29 0004 00C0      		rjmp .L7
  30               	.LVL2:
  31 0006 8150      		subi r24,lo8(-(-1))
  32               	.LVL3:
  33               		.loc 1 227 0 is_stmt 0 discriminator 4
  34 0008 01F4      		brne .L2
  35               	.LVL4:
  36               	.L7:
  37               	.LBE129:
 228:quantum/split_common/serial.c ****     }
 229:quantum/split_common/serial.c ****     // This shouldn't hang if the target disconnects because the
 230:quantum/split_common/serial.c ****     // serial line will float to high if the target does disconnect.
 231:quantum/split_common/serial.c ****     while (!serial_read_pin())
  38               		.loc 1 231 0 is_stmt 1 discriminator 1
  39 000a 489B      		sbis 0x9,0
  40 000c 00C0      		rjmp .L7
  41               	/* epilogue start */
 232:quantum/split_common/serial.c ****         ;
 233:quantum/split_common/serial.c **** }
  42               		.loc 1 233 0
  43 000e 0895      		ret
  44               		.cfi_endproc
  45               	.LFE16:
  47               		.section	.text.sync_send,"ax",@progbits
  49               	sync_send:
  50               	.LFB17:
 234:quantum/split_common/serial.c **** 
 235:quantum/split_common/serial.c **** // Used by the reciver to send a synchronization signal to the sender.
 236:quantum/split_common/serial.c **** static void sync_send(void) NO_INLINE;
 237:quantum/split_common/serial.c **** static void sync_send(void) {
  51               		.loc 1 237 0
  52               		.cfi_startproc
  53               	/* prologue: function */
  54               	/* frame size = 0 */
  55               	/* stack size = 0 */
  56               	.L__stack_usage = 0
  57               	.LBB130:
  58               	.LBB131:
 196:quantum/split_common/serial.c **** 
  59               		.loc 1 196 0
  60 0000 5898      		cbi 0xb,0
  61               	.LVL5:
  62               	.LBE131:
  63               	.LBE130:
  64               	.LBB132:
  65               	.LBB133:
  66               	.LBB134:
  67               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  68               		.loc 2 276 0
  69 0002 80E2      		ldi r24,lo8(32)
  70 0004 8A95      	1:	dec r24
  71 0006 01F4      		brne 1b
  72               	.LVL6:
  73               	.LBE134:
  74               	.LBE133:
  75               	.LBE132:
  76               	.LBB135:
  77               	.LBB136:
 199:quantum/split_common/serial.c **** 
  78               		.loc 1 199 0
  79 0008 589A      		sbi 0xb,0
  80 000a 0895      		ret
  81               	.LBE136:
  82               	.LBE135:
  83               		.cfi_endproc
  84               	.LFE17:
  86               		.section	.text.serial_read_chunk.constprop.0,"ax",@progbits
  88               	serial_read_chunk.constprop.0:
  89               	.LFB27:
 238:quantum/split_common/serial.c ****     serial_low();
 239:quantum/split_common/serial.c ****     serial_delay();
 240:quantum/split_common/serial.c ****     serial_high();
 241:quantum/split_common/serial.c **** }
 242:quantum/split_common/serial.c **** 
 243:quantum/split_common/serial.c **** // Reads a byte from the serial line
 244:quantum/split_common/serial.c **** static uint8_t serial_read_chunk(uint8_t *pterrcount, uint8_t bit) NO_INLINE;
 245:quantum/split_common/serial.c **** static uint8_t serial_read_chunk(uint8_t *pterrcount, uint8_t bit) {
  90               		.loc 1 245 0
  91               		.cfi_startproc
  92               	.LVL7:
  93               	/* prologue: function */
  94               	/* frame size = 0 */
  95               	/* stack size = 0 */
  96               	.L__stack_usage = 0
  97 0000 FC01      		movw r30,r24
  98               	.LVL8:
 246:quantum/split_common/serial.c ****     uint8_t byte, i, p, pb;
 247:quantum/split_common/serial.c **** 
 248:quantum/split_common/serial.c ****     _delay_sub_us(READ_WRITE_START_ADJUST);
  99               		.loc 1 248 0
 100 0002 2AE0      		ldi r18,lo8(10)
 101 0004 2A95      	1:	dec r18
 102 0006 01F4      		brne 1b
 103               	.LVL9:
 104 0008 28E0      		ldi r18,lo8(8)
 249:quantum/split_common/serial.c ****     for (i = 0, byte = 0, p = PARITY; i < bit; i++) {
 105               		.loc 1 249 0
 106 000a 90E0      		ldi r25,0
 107 000c 80E0      		ldi r24,0
 108               	.LVL10:
 250:quantum/split_common/serial.c ****         serial_delay_half1();  // read the middle of pulses
 251:quantum/split_common/serial.c ****         if (serial_read_pin()) {
 252:quantum/split_common/serial.c ****             byte = (byte << 1) | 1;
 253:quantum/split_common/serial.c ****             p ^= 1;
 109               		.loc 1 253 0
 110 000e 31E0      		ldi r19,lo8(1)
 111               	.LVL11:
 112               	.L15:
 113               	.LBB137:
 114               	.LBB138:
 115               	.LBB139:
 116               		.loc 2 276 0
 117 0010 40E1      		ldi r20,lo8(16)
 118 0012 4A95      	1:	dec r20
 119 0014 01F4      		brne 1b
 120               	.LVL12:
 121               	.LBE139:
 122               	.LBE138:
 123               	.LBE137:
 252:quantum/split_common/serial.c ****             p ^= 1;
 124               		.loc 1 252 0
 125 0016 880F      		lsl r24
 126               	.LVL13:
 251:quantum/split_common/serial.c ****             byte = (byte << 1) | 1;
 127               		.loc 1 251 0
 128 0018 489B      		sbis 0x9,0
 129 001a 00C0      		rjmp .L14
 252:quantum/split_common/serial.c ****             p ^= 1;
 130               		.loc 1 252 0
 131 001c 8160      		ori r24,lo8(1)
 132               	.LVL14:
 133               		.loc 1 253 0
 134 001e 9327      		eor r25,r19
 135               	.LVL15:
 136               	.L14:
 254:quantum/split_common/serial.c ****         } else {
 255:quantum/split_common/serial.c ****             byte = (byte << 1) | 0;
 256:quantum/split_common/serial.c ****             p ^= 0;
 257:quantum/split_common/serial.c ****         }
 258:quantum/split_common/serial.c ****         _delay_sub_us(READ_WRITE_WIDTH_ADJUST);
 137               		.loc 1 258 0
 138 0020 00C0      		rjmp .
 139 0022 0000      		nop
 140               	.LVL16:
 141               	.LBB140:
 142               	.LBB141:
 143               	.LBB142:
 144               		.loc 2 276 0
 145 0024 40E1      		ldi r20,lo8(16)
 146 0026 4A95      	1:	dec r20
 147 0028 01F4      		brne 1b
 148               	.LVL17:
 149 002a 2150      		subi r18,lo8(-(-1))
 150               	.LVL18:
 151               	.LBE142:
 152               	.LBE141:
 153               	.LBE140:
 249:quantum/split_common/serial.c ****         serial_delay_half1();  // read the middle of pulses
 154               		.loc 1 249 0
 155 002c 01F4      		brne .L15
 156               	.LVL19:
 157               	.LBB143:
 158               	.LBB144:
 159               	.LBB145:
 160               		.loc 2 276 0
 161 002e 20E1      		ldi r18,lo8(16)
 162 0030 2A95      	1:	dec r18
 163 0032 01F4      		brne 1b
 164               	.LVL20:
 165               	.LBE145:
 166               	.LBE144:
 167               	.LBE143:
 168               	.LBB146:
 169               	.LBB147:
 193:quantum/split_common/serial.c **** 
 170               		.loc 1 193 0
 171 0034 29B1      		in r18,0x9
 172               	.LBE147:
 173               	.LBE146:
 259:quantum/split_common/serial.c ****         serial_delay_half2();
 260:quantum/split_common/serial.c ****     }
 261:quantum/split_common/serial.c ****     /* recive parity bit */
 262:quantum/split_common/serial.c ****     serial_delay_half1();  // read the middle of pulses
 263:quantum/split_common/serial.c ****     pb = serial_read_pin();
 264:quantum/split_common/serial.c ****     _delay_sub_us(READ_WRITE_WIDTH_ADJUST);
 174               		.loc 1 264 0
 175 0036 00C0      		rjmp .
 176 0038 0000      		nop
 177               	.LVL21:
 178               	.LBB148:
 179               	.LBB149:
 180               	.LBB150:
 181               		.loc 2 276 0
 182 003a 30E1      		ldi r19,lo8(16)
 183 003c 3A95      	1:	dec r19
 184 003e 01F4      		brne 1b
 185               	.LVL22:
 186 0040 2170      		andi r18,lo8(1)
 187 0042 9227      		eor r25,r18
 188               	.LVL23:
 189               	.LBE150:
 190               	.LBE149:
 191               	.LBE148:
 265:quantum/split_common/serial.c ****     serial_delay_half2();
 266:quantum/split_common/serial.c **** 
 267:quantum/split_common/serial.c ****     *pterrcount += (p != pb) ? 1 : 0;
 192               		.loc 1 267 0
 193 0044 2081      		ld r18,Z
 194 0046 920F      		add r25,r18
 195 0048 9083      		st Z,r25
 268:quantum/split_common/serial.c **** 
 269:quantum/split_common/serial.c ****     return byte;
 270:quantum/split_common/serial.c **** }
 196               		.loc 1 270 0
 197 004a 0895      		ret
 198               		.cfi_endproc
 199               	.LFE27:
 201               		.section	.text.serial_recive_packet,"ax",@progbits
 203               	serial_recive_packet:
 204               	.LFB21:
 271:quantum/split_common/serial.c **** 
 272:quantum/split_common/serial.c **** // Sends a byte with MSB ordering
 273:quantum/split_common/serial.c **** void serial_write_chunk(uint8_t data, uint8_t bit) NO_INLINE;
 274:quantum/split_common/serial.c **** void serial_write_chunk(uint8_t data, uint8_t bit) {
 275:quantum/split_common/serial.c ****     uint8_t b, p;
 276:quantum/split_common/serial.c ****     for (p = PARITY, b = 1 << (bit - 1); b; b >>= 1) {
 277:quantum/split_common/serial.c ****         if (data & b) {
 278:quantum/split_common/serial.c ****             serial_high();
 279:quantum/split_common/serial.c ****             p ^= 1;
 280:quantum/split_common/serial.c ****         } else {
 281:quantum/split_common/serial.c ****             serial_low();
 282:quantum/split_common/serial.c ****             p ^= 0;
 283:quantum/split_common/serial.c ****         }
 284:quantum/split_common/serial.c ****         serial_delay();
 285:quantum/split_common/serial.c ****     }
 286:quantum/split_common/serial.c ****     /* send parity bit */
 287:quantum/split_common/serial.c ****     if (p & 1) {
 288:quantum/split_common/serial.c ****         serial_high();
 289:quantum/split_common/serial.c ****     } else {
 290:quantum/split_common/serial.c ****         serial_low();
 291:quantum/split_common/serial.c ****     }
 292:quantum/split_common/serial.c ****     serial_delay();
 293:quantum/split_common/serial.c **** 
 294:quantum/split_common/serial.c ****     serial_low();  // sync_send() / senc_recv() need raise edge
 295:quantum/split_common/serial.c **** }
 296:quantum/split_common/serial.c **** 
 297:quantum/split_common/serial.c **** static void serial_send_packet(uint8_t *buffer, uint8_t size) NO_INLINE;
 298:quantum/split_common/serial.c **** static void serial_send_packet(uint8_t *buffer, uint8_t size) {
 299:quantum/split_common/serial.c ****     for (uint8_t i = 0; i < size; ++i) {
 300:quantum/split_common/serial.c ****         uint8_t data;
 301:quantum/split_common/serial.c ****         data = buffer[i];
 302:quantum/split_common/serial.c ****         sync_send();
 303:quantum/split_common/serial.c ****         serial_write_chunk(data, 8);
 304:quantum/split_common/serial.c ****     }
 305:quantum/split_common/serial.c **** }
 306:quantum/split_common/serial.c **** 
 307:quantum/split_common/serial.c **** static uint8_t serial_recive_packet(uint8_t *buffer, uint8_t size) NO_INLINE;
 308:quantum/split_common/serial.c **** static uint8_t serial_recive_packet(uint8_t *buffer, uint8_t size) {
 205               		.loc 1 308 0
 206               		.cfi_startproc
 207               	.LVL24:
 208 0000 EF92      		push r14
 209               	.LCFI0:
 210               		.cfi_def_cfa_offset 3
 211               		.cfi_offset 14, -2
 212 0002 FF92      		push r15
 213               	.LCFI1:
 214               		.cfi_def_cfa_offset 4
 215               		.cfi_offset 15, -3
 216 0004 0F93      		push r16
 217               	.LCFI2:
 218               		.cfi_def_cfa_offset 5
 219               		.cfi_offset 16, -4
 220 0006 1F93      		push r17
 221               	.LCFI3:
 222               		.cfi_def_cfa_offset 6
 223               		.cfi_offset 17, -5
 224 0008 CF93      		push r28
 225               	.LCFI4:
 226               		.cfi_def_cfa_offset 7
 227               		.cfi_offset 28, -6
 228 000a DF93      		push r29
 229               	.LCFI5:
 230               		.cfi_def_cfa_offset 8
 231               		.cfi_offset 29, -7
 232 000c 1F92      		push __zero_reg__
 233               	.LCFI6:
 234               		.cfi_def_cfa_offset 9
 235 000e CDB7      		in r28,__SP_L__
 236 0010 DEB7      		in r29,__SP_H__
 237               	.LCFI7:
 238               		.cfi_def_cfa_register 28
 239               	/* prologue: function */
 240               	/* frame size = 1 */
 241               	/* stack size = 7 */
 242               	.L__stack_usage = 7
 309:quantum/split_common/serial.c ****     uint8_t pecount = 0;
 243               		.loc 1 309 0
 244 0012 1982      		std Y+1,__zero_reg__
 245               	.LVL25:
 246 0014 8C01      		movw r16,r24
 247 0016 7C01      		movw r14,r24
 248 0018 E60E      		add r14,r22
 249 001a F11C      		adc r15,__zero_reg__
 250               	.LVL26:
 251               	.L18:
 252               	.LBB151:
 310:quantum/split_common/serial.c ****     for (uint8_t i = 0; i < size; ++i) {
 253               		.loc 1 310 0 discriminator 1
 254 001c 0E15      		cp r16,r14
 255 001e 1F05      		cpc r17,r15
 256 0020 01F0      		breq .L24
 257               	.LBB152:
 311:quantum/split_common/serial.c ****         uint8_t data;
 312:quantum/split_common/serial.c ****         sync_recv();
 258               		.loc 1 312 0 discriminator 3
 259 0022 0E94 0000 		call sync_recv
 260               	.LVL27:
 313:quantum/split_common/serial.c ****         data      = serial_read_chunk(&pecount, 8);
 261               		.loc 1 313 0 discriminator 3
 262 0026 CE01      		movw r24,r28
 263 0028 0196      		adiw r24,1
 264 002a 0E94 0000 		call serial_read_chunk.constprop.0
 265               	.LVL28:
 314:quantum/split_common/serial.c ****         buffer[i] = data;
 266               		.loc 1 314 0 discriminator 3
 267 002e F801      		movw r30,r16
 268 0030 8193      		st Z+,r24
 269 0032 8F01      		movw r16,r30
 270               	.LVL29:
 271 0034 00C0      		rjmp .L18
 272               	.LVL30:
 273               	.L24:
 274               	.LBE152:
 275               	.LBE151:
 315:quantum/split_common/serial.c ****     }
 316:quantum/split_common/serial.c ****     return pecount == 0;
 276               		.loc 1 316 0
 277 0036 81E0      		ldi r24,lo8(1)
 278 0038 9981      		ldd r25,Y+1
 279 003a 9111      		cpse r25,__zero_reg__
 280 003c 80E0      		ldi r24,0
 281               	.L20:
 282               	/* epilogue start */
 317:quantum/split_common/serial.c **** }
 283               		.loc 1 317 0
 284 003e 0F90      		pop __tmp_reg__
 285 0040 DF91      		pop r29
 286 0042 CF91      		pop r28
 287 0044 1F91      		pop r17
 288 0046 0F91      		pop r16
 289               	.LVL31:
 290 0048 FF90      		pop r15
 291 004a EF90      		pop r14
 292 004c 0895      		ret
 293               		.cfi_endproc
 294               	.LFE21:
 296               		.section	.text.soft_serial_initiator_init,"ax",@progbits
 297               	.global	soft_serial_initiator_init
 299               	soft_serial_initiator_init:
 300               	.LFB14:
 201:quantum/split_common/serial.c ****     Transaction_table      = sstd_table;
 301               		.loc 1 201 0
 302               		.cfi_startproc
 303               	.LVL32:
 304               	/* prologue: function */
 305               	/* frame size = 0 */
 306               	/* stack size = 0 */
 307               	.L__stack_usage = 0
 202:quantum/split_common/serial.c ****     Transaction_table_size = (uint8_t)sstd_table_size;
 308               		.loc 1 202 0
 309 0000 9093 0000 		sts Transaction_table+1,r25
 310 0004 8093 0000 		sts Transaction_table,r24
 311               	.LBB153:
 312               	.LBB154:
 186:quantum/split_common/serial.c **** 
 313               		.loc 1 186 0
 314 0008 509A      		sbi 0xa,0
 315               	.LBE154:
 316               	.LBE153:
 317               	.LBB155:
 318               	.LBB156:
 199:quantum/split_common/serial.c **** 
 319               		.loc 1 199 0
 320 000a 589A      		sbi 0xb,0
 321 000c 0895      		ret
 322               	.LBE156:
 323               	.LBE155:
 324               		.cfi_endproc
 325               	.LFE14:
 327               		.section	.text.soft_serial_target_init,"ax",@progbits
 328               	.global	soft_serial_target_init
 330               	soft_serial_target_init:
 331               	.LFB15:
 208:quantum/split_common/serial.c ****     Transaction_table      = sstd_table;
 332               		.loc 1 208 0
 333               		.cfi_startproc
 334               	.LVL33:
 335               	/* prologue: function */
 336               	/* frame size = 0 */
 337               	/* stack size = 0 */
 338               	.L__stack_usage = 0
 209:quantum/split_common/serial.c ****     Transaction_table_size = (uint8_t)sstd_table_size;
 339               		.loc 1 209 0
 340 0000 9093 0000 		sts Transaction_table+1,r25
 341 0004 8093 0000 		sts Transaction_table,r24
 342               	.LBB157:
 343               	.LBB158:
 190:quantum/split_common/serial.c **** 
 344               		.loc 1 190 0
 345 0008 5098      		cbi 0xa,0
 346 000a 589A      		sbi 0xb,0
 347               	.LBE158:
 348               	.LBE157:
 214:quantum/split_common/serial.c **** #    if SOFT_SERIAL_PIN == E6
 349               		.loc 1 214 0
 350 000c E89A      		sbi 0x1d,0
 220:quantum/split_common/serial.c **** #    endif
 351               		.loc 1 220 0
 352 000e E9E6      		ldi r30,lo8(105)
 353 0010 F0E0      		ldi r31,0
 354 0012 8081      		ld r24,Z
 355               	.LVL34:
 356 0014 8C7F      		andi r24,lo8(-4)
 357 0016 8083      		st Z,r24
 358               	.LVL35:
 359 0018 0895      		ret
 360               		.cfi_endproc
 361               	.LFE15:
 363               		.section	.text.serial_write_chunk,"ax",@progbits
 364               	.global	serial_write_chunk
 366               	serial_write_chunk:
 367               	.LFB19:
 274:quantum/split_common/serial.c ****     uint8_t b, p;
 368               		.loc 1 274 0
 369               		.cfi_startproc
 370               	.LVL36:
 371               	/* prologue: function */
 372               	/* frame size = 0 */
 373               	/* stack size = 0 */
 374               	.L__stack_usage = 0
 276:quantum/split_common/serial.c ****         if (data & b) {
 375               		.loc 1 276 0
 376 0000 6150      		subi r22,lo8(-(-1))
 377               	.LVL37:
 378 0002 91E0      		ldi r25,lo8(1)
 379 0004 00C0      		rjmp 2f
 380               		1:
 381 0006 990F      		lsl r25
 382               		2:
 383 0008 6A95      		dec r22
 384 000a 02F4      		brpl 1b
 385               	.LVL38:
 386 000c 20E0      		ldi r18,0
 279:quantum/split_common/serial.c ****         } else {
 387               		.loc 1 279 0
 388 000e 31E0      		ldi r19,lo8(1)
 389               	.LVL39:
 390               	.L28:
 276:quantum/split_common/serial.c ****         if (data & b) {
 391               		.loc 1 276 0 discriminator 1
 392 0010 9923      		tst r25
 393 0012 01F0      		breq .L34
 277:quantum/split_common/serial.c ****             serial_high();
 394               		.loc 1 277 0
 395 0014 492F      		mov r20,r25
 396 0016 4823      		and r20,r24
 397 0018 01F0      		breq .L29
 398               	.LBB159:
 399               	.LBB160:
 199:quantum/split_common/serial.c **** 
 400               		.loc 1 199 0
 401 001a 589A      		sbi 0xb,0
 402               	.LBE160:
 403               	.LBE159:
 279:quantum/split_common/serial.c ****         } else {
 404               		.loc 1 279 0
 405 001c 2327      		eor r18,r19
 406               	.LVL40:
 407 001e 00C0      		rjmp .L30
 408               	.L29:
 409               	.LBB161:
 410               	.LBB162:
 196:quantum/split_common/serial.c **** 
 411               		.loc 1 196 0
 412 0020 5898      		cbi 0xb,0
 413               	.L30:
 414               	.LVL41:
 415               	.LBE162:
 416               	.LBE161:
 417               	.LBB163:
 418               	.LBB164:
 419               	.LBB165:
 420               		.loc 2 276 0 discriminator 2
 421 0022 40E2      		ldi r20,lo8(32)
 422 0024 4A95      	1:	dec r20
 423 0026 01F4      		brne 1b
 424               	.LVL42:
 425               	.LBE165:
 426               	.LBE164:
 427               	.LBE163:
 276:quantum/split_common/serial.c ****         if (data & b) {
 428               		.loc 1 276 0 discriminator 2
 429 0028 9695      		lsr r25
 430               	.LVL43:
 431 002a 00C0      		rjmp .L28
 432               	.L34:
 287:quantum/split_common/serial.c ****         serial_high();
 433               		.loc 1 287 0
 434 002c 2223      		tst r18
 435 002e 01F0      		breq .L32
 436               	.LBB166:
 437               	.LBB167:
 199:quantum/split_common/serial.c **** 
 438               		.loc 1 199 0
 439 0030 589A      		sbi 0xb,0
 440 0032 00C0      		rjmp .L33
 441               	.L32:
 442               	.LBE167:
 443               	.LBE166:
 444               	.LBB168:
 445               	.LBB169:
 196:quantum/split_common/serial.c **** 
 446               		.loc 1 196 0
 447 0034 5898      		cbi 0xb,0
 448               	.L33:
 449               	.LVL44:
 450               	.LBE169:
 451               	.LBE168:
 452               	.LBB170:
 453               	.LBB171:
 454               	.LBB172:
 455               		.loc 2 276 0
 456 0036 80E2      		ldi r24,lo8(32)
 457 0038 8A95      	1:	dec r24
 458 003a 01F4      		brne 1b
 459               	.LVL45:
 460               	.LBE172:
 461               	.LBE171:
 462               	.LBE170:
 463               	.LBB173:
 464               	.LBB174:
 196:quantum/split_common/serial.c **** 
 465               		.loc 1 196 0
 466 003c 5898      		cbi 0xb,0
 467 003e 0895      		ret
 468               	.LBE174:
 469               	.LBE173:
 470               		.cfi_endproc
 471               	.LFE19:
 473               		.section	.text.serial_send_packet,"ax",@progbits
 475               	serial_send_packet:
 476               	.LFB20:
 298:quantum/split_common/serial.c ****     for (uint8_t i = 0; i < size; ++i) {
 477               		.loc 1 298 0
 478               		.cfi_startproc
 479               	.LVL46:
 480 0000 FF92      		push r15
 481               	.LCFI8:
 482               		.cfi_def_cfa_offset 3
 483               		.cfi_offset 15, -2
 484 0002 0F93      		push r16
 485               	.LCFI9:
 486               		.cfi_def_cfa_offset 4
 487               		.cfi_offset 16, -3
 488 0004 1F93      		push r17
 489               	.LCFI10:
 490               		.cfi_def_cfa_offset 5
 491               		.cfi_offset 17, -4
 492 0006 CF93      		push r28
 493               	.LCFI11:
 494               		.cfi_def_cfa_offset 6
 495               		.cfi_offset 28, -5
 496 0008 DF93      		push r29
 497               	.LCFI12:
 498               		.cfi_def_cfa_offset 7
 499               		.cfi_offset 29, -6
 500               	/* prologue: function */
 501               	/* frame size = 0 */
 502               	/* stack size = 5 */
 503               	.L__stack_usage = 5
 504               	.LVL47:
 505 000a EC01      		movw r28,r24
 506 000c 8C01      		movw r16,r24
 507 000e 060F      		add r16,r22
 508 0010 111D      		adc r17,__zero_reg__
 509               	.LVL48:
 510               	.L36:
 511               	.LBB175:
 299:quantum/split_common/serial.c ****         uint8_t data;
 512               		.loc 1 299 0 discriminator 1
 513 0012 C017      		cp r28,r16
 514 0014 D107      		cpc r29,r17
 515 0016 01F0      		breq .L38
 516               	.LBB176:
 301:quantum/split_common/serial.c ****         sync_send();
 517               		.loc 1 301 0 discriminator 3
 518 0018 F990      		ld r15,Y+
 519               	.LVL49:
 302:quantum/split_common/serial.c ****         serial_write_chunk(data, 8);
 520               		.loc 1 302 0 discriminator 3
 521 001a 0E94 0000 		call sync_send
 522               	.LVL50:
 303:quantum/split_common/serial.c ****     }
 523               		.loc 1 303 0 discriminator 3
 524 001e 68E0      		ldi r22,lo8(8)
 525 0020 8F2D      		mov r24,r15
 526 0022 0E94 0000 		call serial_write_chunk
 527               	.LVL51:
 528 0026 00C0      		rjmp .L36
 529               	.LVL52:
 530               	.L38:
 531               	/* epilogue start */
 532               	.LBE176:
 533               	.LBE175:
 305:quantum/split_common/serial.c **** 
 534               		.loc 1 305 0
 535 0028 DF91      		pop r29
 536 002a CF91      		pop r28
 537               	.LVL53:
 538 002c 1F91      		pop r17
 539 002e 0F91      		pop r16
 540 0030 FF90      		pop r15
 541 0032 0895      		ret
 542               		.cfi_endproc
 543               	.LFE20:
 545               		.section	.text.__vector_1,"ax",@progbits
 546               	.global	__vector_1
 548               	__vector_1:
 549               	.LFB25:
 318:quantum/split_common/serial.c **** 
 319:quantum/split_common/serial.c **** inline static void change_sender2reciver(void) {
 320:quantum/split_common/serial.c ****     sync_send();                 // 0
 321:quantum/split_common/serial.c ****     serial_delay_half1();        // 1
 322:quantum/split_common/serial.c ****     serial_low();                // 2
 323:quantum/split_common/serial.c ****     serial_input_with_pullup();  // 2
 324:quantum/split_common/serial.c ****     serial_delay_half1();        // 3
 325:quantum/split_common/serial.c **** }
 326:quantum/split_common/serial.c **** 
 327:quantum/split_common/serial.c **** inline static void change_reciver2sender(void) {
 328:quantum/split_common/serial.c ****     sync_recv();           // 0
 329:quantum/split_common/serial.c ****     serial_delay();        // 1
 330:quantum/split_common/serial.c ****     serial_low();          // 3
 331:quantum/split_common/serial.c ****     serial_output();       // 3
 332:quantum/split_common/serial.c ****     serial_delay_half1();  // 4
 333:quantum/split_common/serial.c **** }
 334:quantum/split_common/serial.c **** 
 335:quantum/split_common/serial.c **** static inline uint8_t nibble_bits_count(uint8_t bits) {
 336:quantum/split_common/serial.c ****     bits = (bits & 0x5) + (bits >> 1 & 0x5);
 337:quantum/split_common/serial.c ****     bits = (bits & 0x3) + (bits >> 2 & 0x3);
 338:quantum/split_common/serial.c ****     return bits;
 339:quantum/split_common/serial.c **** }
 340:quantum/split_common/serial.c **** 
 341:quantum/split_common/serial.c **** // interrupt handle to be used by the target device
 342:quantum/split_common/serial.c **** ISR(SERIAL_PIN_INTERRUPT) {
 550               		.loc 1 342 0
 551               		.cfi_startproc
 552 0000 1F92      		push r1
 553               	.LCFI13:
 554               		.cfi_def_cfa_offset 3
 555               		.cfi_offset 1, -2
 556 0002 0F92      		push r0
 557               	.LCFI14:
 558               		.cfi_def_cfa_offset 4
 559               		.cfi_offset 0, -3
 560 0004 0FB6      		in r0,__SREG__
 561 0006 0F92      		push r0
 562 0008 1124      		clr __zero_reg__
 563 000a 2F93      		push r18
 564               	.LCFI15:
 565               		.cfi_def_cfa_offset 5
 566               		.cfi_offset 18, -4
 567 000c 3F93      		push r19
 568               	.LCFI16:
 569               		.cfi_def_cfa_offset 6
 570               		.cfi_offset 19, -5
 571 000e 4F93      		push r20
 572               	.LCFI17:
 573               		.cfi_def_cfa_offset 7
 574               		.cfi_offset 20, -6
 575 0010 5F93      		push r21
 576               	.LCFI18:
 577               		.cfi_def_cfa_offset 8
 578               		.cfi_offset 21, -7
 579 0012 6F93      		push r22
 580               	.LCFI19:
 581               		.cfi_def_cfa_offset 9
 582               		.cfi_offset 22, -8
 583 0014 7F93      		push r23
 584               	.LCFI20:
 585               		.cfi_def_cfa_offset 10
 586               		.cfi_offset 23, -9
 587 0016 8F93      		push r24
 588               	.LCFI21:
 589               		.cfi_def_cfa_offset 11
 590               		.cfi_offset 24, -10
 591 0018 9F93      		push r25
 592               	.LCFI22:
 593               		.cfi_def_cfa_offset 12
 594               		.cfi_offset 25, -11
 595 001a AF93      		push r26
 596               	.LCFI23:
 597               		.cfi_def_cfa_offset 13
 598               		.cfi_offset 26, -12
 599 001c BF93      		push r27
 600               	.LCFI24:
 601               		.cfi_def_cfa_offset 14
 602               		.cfi_offset 27, -13
 603 001e CF93      		push r28
 604               	.LCFI25:
 605               		.cfi_def_cfa_offset 15
 606               		.cfi_offset 28, -14
 607 0020 DF93      		push r29
 608               	.LCFI26:
 609               		.cfi_def_cfa_offset 16
 610               		.cfi_offset 29, -15
 611 0022 EF93      		push r30
 612               	.LCFI27:
 613               		.cfi_def_cfa_offset 17
 614               		.cfi_offset 30, -16
 615 0024 FF93      		push r31
 616               	.LCFI28:
 617               		.cfi_def_cfa_offset 18
 618               		.cfi_offset 31, -17
 619               	/* prologue: Signal */
 620               	/* frame size = 0 */
 621               	/* stack size = 17 */
 622               	.L__stack_usage = 17
 623               	.LBB193:
 624               	.LBB194:
 196:quantum/split_common/serial.c **** 
 625               		.loc 1 196 0
 626 0026 5898      		cbi 0xb,0
 627               	.LBE194:
 628               	.LBE193:
 629               	.LBB195:
 630               	.LBB196:
 186:quantum/split_common/serial.c **** 
 631               		.loc 1 186 0
 632 0028 509A      		sbi 0xa,0
 633               	.LBE196:
 634               	.LBE195:
 343:quantum/split_common/serial.c **** #    ifndef SERIAL_USE_MULTI_TRANSACTION
 344:quantum/split_common/serial.c ****     serial_low();
 345:quantum/split_common/serial.c ****     serial_output();
 346:quantum/split_common/serial.c ****     SSTD_t *trans = Transaction_table;
 635               		.loc 1 346 0
 636 002a C091 0000 		lds r28,Transaction_table
 637 002e D091 0000 		lds r29,Transaction_table+1
 638               	.LVL54:
 347:quantum/split_common/serial.c **** #    else
 348:quantum/split_common/serial.c ****     // recive transaction table index
 349:quantum/split_common/serial.c ****     uint8_t tid, bits;
 350:quantum/split_common/serial.c ****     uint8_t pecount = 0;
 351:quantum/split_common/serial.c ****     sync_recv();
 352:quantum/split_common/serial.c ****     bits = serial_read_chunk(&pecount, 7);
 353:quantum/split_common/serial.c ****     tid  = bits >> 3;
 354:quantum/split_common/serial.c ****     bits = (bits & 7) != nibble_bits_count(tid);
 355:quantum/split_common/serial.c ****     if (bits || pecount > 0 || tid > Transaction_table_size) {
 356:quantum/split_common/serial.c ****         return;
 357:quantum/split_common/serial.c ****     }
 358:quantum/split_common/serial.c ****     serial_delay_half1();
 359:quantum/split_common/serial.c **** 
 360:quantum/split_common/serial.c ****     serial_high();  // response step1 low->high
 361:quantum/split_common/serial.c ****     serial_output();
 362:quantum/split_common/serial.c ****     _delay_sub_us(SLAVE_INT_ACK_WIDTH_UNIT * SLAVE_INT_ACK_WIDTH);
 363:quantum/split_common/serial.c ****     SSTD_t *trans = &Transaction_table[tid];
 364:quantum/split_common/serial.c ****     serial_low();  // response step2 ack high->low
 365:quantum/split_common/serial.c **** #    endif
 366:quantum/split_common/serial.c **** 
 367:quantum/split_common/serial.c ****     // target send phase
 368:quantum/split_common/serial.c ****     if (trans->target2initiator_buffer_size > 0) serial_send_packet((uint8_t *)trans->target2initia
 639               		.loc 1 368 0
 640 0032 6D81      		ldd r22,Y+5
 641 0034 6623      		tst r22
 642 0036 01F0      		breq .L40
 643               		.loc 1 368 0 is_stmt 0 discriminator 1
 644 0038 8E81      		ldd r24,Y+6
 645 003a 9F81      		ldd r25,Y+7
 646 003c 0E94 0000 		call serial_send_packet
 647               	.LVL55:
 648               	.L40:
 649               	.LBB197:
 650               	.LBB198:
 320:quantum/split_common/serial.c ****     serial_delay_half1();        // 1
 651               		.loc 1 320 0 is_stmt 1
 652 0040 0E94 0000 		call sync_send
 653               	.LVL56:
 654               	.LBB199:
 655               	.LBB200:
 656               	.LBB201:
 657               		.loc 2 276 0
 658 0044 80E1      		ldi r24,lo8(16)
 659 0046 8A95      	1:	dec r24
 660 0048 01F4      		brne 1b
 661               	.LVL57:
 662               	.LBE201:
 663               	.LBE200:
 664               	.LBE199:
 665               	.LBB202:
 666               	.LBB203:
 196:quantum/split_common/serial.c **** 
 667               		.loc 1 196 0
 668 004a 5898      		cbi 0xb,0
 669               	.LBE203:
 670               	.LBE202:
 671               	.LBB204:
 672               	.LBB205:
 190:quantum/split_common/serial.c **** 
 673               		.loc 1 190 0
 674 004c 5098      		cbi 0xa,0
 675 004e 589A      		sbi 0xb,0
 676               	.LVL58:
 677               	.LBE205:
 678               	.LBE204:
 679               	.LBB206:
 680               	.LBB207:
 681               	.LBB208:
 682               		.loc 2 276 0
 683 0050 80E1      		ldi r24,lo8(16)
 684 0052 8A95      	1:	dec r24
 685 0054 01F4      		brne 1b
 686               	.LVL59:
 687               	.LBE208:
 688               	.LBE207:
 689               	.LBE206:
 690               	.LBE198:
 691               	.LBE197:
 369:quantum/split_common/serial.c ****     // target switch to input
 370:quantum/split_common/serial.c ****     change_sender2reciver();
 371:quantum/split_common/serial.c **** 
 372:quantum/split_common/serial.c ****     // target recive phase
 373:quantum/split_common/serial.c ****     if (trans->initiator2target_buffer_size > 0) {
 692               		.loc 1 373 0
 693 0056 6A81      		ldd r22,Y+2
 694 0058 6623      		tst r22
 695 005a 01F0      		breq .L41
 374:quantum/split_common/serial.c ****         if (serial_recive_packet((uint8_t *)trans->initiator2target_buffer, trans->initiator2target
 696               		.loc 1 374 0
 697 005c 8B81      		ldd r24,Y+3
 698 005e 9C81      		ldd r25,Y+4
 699 0060 0E94 0000 		call serial_recive_packet
 700               	.LVL60:
 701 0064 E881      		ld r30,Y
 702 0066 F981      		ldd r31,Y+1
 703 0068 8111      		cpse r24,__zero_reg__
 704 006a 00C0      		rjmp .L47
 375:quantum/split_common/serial.c ****             *trans->status = TRANSACTION_ACCEPTED;
 376:quantum/split_common/serial.c ****         } else {
 377:quantum/split_common/serial.c ****             *trans->status = TRANSACTION_DATA_ERROR;
 705               		.loc 1 377 0
 706 006c 82E0      		ldi r24,lo8(2)
 707 006e 00C0      		rjmp .L48
 708               	.L41:
 378:quantum/split_common/serial.c ****         }
 379:quantum/split_common/serial.c ****     } else {
 380:quantum/split_common/serial.c ****         *trans->status = TRANSACTION_ACCEPTED;
 709               		.loc 1 380 0
 710 0070 E881      		ld r30,Y
 711 0072 F981      		ldd r31,Y+1
 712               	.L47:
 713 0074 88E0      		ldi r24,lo8(8)
 714               	.L48:
 715 0076 8083      		st Z,r24
 381:quantum/split_common/serial.c ****     }
 382:quantum/split_common/serial.c **** 
 383:quantum/split_common/serial.c ****     sync_recv();  // weit initiator output to high
 716               		.loc 1 383 0
 717 0078 0E94 0000 		call sync_recv
 718               	.LVL61:
 719               	/* epilogue start */
 384:quantum/split_common/serial.c **** }
 720               		.loc 1 384 0
 721 007c FF91      		pop r31
 722 007e EF91      		pop r30
 723 0080 DF91      		pop r29
 724 0082 CF91      		pop r28
 725               	.LVL62:
 726 0084 BF91      		pop r27
 727 0086 AF91      		pop r26
 728 0088 9F91      		pop r25
 729 008a 8F91      		pop r24
 730 008c 7F91      		pop r23
 731 008e 6F91      		pop r22
 732 0090 5F91      		pop r21
 733 0092 4F91      		pop r20
 734 0094 3F91      		pop r19
 735 0096 2F91      		pop r18
 736 0098 0F90      		pop r0
 737 009a 0FBE      		out __SREG__,r0
 738 009c 0F90      		pop r0
 739 009e 1F90      		pop r1
 740 00a0 1895      		reti
 741               		.cfi_endproc
 742               	.LFE25:
 744               		.section	.text.soft_serial_transaction,"ax",@progbits
 745               	.global	soft_serial_transaction
 747               	soft_serial_transaction:
 748               	.LFB26:
 385:quantum/split_common/serial.c **** 
 386:quantum/split_common/serial.c **** /////////
 387:quantum/split_common/serial.c **** //  start transaction by initiator
 388:quantum/split_common/serial.c **** //
 389:quantum/split_common/serial.c **** // int  soft_serial_transaction(int sstd_index)
 390:quantum/split_common/serial.c **** //
 391:quantum/split_common/serial.c **** // Returns:
 392:quantum/split_common/serial.c **** //    TRANSACTION_END
 393:quantum/split_common/serial.c **** //    TRANSACTION_NO_RESPONSE
 394:quantum/split_common/serial.c **** //    TRANSACTION_DATA_ERROR
 395:quantum/split_common/serial.c **** // this code is very time dependent, so we need to disable interrupts
 396:quantum/split_common/serial.c **** #    ifndef SERIAL_USE_MULTI_TRANSACTION
 397:quantum/split_common/serial.c **** int soft_serial_transaction(void) {
 749               		.loc 1 397 0
 750               		.cfi_startproc
 751 0000 CF93      		push r28
 752               	.LCFI29:
 753               		.cfi_def_cfa_offset 3
 754               		.cfi_offset 28, -2
 755 0002 DF93      		push r29
 756               	.LCFI30:
 757               		.cfi_def_cfa_offset 4
 758               		.cfi_offset 29, -3
 759               	/* prologue: function */
 760               	/* frame size = 0 */
 761               	/* stack size = 2 */
 762               	.L__stack_usage = 2
 398:quantum/split_common/serial.c ****     SSTD_t *trans = Transaction_table;
 763               		.loc 1 398 0
 764 0004 C091 0000 		lds r28,Transaction_table
 765 0008 D091 0000 		lds r29,Transaction_table+1
 766               	.LVL63:
 399:quantum/split_common/serial.c **** #    else
 400:quantum/split_common/serial.c **** int soft_serial_transaction(int sstd_index) {
 401:quantum/split_common/serial.c ****     if (sstd_index > Transaction_table_size) return TRANSACTION_TYPE_ERROR;
 402:quantum/split_common/serial.c ****     SSTD_t *trans = &Transaction_table[sstd_index];
 403:quantum/split_common/serial.c **** #    endif
 404:quantum/split_common/serial.c ****     cli();
 767               		.loc 1 404 0
 768               	/* #APP */
 769               	 ;  404 "quantum/split_common/serial.c" 1
 770 000c F894      		cli
 771               	 ;  0 "" 2
 772               	/* #NOAPP */
 773               	.LBB241:
 774               	.LBB242:
 186:quantum/split_common/serial.c **** 
 775               		.loc 1 186 0
 776 000e 509A      		sbi 0xa,0
 777               	.LBE242:
 778               	.LBE241:
 779               	.LBB243:
 780               	.LBB244:
 196:quantum/split_common/serial.c **** 
 781               		.loc 1 196 0
 782 0010 5898      		cbi 0xb,0
 783               	.LVL64:
 784               	.LBE244:
 785               	.LBE243:
 786               	.LBB245:
 787               	.LBB246:
 788               		.loc 2 276 0
 789 0012 85E0      		ldi r24,lo8(5)
 790 0014 8A95      	1:	dec r24
 791 0016 01F4      		brne 1b
 792 0018 0000      		nop
 793               	.LVL65:
 794               	.LBE246:
 795               	.LBE245:
 796               	.LBB247:
 797               	.LBB248:
 190:quantum/split_common/serial.c **** 
 798               		.loc 1 190 0
 799 001a 5098      		cbi 0xa,0
 800 001c 589A      		sbi 0xb,0
 801               	.LVL66:
 802               	.LBE248:
 803               	.LBE247:
 804               	.LBB249:
 805               	.LBB250:
 806               		.loc 2 276 0
 807 001e 80E2      		ldi r24,lo8(32)
 808 0020 8A95      	1:	dec r24
 809 0022 01F4      		brne 1b
 810               	.LVL67:
 811               	.LBE250:
 812               	.LBE249:
 405:quantum/split_common/serial.c **** 
 406:quantum/split_common/serial.c ****     // signal to the target that we want to start a transaction
 407:quantum/split_common/serial.c ****     serial_output();
 408:quantum/split_common/serial.c ****     serial_low();
 409:quantum/split_common/serial.c ****     _delay_us(SLAVE_INT_WIDTH_US);
 410:quantum/split_common/serial.c **** 
 411:quantum/split_common/serial.c **** #    ifndef SERIAL_USE_MULTI_TRANSACTION
 412:quantum/split_common/serial.c ****     // wait for the target response
 413:quantum/split_common/serial.c ****     serial_input_with_pullup();
 414:quantum/split_common/serial.c ****     _delay_us(SLAVE_INT_RESPONSE_TIME);
 415:quantum/split_common/serial.c **** 
 416:quantum/split_common/serial.c ****     // check if the target is present
 417:quantum/split_common/serial.c ****     if (serial_read_pin()) {
 813               		.loc 1 417 0
 814 0024 489B      		sbis 0x9,0
 815 0026 00C0      		rjmp .L50
 816               	.LBB251:
 817               	.LBB252:
 186:quantum/split_common/serial.c **** 
 818               		.loc 1 186 0
 819 0028 509A      		sbi 0xa,0
 820               	.LBE252:
 821               	.LBE251:
 822               	.LBB253:
 823               	.LBB254:
 199:quantum/split_common/serial.c **** 
 824               		.loc 1 199 0
 825 002a 589A      		sbi 0xb,0
 826               	.LBE254:
 827               	.LBE253:
 418:quantum/split_common/serial.c ****         // target failed to pull the line low, assume not present
 419:quantum/split_common/serial.c ****         serial_output();
 420:quantum/split_common/serial.c ****         serial_high();
 421:quantum/split_common/serial.c ****         *trans->status = TRANSACTION_NO_RESPONSE;
 828               		.loc 1 421 0
 829 002c E881      		ld r30,Y
 830 002e F981      		ldd r31,Y+1
 831 0030 81E0      		ldi r24,lo8(1)
 832 0032 8083      		st Z,r24
 422:quantum/split_common/serial.c ****         sei();
 833               		.loc 1 422 0
 834               	/* #APP */
 835               	 ;  422 "quantum/split_common/serial.c" 1
 836 0034 7894      		sei
 837               	 ;  0 "" 2
 423:quantum/split_common/serial.c ****         return TRANSACTION_NO_RESPONSE;
 838               		.loc 1 423 0
 839               	/* #NOAPP */
 840 0036 81E0      		ldi r24,lo8(1)
 841 0038 90E0      		ldi r25,0
 842 003a 00C0      		rjmp .L51
 843               	.L50:
 424:quantum/split_common/serial.c ****     }
 425:quantum/split_common/serial.c **** 
 426:quantum/split_common/serial.c **** #    else
 427:quantum/split_common/serial.c ****     // send transaction table index
 428:quantum/split_common/serial.c ****     int tid = (sstd_index << 3) | (7 & nibble_bits_count(sstd_index));
 429:quantum/split_common/serial.c ****     sync_send();
 430:quantum/split_common/serial.c ****     _delay_sub_us(TID_SEND_ADJUST);
 431:quantum/split_common/serial.c ****     serial_write_chunk(tid, 7);
 432:quantum/split_common/serial.c ****     serial_delay_half1();
 433:quantum/split_common/serial.c **** 
 434:quantum/split_common/serial.c ****     // wait for the target response (step1 low->high)
 435:quantum/split_common/serial.c ****     serial_input_with_pullup();
 436:quantum/split_common/serial.c ****     while (!serial_read_pin()) {
 437:quantum/split_common/serial.c ****         _delay_sub_us(2);
 438:quantum/split_common/serial.c ****     }
 439:quantum/split_common/serial.c **** 
 440:quantum/split_common/serial.c ****     // check if the target is present (step2 high->low)
 441:quantum/split_common/serial.c ****     for (int i = 0; serial_read_pin(); i++) {
 442:quantum/split_common/serial.c ****         if (i > SLAVE_INT_ACK_WIDTH + 1) {
 443:quantum/split_common/serial.c ****             // slave failed to pull the line low, assume not present
 444:quantum/split_common/serial.c ****             serial_output();
 445:quantum/split_common/serial.c ****             serial_high();
 446:quantum/split_common/serial.c ****             *trans->status = TRANSACTION_NO_RESPONSE;
 447:quantum/split_common/serial.c ****             sei();
 448:quantum/split_common/serial.c ****             return TRANSACTION_NO_RESPONSE;
 449:quantum/split_common/serial.c ****         }
 450:quantum/split_common/serial.c ****         _delay_sub_us(SLAVE_INT_ACK_WIDTH_UNIT);
 451:quantum/split_common/serial.c ****     }
 452:quantum/split_common/serial.c **** #    endif
 453:quantum/split_common/serial.c **** 
 454:quantum/split_common/serial.c ****     // initiator recive phase
 455:quantum/split_common/serial.c ****     // if the target is present syncronize with it
 456:quantum/split_common/serial.c ****     if (trans->target2initiator_buffer_size > 0) {
 844               		.loc 1 456 0
 845 003c 6D81      		ldd r22,Y+5
 846 003e 6623      		tst r22
 847 0040 01F0      		breq .L52
 457:quantum/split_common/serial.c ****         if (!serial_recive_packet((uint8_t *)trans->target2initiator_buffer, trans->target2initiato
 848               		.loc 1 457 0
 849 0042 8E81      		ldd r24,Y+6
 850 0044 9F81      		ldd r25,Y+7
 851 0046 0E94 0000 		call serial_recive_packet
 852               	.LVL68:
 853 004a 8111      		cpse r24,__zero_reg__
 854 004c 00C0      		rjmp .L52
 855               	.LBB255:
 856               	.LBB256:
 186:quantum/split_common/serial.c **** 
 857               		.loc 1 186 0
 858 004e 509A      		sbi 0xa,0
 859               	.LBE256:
 860               	.LBE255:
 861               	.LBB257:
 862               	.LBB258:
 199:quantum/split_common/serial.c **** 
 863               		.loc 1 199 0
 864 0050 589A      		sbi 0xb,0
 865               	.LBE258:
 866               	.LBE257:
 458:quantum/split_common/serial.c ****             serial_output();
 459:quantum/split_common/serial.c ****             serial_high();
 460:quantum/split_common/serial.c ****             *trans->status = TRANSACTION_DATA_ERROR;
 867               		.loc 1 460 0
 868 0052 E881      		ld r30,Y
 869 0054 F981      		ldd r31,Y+1
 870 0056 82E0      		ldi r24,lo8(2)
 871 0058 8083      		st Z,r24
 461:quantum/split_common/serial.c ****             sei();
 872               		.loc 1 461 0
 873               	/* #APP */
 874               	 ;  461 "quantum/split_common/serial.c" 1
 875 005a 7894      		sei
 876               	 ;  0 "" 2
 462:quantum/split_common/serial.c ****             return TRANSACTION_DATA_ERROR;
 877               		.loc 1 462 0
 878               	/* #NOAPP */
 879 005c 82E0      		ldi r24,lo8(2)
 880 005e 90E0      		ldi r25,0
 881 0060 00C0      		rjmp .L51
 882               	.L52:
 883               	.LBB259:
 884               	.LBB260:
 328:quantum/split_common/serial.c ****     serial_delay();        // 1
 885               		.loc 1 328 0
 886 0062 0E94 0000 		call sync_recv
 887               	.LVL69:
 888               	.LBB261:
 889               	.LBB262:
 890               	.LBB263:
 891               		.loc 2 276 0
 892 0066 80E2      		ldi r24,lo8(32)
 893 0068 8A95      	1:	dec r24
 894 006a 01F4      		brne 1b
 895               	.LVL70:
 896               	.LBE263:
 897               	.LBE262:
 898               	.LBE261:
 899               	.LBB264:
 900               	.LBB265:
 196:quantum/split_common/serial.c **** 
 901               		.loc 1 196 0
 902 006c 5898      		cbi 0xb,0
 903               	.LBE265:
 904               	.LBE264:
 905               	.LBB266:
 906               	.LBB267:
 186:quantum/split_common/serial.c **** 
 907               		.loc 1 186 0
 908 006e 509A      		sbi 0xa,0
 909               	.LVL71:
 910               	.LBE267:
 911               	.LBE266:
 912               	.LBB268:
 913               	.LBB269:
 914               	.LBB270:
 915               		.loc 2 276 0
 916 0070 80E1      		ldi r24,lo8(16)
 917 0072 8A95      	1:	dec r24
 918 0074 01F4      		brne 1b
 919               	.LVL72:
 920               	.LBE270:
 921               	.LBE269:
 922               	.LBE268:
 923               	.LBE260:
 924               	.LBE259:
 463:quantum/split_common/serial.c ****         }
 464:quantum/split_common/serial.c ****     }
 465:quantum/split_common/serial.c **** 
 466:quantum/split_common/serial.c ****     // initiator switch to output
 467:quantum/split_common/serial.c ****     change_reciver2sender();
 468:quantum/split_common/serial.c **** 
 469:quantum/split_common/serial.c ****     // initiator send phase
 470:quantum/split_common/serial.c ****     if (trans->initiator2target_buffer_size > 0) {
 925               		.loc 1 470 0
 926 0076 6A81      		ldd r22,Y+2
 927 0078 6623      		tst r22
 928 007a 01F0      		breq .L53
 471:quantum/split_common/serial.c ****         serial_send_packet((uint8_t *)trans->initiator2target_buffer, trans->initiator2target_buffe
 929               		.loc 1 471 0
 930 007c 8B81      		ldd r24,Y+3
 931 007e 9C81      		ldd r25,Y+4
 932 0080 0E94 0000 		call serial_send_packet
 933               	.LVL73:
 934               	.L53:
 472:quantum/split_common/serial.c ****     }
 473:quantum/split_common/serial.c **** 
 474:quantum/split_common/serial.c ****     // always, release the line when not in use
 475:quantum/split_common/serial.c ****     sync_send();
 935               		.loc 1 475 0
 936 0084 0E94 0000 		call sync_send
 937               	.LVL74:
 476:quantum/split_common/serial.c **** 
 477:quantum/split_common/serial.c ****     *trans->status = TRANSACTION_END;
 938               		.loc 1 477 0
 939 0088 E881      		ld r30,Y
 940 008a F981      		ldd r31,Y+1
 941 008c 1082      		st Z,__zero_reg__
 478:quantum/split_common/serial.c ****     sei();
 942               		.loc 1 478 0
 943               	/* #APP */
 944               	 ;  478 "quantum/split_common/serial.c" 1
 945 008e 7894      		sei
 946               	 ;  0 "" 2
 479:quantum/split_common/serial.c ****     return TRANSACTION_END;
 947               		.loc 1 479 0
 948               	/* #NOAPP */
 949 0090 80E0      		ldi r24,0
 950 0092 90E0      		ldi r25,0
 951               	.L51:
 952               	/* epilogue start */
 480:quantum/split_common/serial.c **** }
 953               		.loc 1 480 0
 954 0094 DF91      		pop r29
 955 0096 CF91      		pop r28
 956               	.LVL75:
 957 0098 0895      		ret
 958               		.cfi_endproc
 959               	.LFE26:
 961               		.section	.bss.Transaction_table,"aw",@nobits
 964               	Transaction_table:
 965 0000 0000      		.zero	2
 966               		.text
 967               	.Letext0:
 968               		.file 3 "/usr/lib/avr/include/stdint.h"
 969               		.file 4 "quantum/split_common/serial.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 serial.c
     /tmp/ccidpkFH.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccidpkFH.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccidpkFH.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccidpkFH.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccidpkFH.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccidpkFH.s:12     .text.sync_recv:0000000000000000 sync_recv
     /tmp/ccidpkFH.s:49     .text.sync_send:0000000000000000 sync_send
     /tmp/ccidpkFH.s:88     .text.serial_read_chunk.constprop.0:0000000000000000 serial_read_chunk.constprop.0
     /tmp/ccidpkFH.s:203    .text.serial_recive_packet:0000000000000000 serial_recive_packet
     /tmp/ccidpkFH.s:299    .text.soft_serial_initiator_init:0000000000000000 soft_serial_initiator_init
     /tmp/ccidpkFH.s:964    .bss.Transaction_table:0000000000000000 Transaction_table
     /tmp/ccidpkFH.s:330    .text.soft_serial_target_init:0000000000000000 soft_serial_target_init
     /tmp/ccidpkFH.s:366    .text.serial_write_chunk:0000000000000000 serial_write_chunk
     /tmp/ccidpkFH.s:475    .text.serial_send_packet:0000000000000000 serial_send_packet
     /tmp/ccidpkFH.s:548    .text.__vector_1:0000000000000000 __vector_1
     /tmp/ccidpkFH.s:747    .text.soft_serial_transaction:0000000000000000 soft_serial_transaction

UNDEFINED SYMBOLS
__do_clear_bss
