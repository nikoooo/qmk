   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.matrix_slave_scan_user,"ax",@progbits
  11               		.weak	matrix_slave_scan_user
  13               	matrix_slave_scan_user:
  14               	.LFB24:
  15               		.file 1 "quantum/split_common/matrix.c"
   1:quantum/split_common/matrix.c **** /*
   2:quantum/split_common/matrix.c **** Copyright 2012 Jun Wako <wakojun@gmail.com>
   3:quantum/split_common/matrix.c **** 
   4:quantum/split_common/matrix.c **** This program is free software: you can redistribute it and/or modify
   5:quantum/split_common/matrix.c **** it under the terms of the GNU General Public License as published by
   6:quantum/split_common/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/split_common/matrix.c **** (at your option) any later version.
   8:quantum/split_common/matrix.c **** 
   9:quantum/split_common/matrix.c **** This program is distributed in the hope that it will be useful,
  10:quantum/split_common/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/split_common/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/split_common/matrix.c **** GNU General Public License for more details.
  13:quantum/split_common/matrix.c **** 
  14:quantum/split_common/matrix.c **** You should have received a copy of the GNU General Public License
  15:quantum/split_common/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/split_common/matrix.c **** */
  17:quantum/split_common/matrix.c **** 
  18:quantum/split_common/matrix.c **** /*
  19:quantum/split_common/matrix.c ****  * scan matrix
  20:quantum/split_common/matrix.c ****  */
  21:quantum/split_common/matrix.c **** #include <stdint.h>
  22:quantum/split_common/matrix.c **** #include <stdbool.h>
  23:quantum/split_common/matrix.c **** #include "wait.h"
  24:quantum/split_common/matrix.c **** #include "util.h"
  25:quantum/split_common/matrix.c **** #include "matrix.h"
  26:quantum/split_common/matrix.c **** #include "split_util.h"
  27:quantum/split_common/matrix.c **** #include "config.h"
  28:quantum/split_common/matrix.c **** #include "quantum.h"
  29:quantum/split_common/matrix.c **** #include "debounce.h"
  30:quantum/split_common/matrix.c **** #include "transport.h"
  31:quantum/split_common/matrix.c **** 
  32:quantum/split_common/matrix.c **** #ifdef ENCODER_ENABLE
  33:quantum/split_common/matrix.c **** #    include "encoder.h"
  34:quantum/split_common/matrix.c **** #endif
  35:quantum/split_common/matrix.c **** 
  36:quantum/split_common/matrix.c **** #if (MATRIX_COLS <= 8)
  37:quantum/split_common/matrix.c **** #    define print_matrix_header() print("\nr/c 01234567\n")
  38:quantum/split_common/matrix.c **** #    define print_matrix_row(row) print_bin_reverse8(matrix_get_row(row))
  39:quantum/split_common/matrix.c **** #    define matrix_bitpop(i) bitpop(matrix[i])
  40:quantum/split_common/matrix.c **** #    define ROW_SHIFTER ((uint8_t)1)
  41:quantum/split_common/matrix.c **** #elif (MATRIX_COLS <= 16)
  42:quantum/split_common/matrix.c **** #    define print_matrix_header() print("\nr/c 0123456789ABCDEF\n")
  43:quantum/split_common/matrix.c **** #    define print_matrix_row(row) print_bin_reverse16(matrix_get_row(row))
  44:quantum/split_common/matrix.c **** #    define matrix_bitpop(i) bitpop16(matrix[i])
  45:quantum/split_common/matrix.c **** #    define ROW_SHIFTER ((uint16_t)1)
  46:quantum/split_common/matrix.c **** #elif (MATRIX_COLS <= 32)
  47:quantum/split_common/matrix.c **** #    define print_matrix_header() print("\nr/c 0123456789ABCDEF0123456789ABCDEF\n")
  48:quantum/split_common/matrix.c **** #    define print_matrix_row(row) print_bin_reverse32(matrix_get_row(row))
  49:quantum/split_common/matrix.c **** #    define matrix_bitpop(i) bitpop32(matrix[i])
  50:quantum/split_common/matrix.c **** #    define ROW_SHIFTER ((uint32_t)1)
  51:quantum/split_common/matrix.c **** #endif
  52:quantum/split_common/matrix.c **** 
  53:quantum/split_common/matrix.c **** #define ERROR_DISCONNECT_COUNT 5
  54:quantum/split_common/matrix.c **** 
  55:quantum/split_common/matrix.c **** #define ROWS_PER_HAND (MATRIX_ROWS / 2)
  56:quantum/split_common/matrix.c **** 
  57:quantum/split_common/matrix.c **** #ifdef DIRECT_PINS
  58:quantum/split_common/matrix.c **** static pin_t direct_pins[MATRIX_ROWS][MATRIX_COLS] = DIRECT_PINS;
  59:quantum/split_common/matrix.c **** #else
  60:quantum/split_common/matrix.c **** static pin_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  61:quantum/split_common/matrix.c **** static pin_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  62:quantum/split_common/matrix.c **** #endif
  63:quantum/split_common/matrix.c **** 
  64:quantum/split_common/matrix.c **** /* matrix state(1:on, 0:off) */
  65:quantum/split_common/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  66:quantum/split_common/matrix.c **** static matrix_row_t raw_matrix[ROWS_PER_HAND];
  67:quantum/split_common/matrix.c **** 
  68:quantum/split_common/matrix.c **** // row offsets for each hand
  69:quantum/split_common/matrix.c **** uint8_t thisHand, thatHand;
  70:quantum/split_common/matrix.c **** 
  71:quantum/split_common/matrix.c **** // user-defined overridable functions
  72:quantum/split_common/matrix.c **** 
  73:quantum/split_common/matrix.c **** __attribute__((weak)) void matrix_init_kb(void) { matrix_init_user(); }
  74:quantum/split_common/matrix.c **** 
  75:quantum/split_common/matrix.c **** __attribute__((weak)) void matrix_scan_kb(void) { matrix_scan_user(); }
  76:quantum/split_common/matrix.c **** 
  77:quantum/split_common/matrix.c **** __attribute__((weak)) void matrix_init_user(void) {}
  78:quantum/split_common/matrix.c **** 
  79:quantum/split_common/matrix.c **** __attribute__((weak)) void matrix_scan_user(void) {}
  80:quantum/split_common/matrix.c **** 
  81:quantum/split_common/matrix.c **** __attribute__((weak)) void matrix_slave_scan_user(void) {}
  16               		.loc 1 81 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22 0000 0895      		ret
  23               		.cfi_endproc
  24               	.LFE24:
  26               		.set	matrix_slave_scan_user.localalias.0,matrix_slave_scan_user
  27               		.section	.text.matrix_scan_user,"ax",@progbits
  28               		.weak	matrix_scan_user
  30               	matrix_scan_user:
  31               	.LFB41:
  32               		.cfi_startproc
  33               	/* prologue: function */
  34               	/* frame size = 0 */
  35               	/* stack size = 0 */
  36               	.L__stack_usage = 0
  37 0000 0C94 0000 		jmp matrix_slave_scan_user.localalias.0
  38               		.cfi_endproc
  39               	.LFE41:
  41               		.section	.text.matrix_scan_kb,"ax",@progbits
  42               		.weak	matrix_scan_kb
  44               	matrix_scan_kb:
  45               	.LFB21:
  75:quantum/split_common/matrix.c **** 
  46               		.loc 1 75 0
  47               		.cfi_startproc
  48               	/* prologue: function */
  49               	/* frame size = 0 */
  50               	/* stack size = 0 */
  51               	.L__stack_usage = 0
  75:quantum/split_common/matrix.c **** 
  52               		.loc 1 75 0
  53 0000 0C94 0000 		jmp matrix_scan_user
  54               	.LVL0:
  55               		.cfi_endproc
  56               	.LFE21:
  58               		.section	.text.matrix_init_user,"ax",@progbits
  59               		.weak	matrix_init_user
  61               	matrix_init_user:
  62               	.LFB43:
  63               		.cfi_startproc
  64               	/* prologue: function */
  65               	/* frame size = 0 */
  66               	/* stack size = 0 */
  67               	.L__stack_usage = 0
  68 0000 0C94 0000 		jmp matrix_slave_scan_user.localalias.0
  69               		.cfi_endproc
  70               	.LFE43:
  72               		.section	.text.matrix_init_kb,"ax",@progbits
  73               		.weak	matrix_init_kb
  75               	matrix_init_kb:
  76               	.LFB20:
  73:quantum/split_common/matrix.c **** 
  77               		.loc 1 73 0
  78               		.cfi_startproc
  79               	/* prologue: function */
  80               	/* frame size = 0 */
  81               	/* stack size = 0 */
  82               	.L__stack_usage = 0
  73:quantum/split_common/matrix.c **** 
  83               		.loc 1 73 0
  84 0000 0C94 0000 		jmp matrix_init_user
  85               	.LVL1:
  86               		.cfi_endproc
  87               	.LFE20:
  89               		.section	.text.matrix_rows,"ax",@progbits
  90               	.global	matrix_rows
  92               	matrix_rows:
  93               	.LFB25:
  82:quantum/split_common/matrix.c **** 
  83:quantum/split_common/matrix.c **** // helper functions
  84:quantum/split_common/matrix.c **** 
  85:quantum/split_common/matrix.c **** inline uint8_t matrix_rows(void) { return MATRIX_ROWS; }
  94               		.loc 1 85 0
  95               		.cfi_startproc
  96               	/* prologue: function */
  97               	/* frame size = 0 */
  98               	/* stack size = 0 */
  99               	.L__stack_usage = 0
 100               		.loc 1 85 0
 101 0000 88E0      		ldi r24,lo8(8)
 102 0002 0895      		ret
 103               		.cfi_endproc
 104               	.LFE25:
 106               		.section	.text.matrix_cols,"ax",@progbits
 107               	.global	matrix_cols
 109               	matrix_cols:
 110               	.LFB26:
  86:quantum/split_common/matrix.c **** 
  87:quantum/split_common/matrix.c **** inline uint8_t matrix_cols(void) { return MATRIX_COLS; }
 111               		.loc 1 87 0
 112               		.cfi_startproc
 113               	/* prologue: function */
 114               	/* frame size = 0 */
 115               	/* stack size = 0 */
 116               	.L__stack_usage = 0
 117               		.loc 1 87 0
 118 0000 87E0      		ldi r24,lo8(7)
 119 0002 0895      		ret
 120               		.cfi_endproc
 121               	.LFE26:
 123               		.section	.text.matrix_is_modified,"ax",@progbits
 124               	.global	matrix_is_modified
 126               	matrix_is_modified:
 127               	.LFB27:
  88:quantum/split_common/matrix.c **** 
  89:quantum/split_common/matrix.c **** bool matrix_is_modified(void) {
 128               		.loc 1 89 0
 129               		.cfi_startproc
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 0 */
 133               	.L__stack_usage = 0
  90:quantum/split_common/matrix.c ****     if (debounce_active()) return false;
 134               		.loc 1 90 0
 135 0000 0E94 0000 		call debounce_active
 136               	.LVL2:
  91:quantum/split_common/matrix.c ****     return true;
  92:quantum/split_common/matrix.c **** }
 137               		.loc 1 92 0
 138 0004 91E0      		ldi r25,lo8(1)
 139 0006 8927      		eor r24,r25
 140 0008 0895      		ret
 141               		.cfi_endproc
 142               	.LFE27:
 144               		.section	.text.matrix_is_on,"ax",@progbits
 145               	.global	matrix_is_on
 147               	matrix_is_on:
 148               	.LFB28:
  93:quantum/split_common/matrix.c **** 
  94:quantum/split_common/matrix.c **** inline bool matrix_is_on(uint8_t row, uint8_t col) { return (matrix[row] & ((matrix_row_t)1 << col)
 149               		.loc 1 94 0
 150               		.cfi_startproc
 151               	.LVL3:
 152               	/* prologue: function */
 153               	/* frame size = 0 */
 154               	/* stack size = 0 */
 155               	.L__stack_usage = 0
 156               		.loc 1 94 0
 157 0000 E82F      		mov r30,r24
 158 0002 F0E0      		ldi r31,0
 159 0004 E050      		subi r30,lo8(-(matrix))
 160 0006 F040      		sbci r31,hi8(-(matrix))
 161 0008 2081      		ld r18,Z
 162 000a 822F      		mov r24,r18
 163               	.LVL4:
 164 000c 90E0      		ldi r25,0
 165 000e 21E0      		ldi r18,lo8(1)
 166 0010 30E0      		ldi r19,0
 167 0012 00C0      		rjmp 2f
 168               		1:
 169 0014 220F      		lsl r18
 170 0016 331F      		rol r19
 171               		2:
 172 0018 6A95      		dec r22
 173 001a 02F4      		brpl 1b
 174 001c 2823      		and r18,r24
 175 001e 3923      		and r19,r25
 176 0020 81E0      		ldi r24,lo8(1)
 177 0022 232B      		or r18,r19
 178 0024 01F4      		brne .L10
 179 0026 80E0      		ldi r24,0
 180               	.L10:
 181 0028 0895      		ret
 182               		.cfi_endproc
 183               	.LFE28:
 185               		.section	.text.matrix_get_row,"ax",@progbits
 186               	.global	matrix_get_row
 188               	matrix_get_row:
 189               	.LFB29:
  95:quantum/split_common/matrix.c **** 
  96:quantum/split_common/matrix.c **** inline matrix_row_t matrix_get_row(uint8_t row) { return matrix[row]; }
 190               		.loc 1 96 0
 191               		.cfi_startproc
 192               	.LVL5:
 193               	/* prologue: function */
 194               	/* frame size = 0 */
 195               	/* stack size = 0 */
 196               	.L__stack_usage = 0
 197               		.loc 1 96 0
 198 0000 E82F      		mov r30,r24
 199 0002 F0E0      		ldi r31,0
 200 0004 E050      		subi r30,lo8(-(matrix))
 201 0006 F040      		sbci r31,hi8(-(matrix))
 202 0008 8081      		ld r24,Z
 203               	.LVL6:
 204 000a 0895      		ret
 205               		.cfi_endproc
 206               	.LFE29:
 208               		.section	.text.matrix_print,"ax",@progbits
 209               	.global	matrix_print
 211               	matrix_print:
 212               	.LFB30:
  97:quantum/split_common/matrix.c **** 
  98:quantum/split_common/matrix.c **** void matrix_print(void) {
 213               		.loc 1 98 0
 214               		.cfi_startproc
 215               	/* prologue: function */
 216               	/* frame size = 0 */
 217               	/* stack size = 0 */
 218               	.L__stack_usage = 0
 219               	.LVL7:
 220 0000 0895      		ret
 221               		.cfi_endproc
 222               	.LFE30:
 224               		.section	.text.matrix_key_count,"ax",@progbits
 225               	.global	matrix_key_count
 227               	matrix_key_count:
 228               	.LFB31:
  99:quantum/split_common/matrix.c ****     print_matrix_header();
 100:quantum/split_common/matrix.c **** 
 101:quantum/split_common/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 102:quantum/split_common/matrix.c ****         phex(row);
 103:quantum/split_common/matrix.c ****         print(": ");
 104:quantum/split_common/matrix.c ****         print_matrix_row(row);
 105:quantum/split_common/matrix.c ****         print("\n");
 106:quantum/split_common/matrix.c ****     }
 107:quantum/split_common/matrix.c **** }
 108:quantum/split_common/matrix.c **** 
 109:quantum/split_common/matrix.c **** uint8_t matrix_key_count(void) {
 229               		.loc 1 109 0
 230               		.cfi_startproc
 231               		.loc 1 109 0
 232 0000 0F93      		push r16
 233               	.LCFI0:
 234               		.cfi_def_cfa_offset 3
 235               		.cfi_offset 16, -2
 236 0002 1F93      		push r17
 237               	.LCFI1:
 238               		.cfi_def_cfa_offset 4
 239               		.cfi_offset 17, -3
 240 0004 CF93      		push r28
 241               	.LCFI2:
 242               		.cfi_def_cfa_offset 5
 243               		.cfi_offset 28, -4
 244               	/* prologue: function */
 245               	/* frame size = 0 */
 246               	/* stack size = 3 */
 247               	.L__stack_usage = 3
 248               	.LVL8:
 249 0006 00E0      		ldi r16,lo8(matrix)
 250 0008 10E0      		ldi r17,hi8(matrix)
 110:quantum/split_common/matrix.c ****     uint8_t count = 0;
 251               		.loc 1 110 0
 252 000a C0E0      		ldi r28,0
 253               	.LVL9:
 254               	.L15:
 255               	.LBB8:
 111:quantum/split_common/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 112:quantum/split_common/matrix.c ****         count += matrix_bitpop(i);
 256               		.loc 1 112 0 discriminator 3
 257 000c F801      		movw r30,r16
 258 000e 8191      		ld r24,Z+
 259 0010 8F01      		movw r16,r30
 260               	.LVL10:
 261 0012 0E94 0000 		call bitpop
 262               	.LVL11:
 263 0016 C80F      		add r28,r24
 264               	.LVL12:
 111:quantum/split_common/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 265               		.loc 1 111 0 discriminator 3
 266 0018 F0E0      		ldi r31,hi8(matrix+8)
 267 001a 0030      		cpi r16,lo8(matrix+8)
 268 001c 1F07      		cpc r17,r31
 269 001e 01F4      		brne .L15
 270               	.LBE8:
 113:quantum/split_common/matrix.c ****     }
 114:quantum/split_common/matrix.c ****     return count;
 115:quantum/split_common/matrix.c **** }
 271               		.loc 1 115 0
 272 0020 8C2F      		mov r24,r28
 273               	/* epilogue start */
 274 0022 CF91      		pop r28
 275               	.LVL13:
 276 0024 1F91      		pop r17
 277 0026 0F91      		pop r16
 278               	.LVL14:
 279 0028 0895      		ret
 280               		.cfi_endproc
 281               	.LFE31:
 283               		.section	.text.matrix_init,"ax",@progbits
 284               	.global	matrix_init
 286               	matrix_init:
 287               	.LFB37:
 116:quantum/split_common/matrix.c **** 
 117:quantum/split_common/matrix.c **** // matrix code
 118:quantum/split_common/matrix.c **** 
 119:quantum/split_common/matrix.c **** #ifdef DIRECT_PINS
 120:quantum/split_common/matrix.c **** 
 121:quantum/split_common/matrix.c **** static void init_pins(void) {
 122:quantum/split_common/matrix.c ****     for (int row = 0; row < MATRIX_ROWS; row++) {
 123:quantum/split_common/matrix.c ****         for (int col = 0; col < MATRIX_COLS; col++) {
 124:quantum/split_common/matrix.c ****             pin_t pin = direct_pins[row][col];
 125:quantum/split_common/matrix.c ****             if (pin != NO_PIN) {
 126:quantum/split_common/matrix.c ****                 setPinInputHigh(pin);
 127:quantum/split_common/matrix.c ****             }
 128:quantum/split_common/matrix.c ****         }
 129:quantum/split_common/matrix.c ****     }
 130:quantum/split_common/matrix.c **** }
 131:quantum/split_common/matrix.c **** 
 132:quantum/split_common/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row) {
 133:quantum/split_common/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 134:quantum/split_common/matrix.c ****     current_matrix[current_row] = 0;
 135:quantum/split_common/matrix.c **** 
 136:quantum/split_common/matrix.c ****     for (uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 137:quantum/split_common/matrix.c ****         pin_t pin = direct_pins[current_row][col_index];
 138:quantum/split_common/matrix.c ****         if (pin != NO_PIN) {
 139:quantum/split_common/matrix.c ****             current_matrix[current_row] |= readPin(pin) ? 0 : (ROW_SHIFTER << col_index);
 140:quantum/split_common/matrix.c ****         }
 141:quantum/split_common/matrix.c ****     }
 142:quantum/split_common/matrix.c **** 
 143:quantum/split_common/matrix.c ****     return (last_row_value != current_matrix[current_row]);
 144:quantum/split_common/matrix.c **** }
 145:quantum/split_common/matrix.c **** 
 146:quantum/split_common/matrix.c **** #elif (DIODE_DIRECTION == COL2ROW)
 147:quantum/split_common/matrix.c **** 
 148:quantum/split_common/matrix.c **** static void select_row(uint8_t row) {
 149:quantum/split_common/matrix.c ****     setPinOutput(row_pins[row]);
 150:quantum/split_common/matrix.c ****     writePinLow(row_pins[row]);
 151:quantum/split_common/matrix.c **** }
 152:quantum/split_common/matrix.c **** 
 153:quantum/split_common/matrix.c **** static void unselect_row(uint8_t row) { setPinInputHigh(row_pins[row]); }
 154:quantum/split_common/matrix.c **** 
 155:quantum/split_common/matrix.c **** static void unselect_rows(void) {
 156:quantum/split_common/matrix.c ****     for (uint8_t x = 0; x < ROWS_PER_HAND; x++) {
 157:quantum/split_common/matrix.c ****         setPinInputHigh(row_pins[x]);
 158:quantum/split_common/matrix.c ****     }
 159:quantum/split_common/matrix.c **** }
 160:quantum/split_common/matrix.c **** 
 161:quantum/split_common/matrix.c **** static void init_pins(void) {
 162:quantum/split_common/matrix.c ****     unselect_rows();
 163:quantum/split_common/matrix.c ****     for (uint8_t x = 0; x < MATRIX_COLS; x++) {
 164:quantum/split_common/matrix.c ****         setPinInputHigh(col_pins[x]);
 165:quantum/split_common/matrix.c ****     }
 166:quantum/split_common/matrix.c **** }
 167:quantum/split_common/matrix.c **** 
 168:quantum/split_common/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row) {
 169:quantum/split_common/matrix.c ****     // Store last value of row prior to reading
 170:quantum/split_common/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 171:quantum/split_common/matrix.c **** 
 172:quantum/split_common/matrix.c ****     // Clear data in matrix row
 173:quantum/split_common/matrix.c ****     current_matrix[current_row] = 0;
 174:quantum/split_common/matrix.c **** 
 175:quantum/split_common/matrix.c ****     // Select row and wait for row selecton to stabilize
 176:quantum/split_common/matrix.c ****     select_row(current_row);
 177:quantum/split_common/matrix.c ****     wait_us(30);
 178:quantum/split_common/matrix.c **** 
 179:quantum/split_common/matrix.c ****     // For each col...
 180:quantum/split_common/matrix.c ****     for (uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 181:quantum/split_common/matrix.c ****         // Populate the matrix row with the state of the col pin
 182:quantum/split_common/matrix.c ****         current_matrix[current_row] |= readPin(col_pins[col_index]) ? 0 : (ROW_SHIFTER << col_index
 183:quantum/split_common/matrix.c ****     }
 184:quantum/split_common/matrix.c **** 
 185:quantum/split_common/matrix.c ****     // Unselect row
 186:quantum/split_common/matrix.c ****     unselect_row(current_row);
 187:quantum/split_common/matrix.c **** 
 188:quantum/split_common/matrix.c ****     return (last_row_value != current_matrix[current_row]);
 189:quantum/split_common/matrix.c **** }
 190:quantum/split_common/matrix.c **** 
 191:quantum/split_common/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
 192:quantum/split_common/matrix.c **** 
 193:quantum/split_common/matrix.c **** static void select_col(uint8_t col) {
 194:quantum/split_common/matrix.c ****     setPinOutput(col_pins[col]);
 195:quantum/split_common/matrix.c ****     writePinLow(col_pins[col]);
 196:quantum/split_common/matrix.c **** }
 197:quantum/split_common/matrix.c **** 
 198:quantum/split_common/matrix.c **** static void unselect_col(uint8_t col) { setPinInputHigh(col_pins[col]); }
 199:quantum/split_common/matrix.c **** 
 200:quantum/split_common/matrix.c **** static void unselect_cols(void) {
 201:quantum/split_common/matrix.c ****     for (uint8_t x = 0; x < MATRIX_COLS; x++) {
 202:quantum/split_common/matrix.c ****         setPinInputHigh(col_pins[x]);
 203:quantum/split_common/matrix.c ****     }
 204:quantum/split_common/matrix.c **** }
 205:quantum/split_common/matrix.c **** 
 206:quantum/split_common/matrix.c **** static void init_pins(void) {
 207:quantum/split_common/matrix.c ****     unselect_cols();
 208:quantum/split_common/matrix.c ****     for (uint8_t x = 0; x < ROWS_PER_HAND; x++) {
 209:quantum/split_common/matrix.c ****         setPinInputHigh(row_pins[x]);
 210:quantum/split_common/matrix.c ****     }
 211:quantum/split_common/matrix.c **** }
 212:quantum/split_common/matrix.c **** 
 213:quantum/split_common/matrix.c **** static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col) {
 214:quantum/split_common/matrix.c ****     bool matrix_changed = false;
 215:quantum/split_common/matrix.c **** 
 216:quantum/split_common/matrix.c ****     // Select col and wait for col selecton to stabilize
 217:quantum/split_common/matrix.c ****     select_col(current_col);
 218:quantum/split_common/matrix.c ****     wait_us(30);
 219:quantum/split_common/matrix.c **** 
 220:quantum/split_common/matrix.c ****     // For each row...
 221:quantum/split_common/matrix.c ****     for (uint8_t row_index = 0; row_index < ROWS_PER_HAND; row_index++) {
 222:quantum/split_common/matrix.c ****         // Store last value of row prior to reading
 223:quantum/split_common/matrix.c ****         matrix_row_t last_row_value = current_matrix[row_index];
 224:quantum/split_common/matrix.c **** 
 225:quantum/split_common/matrix.c ****         // Check row pin state
 226:quantum/split_common/matrix.c ****         if (readPin(row_pins[row_index])) {
 227:quantum/split_common/matrix.c ****             // Pin HI, clear col bit
 228:quantum/split_common/matrix.c ****             current_matrix[row_index] &= ~(ROW_SHIFTER << current_col);
 229:quantum/split_common/matrix.c ****         } else {
 230:quantum/split_common/matrix.c ****             // Pin LO, set col bit
 231:quantum/split_common/matrix.c ****             current_matrix[row_index] |= (ROW_SHIFTER << current_col);
 232:quantum/split_common/matrix.c ****         }
 233:quantum/split_common/matrix.c **** 
 234:quantum/split_common/matrix.c ****         // Determine if the matrix changed state
 235:quantum/split_common/matrix.c ****         if ((last_row_value != current_matrix[row_index]) && !(matrix_changed)) {
 236:quantum/split_common/matrix.c ****             matrix_changed = true;
 237:quantum/split_common/matrix.c ****         }
 238:quantum/split_common/matrix.c ****     }
 239:quantum/split_common/matrix.c **** 
 240:quantum/split_common/matrix.c ****     // Unselect col
 241:quantum/split_common/matrix.c ****     unselect_col(current_col);
 242:quantum/split_common/matrix.c **** 
 243:quantum/split_common/matrix.c ****     return matrix_changed;
 244:quantum/split_common/matrix.c **** }
 245:quantum/split_common/matrix.c **** 
 246:quantum/split_common/matrix.c **** #endif
 247:quantum/split_common/matrix.c **** 
 248:quantum/split_common/matrix.c **** void matrix_init(void) {
 288               		.loc 1 248 0
 289               		.cfi_startproc
 290 0000 CF93      		push r28
 291               	.LCFI3:
 292               		.cfi_def_cfa_offset 3
 293               		.cfi_offset 28, -2
 294 0002 DF93      		push r29
 295               	.LCFI4:
 296               		.cfi_def_cfa_offset 4
 297               		.cfi_offset 29, -3
 298               	/* prologue: function */
 299               	/* frame size = 0 */
 300               	/* stack size = 2 */
 301               	.L__stack_usage = 2
 249:quantum/split_common/matrix.c ****     keyboard_split_setup();
 302               		.loc 1 249 0
 303 0004 0E94 0000 		call keyboard_split_setup
 304               	.LVL15:
 250:quantum/split_common/matrix.c **** 
 251:quantum/split_common/matrix.c ****     // Set pinout for right half if pinout for that half is defined
 252:quantum/split_common/matrix.c ****     if (!isLeftHand) {
 305               		.loc 1 252 0
 306 0008 8091 0000 		lds r24,isLeftHand
 253:quantum/split_common/matrix.c **** #ifdef DIRECT_PINS_RIGHT
 254:quantum/split_common/matrix.c ****         const pin_t direct_pins_right[MATRIX_ROWS][MATRIX_COLS] = DIRECT_PINS_RIGHT;
 255:quantum/split_common/matrix.c ****         for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 256:quantum/split_common/matrix.c ****             for (uint8_t j = 0; j < MATRIX_COLS; j++) {
 257:quantum/split_common/matrix.c ****                 direct_pins[i][j] = direct_pins_right[i][j];
 258:quantum/split_common/matrix.c ****             }
 259:quantum/split_common/matrix.c ****         }
 260:quantum/split_common/matrix.c **** #endif
 261:quantum/split_common/matrix.c **** #ifdef MATRIX_ROW_PINS_RIGHT
 262:quantum/split_common/matrix.c ****         const pin_t row_pins_right[MATRIX_ROWS] = MATRIX_ROW_PINS_RIGHT;
 263:quantum/split_common/matrix.c ****         for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 264:quantum/split_common/matrix.c ****             row_pins[i] = row_pins_right[i];
 265:quantum/split_common/matrix.c ****         }
 266:quantum/split_common/matrix.c **** #endif
 267:quantum/split_common/matrix.c **** #ifdef MATRIX_COL_PINS_RIGHT
 268:quantum/split_common/matrix.c ****         const pin_t col_pins_right[MATRIX_COLS] = MATRIX_COL_PINS_RIGHT;
 269:quantum/split_common/matrix.c ****         for (uint8_t i = 0; i < MATRIX_COLS; i++) {
 270:quantum/split_common/matrix.c ****             col_pins[i] = col_pins_right[i];
 271:quantum/split_common/matrix.c ****         }
 272:quantum/split_common/matrix.c **** #endif
 273:quantum/split_common/matrix.c ****     }
 274:quantum/split_common/matrix.c **** 
 275:quantum/split_common/matrix.c ****     thisHand = isLeftHand ? 0 : (ROWS_PER_HAND);
 307               		.loc 1 275 0
 308 000c 8091 0000 		lds r24,isLeftHand
 309 0010 8111      		cpse r24,__zero_reg__
 310 0012 00C0      		rjmp .L22
 311 0014 94E0      		ldi r25,lo8(4)
 312 0016 00C0      		rjmp .L18
 313               	.L22:
 314 0018 90E0      		ldi r25,0
 315               	.L18:
 316               		.loc 1 275 0 is_stmt 0 discriminator 4
 317 001a 9093 0000 		sts thisHand,r25
 276:quantum/split_common/matrix.c ****     thatHand = ROWS_PER_HAND - thisHand;
 318               		.loc 1 276 0 is_stmt 1 discriminator 4
 319 001e 84E0      		ldi r24,lo8(4)
 320 0020 891B      		sub r24,r25
 321 0022 8093 0000 		sts thatHand,r24
 322               	.LVL16:
 323 0026 A0E0      		ldi r26,lo8(row_pins)
 324 0028 B0E0      		ldi r27,hi8(row_pins)
 325 002a 40E0      		ldi r20,lo8(row_pins+4)
 326 002c 50E0      		ldi r21,hi8(row_pins+4)
 327               	.LBB16:
 328               	.LBB17:
 329               	.LBB18:
 157:quantum/split_common/matrix.c ****     }
 330               		.loc 1 157 0 discriminator 4
 331 002e 61E0      		ldi r22,lo8(1)
 332 0030 70E0      		ldi r23,0
 333               	.LVL17:
 334               	.L19:
 157:quantum/split_common/matrix.c ****     }
 335               		.loc 1 157 0 is_stmt 0
 336 0032 8D91      		ld r24,X+
 337               	.LVL18:
 338 0034 E82F      		mov r30,r24
 339 0036 E295      		swap r30
 340 0038 EF70      		andi r30,lo8(15)
 341 003a F0E0      		ldi r31,0
 342 003c 21A1      		ldd r18,Z+33
 343 003e 8F70      		andi r24,lo8(15)
 344 0040 EB01      		movw r28,r22
 345 0042 00C0      		rjmp 2f
 346               		1:
 347 0044 CC0F      		lsl r28
 348 0046 DD1F      		rol r29
 349               		2:
 350 0048 8A95      		dec r24
 351 004a 02F4      		brpl 1b
 352 004c CE01      		movw r24,r28
 353 004e 9C2F      		mov r25,r28
 354 0050 9095      		com r25
 355 0052 9223      		and r25,r18
 356 0054 91A3      		std Z+33,r25
 357 0056 92A1      		ldd r25,Z+34
 358 0058 892B      		or r24,r25
 359 005a 82A3      		std Z+34,r24
 360               	.LVL19:
 156:quantum/split_common/matrix.c ****         setPinInputHigh(row_pins[x]);
 361               		.loc 1 156 0 is_stmt 1
 362 005c 4A17      		cp r20,r26
 363 005e 5B07      		cpc r21,r27
 364 0060 01F4      		brne .L19
 365 0062 A0E0      		ldi r26,lo8(col_pins)
 366 0064 B0E0      		ldi r27,hi8(col_pins)
 367               	.LVL20:
 368 0066 40E0      		ldi r20,lo8(col_pins+7)
 369 0068 50E0      		ldi r21,hi8(col_pins+7)
 370               	.LBE18:
 371               	.LBE17:
 372               	.LBB19:
 164:quantum/split_common/matrix.c ****     }
 373               		.loc 1 164 0
 374 006a 61E0      		ldi r22,lo8(1)
 375 006c 70E0      		ldi r23,0
 376               	.L20:
 377               	.LVL21:
 378 006e 8D91      		ld r24,X+
 379               	.LVL22:
 380 0070 E82F      		mov r30,r24
 381 0072 E295      		swap r30
 382 0074 EF70      		andi r30,lo8(15)
 383 0076 F0E0      		ldi r31,0
 384 0078 21A1      		ldd r18,Z+33
 385 007a 8F70      		andi r24,lo8(15)
 386 007c EB01      		movw r28,r22
 387 007e 00C0      		rjmp 2f
 388               		1:
 389 0080 CC0F      		lsl r28
 390 0082 DD1F      		rol r29
 391               		2:
 392 0084 8A95      		dec r24
 393 0086 02F4      		brpl 1b
 394 0088 CE01      		movw r24,r28
 395 008a 9C2F      		mov r25,r28
 396 008c 9095      		com r25
 397 008e 9223      		and r25,r18
 398 0090 91A3      		std Z+33,r25
 399 0092 92A1      		ldd r25,Z+34
 400 0094 892B      		or r24,r25
 401 0096 82A3      		std Z+34,r24
 402               	.LVL23:
 163:quantum/split_common/matrix.c ****         setPinInputHigh(col_pins[x]);
 403               		.loc 1 163 0
 404 0098 4A17      		cp r20,r26
 405 009a 5B07      		cpc r21,r27
 406 009c 01F4      		brne .L20
 407 009e E0E0      		ldi r30,lo8(matrix)
 408 00a0 F0E0      		ldi r31,hi8(matrix)
 409 00a2 80E0      		ldi r24,lo8(matrix+8)
 410 00a4 90E0      		ldi r25,hi8(matrix+8)
 411               	.L21:
 412               	.LVL24:
 413               	.LBE19:
 414               	.LBE16:
 415               	.LBB20:
 277:quantum/split_common/matrix.c **** 
 278:quantum/split_common/matrix.c ****     // initialize key pins
 279:quantum/split_common/matrix.c ****     init_pins();
 280:quantum/split_common/matrix.c **** 
 281:quantum/split_common/matrix.c ****     // initialize matrix state: all keys off
 282:quantum/split_common/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 283:quantum/split_common/matrix.c ****         matrix[i] = 0;
 416               		.loc 1 283 0 discriminator 3
 417 00a6 1192      		st Z+,__zero_reg__
 418               	.LVL25:
 282:quantum/split_common/matrix.c ****         matrix[i] = 0;
 419               		.loc 1 282 0 discriminator 3
 420 00a8 8E17      		cp r24,r30
 421 00aa 9F07      		cpc r25,r31
 422 00ac 01F4      		brne .L21
 423               	.LBE20:
 284:quantum/split_common/matrix.c ****     }
 285:quantum/split_common/matrix.c **** 
 286:quantum/split_common/matrix.c ****     debounce_init(ROWS_PER_HAND);
 424               		.loc 1 286 0
 425 00ae 84E0      		ldi r24,lo8(4)
 426 00b0 0E94 0000 		call debounce_init
 427               	.LVL26:
 428               	/* epilogue start */
 287:quantum/split_common/matrix.c **** 
 288:quantum/split_common/matrix.c ****     matrix_init_quantum();
 289:quantum/split_common/matrix.c **** }
 429               		.loc 1 289 0
 430 00b4 DF91      		pop r29
 431 00b6 CF91      		pop r28
 288:quantum/split_common/matrix.c **** }
 432               		.loc 1 288 0
 433 00b8 0C94 0000 		jmp matrix_init_quantum
 434               	.LVL27:
 435               		.cfi_endproc
 436               	.LFE37:
 438               		.section	.text._matrix_scan,"ax",@progbits
 439               	.global	_matrix_scan
 441               	_matrix_scan:
 442               	.LFB38:
 290:quantum/split_common/matrix.c **** 
 291:quantum/split_common/matrix.c **** uint8_t _matrix_scan(void) {
 443               		.loc 1 291 0
 444               		.cfi_startproc
 445 0000 6F92      		push r6
 446               	.LCFI5:
 447               		.cfi_def_cfa_offset 3
 448               		.cfi_offset 6, -2
 449 0002 7F92      		push r7
 450               	.LCFI6:
 451               		.cfi_def_cfa_offset 4
 452               		.cfi_offset 7, -3
 453 0004 8F92      		push r8
 454               	.LCFI7:
 455               		.cfi_def_cfa_offset 5
 456               		.cfi_offset 8, -4
 457 0006 9F92      		push r9
 458               	.LCFI8:
 459               		.cfi_def_cfa_offset 6
 460               		.cfi_offset 9, -5
 461 0008 AF92      		push r10
 462               	.LCFI9:
 463               		.cfi_def_cfa_offset 7
 464               		.cfi_offset 10, -6
 465 000a BF92      		push r11
 466               	.LCFI10:
 467               		.cfi_def_cfa_offset 8
 468               		.cfi_offset 11, -7
 469 000c CF92      		push r12
 470               	.LCFI11:
 471               		.cfi_def_cfa_offset 9
 472               		.cfi_offset 12, -8
 473 000e DF92      		push r13
 474               	.LCFI12:
 475               		.cfi_def_cfa_offset 10
 476               		.cfi_offset 13, -9
 477 0010 EF92      		push r14
 478               	.LCFI13:
 479               		.cfi_def_cfa_offset 11
 480               		.cfi_offset 14, -10
 481 0012 FF92      		push r15
 482               	.LCFI14:
 483               		.cfi_def_cfa_offset 12
 484               		.cfi_offset 15, -11
 485 0014 0F93      		push r16
 486               	.LCFI15:
 487               		.cfi_def_cfa_offset 13
 488               		.cfi_offset 16, -12
 489 0016 1F93      		push r17
 490               	.LCFI16:
 491               		.cfi_def_cfa_offset 14
 492               		.cfi_offset 17, -13
 493 0018 CF93      		push r28
 494               	.LCFI17:
 495               		.cfi_def_cfa_offset 15
 496               		.cfi_offset 28, -14
 497 001a DF93      		push r29
 498               	.LCFI18:
 499               		.cfi_def_cfa_offset 16
 500               		.cfi_offset 29, -15
 501               	/* prologue: function */
 502               	/* frame size = 0 */
 503               	/* stack size = 14 */
 504               	.L__stack_usage = 14
 505               	.LVL28:
 506 001c 60E0      		ldi r22,lo8(row_pins)
 507 001e 70E0      		ldi r23,hi8(row_pins)
 508 0020 A0E0      		ldi r26,lo8(raw_matrix)
 509 0022 B0E0      		ldi r27,hi8(raw_matrix)
 510 0024 20E0      		ldi r18,lo8(raw_matrix+4)
 511 0026 A22E      		mov r10,r18
 512 0028 20E0      		ldi r18,hi8(raw_matrix+4)
 513 002a B22E      		mov r11,r18
 292:quantum/split_common/matrix.c ****     bool changed = false;
 514               		.loc 1 292 0
 515 002c 712C      		mov r7,__zero_reg__
 516               	.LBB31:
 517               	.LBB32:
 518               	.LBB33:
 519               	.LBB34:
 520               	.LBB35:
 149:quantum/split_common/matrix.c ****     writePinLow(row_pins[row]);
 521               		.loc 1 149 0
 522 002e 01E0      		ldi r16,lo8(1)
 523 0030 10E0      		ldi r17,0
 524               	.LVL29:
 525               	.L30:
 526 0032 6D01      		movw r12,r26
 527               	.LBE35:
 528               	.LBE34:
 170:quantum/split_common/matrix.c **** 
 529               		.loc 1 170 0
 530 0034 9C90      		ld r9,X
 531               	.LVL30:
 173:quantum/split_common/matrix.c **** 
 532               		.loc 1 173 0
 533 0036 1C92      		st X,__zero_reg__
 534               	.LVL31:
 535               	.LBB37:
 536               	.LBB36:
 149:quantum/split_common/matrix.c ****     writePinLow(row_pins[row]);
 537               		.loc 1 149 0
 538 0038 EB01      		movw r28,r22
 539 003a 8991      		ld r24,Y+
 540 003c BE01      		movw r22,r28
 541 003e E82F      		mov r30,r24
 542 0040 E295      		swap r30
 543 0042 EF70      		andi r30,lo8(15)
 544 0044 F0E0      		ldi r31,0
 545 0046 21A1      		ldd r18,Z+33
 546 0048 8F70      		andi r24,lo8(15)
 547 004a A801      		movw r20,r16
 548 004c 00C0      		rjmp 2f
 549               		1:
 550 004e 440F      		lsl r20
 551 0050 551F      		rol r21
 552               		2:
 553 0052 8A95      		dec r24
 554 0054 02F4      		brpl 1b
 555 0056 CA01      		movw r24,r20
 556 0058 242B      		or r18,r20
 557 005a 21A3      		std Z+33,r18
 150:quantum/split_common/matrix.c **** }
 558               		.loc 1 150 0
 559 005c 22A1      		ldd r18,Z+34
 560 005e 642E      		mov r6,r20
 561 0060 6094      		com r6
 562 0062 2621      		and r18,r6
 563 0064 22A3      		std Z+34,r18
 564               	.LVL32:
 565               	.LBE36:
 566               	.LBE37:
 567               	.LBB38:
 568               	.LBB39:
 569               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 570               		.loc 2 276 0
 571 0066 50EA      		ldi r21,lo8(-96)
 572 0068 5A95      	1:	dec r21
 573 006a 01F4      		brne 1b
 574               	.LVL33:
 575 006c 90E0      		ldi r25,lo8(col_pins)
 576 006e E92E      		mov r14,r25
 577 0070 90E0      		ldi r25,hi8(col_pins)
 578 0072 F92E      		mov r15,r25
 579 0074 40E0      		ldi r20,0
 580 0076 50E0      		ldi r21,0
 581               	.LVL34:
 582               	.L28:
 583               	.LBE39:
 584               	.LBE38:
 585               	.LBB40:
 182:quantum/split_common/matrix.c ****     }
 586               		.loc 1 182 0
 587 0078 E701      		movw r28,r14
 588 007a 8990      		ld r8,Y+
 589 007c 7E01      		movw r14,r28
 590 007e 282D      		mov r18,r8
 591 0080 2295      		swap r18
 592 0082 2F70      		andi r18,lo8(15)
 593 0084 30E0      		ldi r19,0
 594 0086 E901      		movw r28,r18
 595 0088 28A1      		ldd r18,Y+32
 596 008a 30E0      		ldi r19,0
 597 008c D82D      		mov r29,r8
 598 008e DF70      		andi r29,lo8(15)
 599 0090 00C0      		rjmp 2f
 600               		1:
 601 0092 3595      		asr r19
 602 0094 2795      		ror r18
 603               		2:
 604 0096 DA95      		dec r29
 605 0098 02F4      		brpl 1b
 606 009a 20FD      		sbrc r18,0
 607 009c 00C0      		rjmp .L31
 608 009e 9801      		movw r18,r16
 609 00a0 042E      		mov r0,r20
 610 00a2 00C0      		rjmp 2f
 611               		1:
 612 00a4 220F      		lsl r18
 613               		2:
 614 00a6 0A94      		dec r0
 615 00a8 02F4      		brpl 1b
 616 00aa 00C0      		rjmp .L27
 617               	.L31:
 618 00ac 20E0      		ldi r18,0
 619 00ae 30E0      		ldi r19,0
 620               	.L27:
 621 00b0 3C91      		ld r19,X
 622 00b2 232B      		or r18,r19
 623 00b4 2C93      		st X,r18
 624               	.LVL35:
 625 00b6 4F5F      		subi r20,-1
 626 00b8 5F4F      		sbci r21,-1
 627               	.LVL36:
 180:quantum/split_common/matrix.c ****         // Populate the matrix row with the state of the col pin
 628               		.loc 1 180 0
 629 00ba 4730      		cpi r20,7
 630 00bc 5105      		cpc r21,__zero_reg__
 631 00be 01F4      		brne .L28
 632               	.LVL37:
 633               	.LBE40:
 634               	.LBB41:
 635               	.LBB42:
 153:quantum/split_common/matrix.c **** 
 636               		.loc 1 153 0
 637 00c0 91A1      		ldd r25,Z+33
 638 00c2 D62D      		mov r29,r6
 639 00c4 D923      		and r29,r25
 640 00c6 D1A3      		std Z+33,r29
 641 00c8 92A1      		ldd r25,Z+34
 642 00ca 892B      		or r24,r25
 643 00cc 82A3      		std Z+34,r24
 644               	.LVL38:
 645 00ce 1196      		adiw r26,1
 646               	.LVL39:
 647               	.LBE42:
 648               	.LBE41:
 649               	.LBE33:
 650               	.LBE32:
 293:quantum/split_common/matrix.c **** 
 294:quantum/split_common/matrix.c **** #if defined(DIRECT_PINS) || (DIODE_DIRECTION == COL2ROW)
 295:quantum/split_common/matrix.c ****     // Set row, read cols
 296:quantum/split_common/matrix.c ****     for (uint8_t current_row = 0; current_row < ROWS_PER_HAND; current_row++) {
 297:quantum/split_common/matrix.c ****         changed |= read_cols_on_row(raw_matrix, current_row);
 651               		.loc 1 297 0
 652 00d0 81E0      		ldi r24,lo8(1)
 653 00d2 F601      		movw r30,r12
 654 00d4 9081      		ld r25,Z
 655 00d6 9911      		cpse r25,r9
 656 00d8 00C0      		rjmp .L29
 657 00da 80E0      		ldi r24,0
 658               	.L29:
 659 00dc 782A      		or r7,r24
 660               	.LVL40:
 296:quantum/split_common/matrix.c ****         changed |= read_cols_on_row(raw_matrix, current_row);
 661               		.loc 1 296 0
 662 00de AA16      		cp r10,r26
 663 00e0 BB06      		cpc r11,r27
 664 00e2 01F0      		breq .+2
 665 00e4 00C0      		rjmp .L30
 666               	.LBE31:
 298:quantum/split_common/matrix.c ****     }
 299:quantum/split_common/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
 300:quantum/split_common/matrix.c ****     // Set col, read rows
 301:quantum/split_common/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 302:quantum/split_common/matrix.c ****         changed |= read_rows_on_col(raw_matrix, current_col);
 303:quantum/split_common/matrix.c ****     }
 304:quantum/split_common/matrix.c **** #endif
 305:quantum/split_common/matrix.c **** 
 306:quantum/split_common/matrix.c ****     debounce(raw_matrix, matrix + thisHand, ROWS_PER_HAND, changed);
 667               		.loc 1 306 0
 668 00e6 6091 0000 		lds r22,thisHand
 669 00ea 70E0      		ldi r23,0
 670 00ec 6050      		subi r22,lo8(-(matrix))
 671 00ee 7040      		sbci r23,hi8(-(matrix))
 672 00f0 272D      		mov r18,r7
 673 00f2 44E0      		ldi r20,lo8(4)
 674 00f4 80E0      		ldi r24,lo8(raw_matrix)
 675 00f6 90E0      		ldi r25,hi8(raw_matrix)
 676 00f8 0E94 0000 		call debounce
 677               	.LVL41:
 307:quantum/split_common/matrix.c **** 
 308:quantum/split_common/matrix.c ****     return (uint8_t)changed;
 309:quantum/split_common/matrix.c **** }
 678               		.loc 1 309 0
 679 00fc 872D      		mov r24,r7
 680               	/* epilogue start */
 681 00fe DF91      		pop r29
 682 0100 CF91      		pop r28
 683 0102 1F91      		pop r17
 684 0104 0F91      		pop r16
 685 0106 FF90      		pop r15
 686 0108 EF90      		pop r14
 687 010a DF90      		pop r13
 688 010c CF90      		pop r12
 689               	.LVL42:
 690 010e BF90      		pop r11
 691 0110 AF90      		pop r10
 692 0112 9F90      		pop r9
 693 0114 8F90      		pop r8
 694 0116 7F90      		pop r7
 695               	.LVL43:
 696 0118 6F90      		pop r6
 697 011a 0895      		ret
 698               		.cfi_endproc
 699               	.LFE38:
 701               		.section	.text.matrix_scan,"ax",@progbits
 702               	.global	matrix_scan
 704               	matrix_scan:
 705               	.LFB39:
 310:quantum/split_common/matrix.c **** 
 311:quantum/split_common/matrix.c **** uint8_t matrix_scan(void) {
 706               		.loc 1 311 0
 707               		.cfi_startproc
 708 0000 CF93      		push r28
 709               	.LCFI19:
 710               		.cfi_def_cfa_offset 3
 711               		.cfi_offset 28, -2
 712               	/* prologue: function */
 713               	/* frame size = 0 */
 714               	/* stack size = 1 */
 715               	.L__stack_usage = 1
 312:quantum/split_common/matrix.c ****     uint8_t ret = _matrix_scan();
 716               		.loc 1 312 0
 717 0002 0E94 0000 		call _matrix_scan
 718               	.LVL44:
 719 0006 C82F      		mov r28,r24
 720               	.LVL45:
 313:quantum/split_common/matrix.c **** 
 314:quantum/split_common/matrix.c ****     if (is_keyboard_master()) {
 721               		.loc 1 314 0
 722 0008 0E94 0000 		call is_keyboard_master
 723               	.LVL46:
 724 000c 8823      		tst r24
 725 000e 01F0      		breq .L35
 726               	.LBB43:
 315:quantum/split_common/matrix.c ****         static uint8_t error_count;
 316:quantum/split_common/matrix.c **** 
 317:quantum/split_common/matrix.c ****         if (!transport_master(matrix + thatHand)) {
 727               		.loc 1 317 0
 728 0010 8091 0000 		lds r24,thatHand
 729 0014 90E0      		ldi r25,0
 730 0016 8050      		subi r24,lo8(-(matrix))
 731 0018 9040      		sbci r25,hi8(-(matrix))
 732 001a 0E94 0000 		call transport_master
 733               	.LVL47:
 734 001e 8111      		cpse r24,__zero_reg__
 735 0020 00C0      		rjmp .L36
 318:quantum/split_common/matrix.c ****             error_count++;
 736               		.loc 1 318 0
 737 0022 8091 0000 		lds r24,error_count.3713
 738 0026 8F5F      		subi r24,lo8(-(1))
 739 0028 8093 0000 		sts error_count.3713,r24
 319:quantum/split_common/matrix.c **** 
 320:quantum/split_common/matrix.c ****             if (error_count > ERROR_DISCONNECT_COUNT) {
 740               		.loc 1 320 0
 741 002c 8630      		cpi r24,lo8(6)
 742 002e 00F0      		brlo .L38
 743               	.LBB44:
 321:quantum/split_common/matrix.c ****                 // reset other half if disconnected
 322:quantum/split_common/matrix.c ****                 for (int i = 0; i < ROWS_PER_HAND; ++i) {
 323:quantum/split_common/matrix.c ****                     matrix[thatHand + i] = 0;
 744               		.loc 1 323 0
 745 0030 E091 0000 		lds r30,thatHand
 746 0034 F0E0      		ldi r31,0
 747               	.LVL48:
 748 0036 E050      		subi r30,lo8(-(matrix))
 749 0038 F040      		sbci r31,hi8(-(matrix))
 750 003a 1082      		st Z,__zero_reg__
 751               	.LVL49:
 752 003c 1182      		std Z+1,__zero_reg__
 753               	.LVL50:
 754 003e 1282      		std Z+2,__zero_reg__
 755               	.LVL51:
 756 0040 1382      		std Z+3,__zero_reg__
 757               	.LVL52:
 758 0042 00C0      		rjmp .L38
 759               	.LVL53:
 760               	.L36:
 761               	.LBE44:
 324:quantum/split_common/matrix.c ****                 }
 325:quantum/split_common/matrix.c ****             }
 326:quantum/split_common/matrix.c ****         } else {
 327:quantum/split_common/matrix.c ****             error_count = 0;
 762               		.loc 1 327 0
 763 0044 1092 0000 		sts error_count.3713,__zero_reg__
 764               	.L38:
 328:quantum/split_common/matrix.c ****         }
 329:quantum/split_common/matrix.c **** 
 330:quantum/split_common/matrix.c ****         matrix_scan_quantum();
 765               		.loc 1 330 0
 766 0048 0E94 0000 		call matrix_scan_quantum
 767               	.LVL54:
 768               	.LBE43:
 769 004c 00C0      		rjmp .L40
 770               	.L35:
 331:quantum/split_common/matrix.c ****     } else {
 332:quantum/split_common/matrix.c ****         transport_slave(matrix + thisHand);
 771               		.loc 1 332 0
 772 004e 8091 0000 		lds r24,thisHand
 773 0052 90E0      		ldi r25,0
 774 0054 8050      		subi r24,lo8(-(matrix))
 775 0056 9040      		sbci r25,hi8(-(matrix))
 776 0058 0E94 0000 		call transport_slave
 777               	.LVL55:
 333:quantum/split_common/matrix.c **** #ifdef ENCODER_ENABLE
 334:quantum/split_common/matrix.c ****         encoder_read();
 335:quantum/split_common/matrix.c **** #endif
 336:quantum/split_common/matrix.c ****         matrix_slave_scan_user();
 778               		.loc 1 336 0
 779 005c 0E94 0000 		call matrix_slave_scan_user
 780               	.LVL56:
 781               	.L40:
 337:quantum/split_common/matrix.c ****     }
 338:quantum/split_common/matrix.c **** 
 339:quantum/split_common/matrix.c ****     return ret;
 340:quantum/split_common/matrix.c **** }
 782               		.loc 1 340 0
 783 0060 8C2F      		mov r24,r28
 784               	/* epilogue start */
 785 0062 CF91      		pop r28
 786               	.LVL57:
 787 0064 0895      		ret
 788               		.cfi_endproc
 789               	.LFE39:
 791               		.section	.bss.error_count.3713,"aw",@nobits
 794               	error_count.3713:
 795 0000 00        		.zero	1
 796               		.comm	thatHand,1,1
 797               		.comm	thisHand,1,1
 798               		.section	.bss.raw_matrix,"aw",@nobits
 801               	raw_matrix:
 802 0000 0000 0000 		.zero	4
 803               		.section	.bss.matrix,"aw",@nobits
 806               	matrix:
 807 0000 0000 0000 		.zero	8
 807      0000 0000 
 808               		.section	.rodata.col_pins,"a",@progbits
 811               	col_pins:
 812 0000 36        		.byte	54
 813 0001 32        		.byte	50
 814 0002 33        		.byte	51
 815 0003 31        		.byte	49
 816 0004 F7        		.byte	-9
 817 0005 F6        		.byte	-10
 818 0006 F5        		.byte	-11
 819               		.section	.rodata.row_pins,"a",@progbits
 822               	row_pins:
 823 0000 97        		.byte	-105
 824 0001 C6        		.byte	-58
 825 0002 34        		.byte	52
 826 0003 35        		.byte	53
 827 0004 0000 0000 		.zero	4
 828               		.text
 829               	.Letext0:
 830               		.file 3 "/usr/lib/avr/include/stdint.h"
 831               		.file 4 "tmk_core/common/matrix.h"
 832               		.file 5 "tmk_core/common/report.h"
 833               		.file 6 "quantum/quantum.h"
 834               		.file 7 "quantum/split_common/split_util.h"
 835               		.file 8 "tmk_core/common/action_util.h"
 836               		.file 9 "quantum/debounce.h"
 837               		.file 10 "tmk_core/common/util.h"
 838               		.file 11 "quantum/split_common/transport.h"
 839               		.file 12 "tmk_core/common/keyboard.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/cc1hPXM2.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc1hPXM2.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc1hPXM2.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc1hPXM2.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc1hPXM2.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc1hPXM2.s:13     .text.matrix_slave_scan_user:0000000000000000 matrix_slave_scan_user
     /tmp/cc1hPXM2.s:13     .text.matrix_slave_scan_user:0000000000000000 matrix_slave_scan_user.localalias.0
     /tmp/cc1hPXM2.s:30     .text.matrix_scan_user:0000000000000000 matrix_scan_user
     /tmp/cc1hPXM2.s:44     .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
     /tmp/cc1hPXM2.s:61     .text.matrix_init_user:0000000000000000 matrix_init_user
     /tmp/cc1hPXM2.s:75     .text.matrix_init_kb:0000000000000000 matrix_init_kb
     /tmp/cc1hPXM2.s:92     .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/cc1hPXM2.s:109    .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/cc1hPXM2.s:126    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/cc1hPXM2.s:147    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/cc1hPXM2.s:806    .bss.matrix:0000000000000000 matrix
     /tmp/cc1hPXM2.s:188    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/cc1hPXM2.s:211    .text.matrix_print:0000000000000000 matrix_print
     /tmp/cc1hPXM2.s:227    .text.matrix_key_count:0000000000000000 matrix_key_count
     /tmp/cc1hPXM2.s:286    .text.matrix_init:0000000000000000 matrix_init
                            *COM*:0000000000000001 thisHand
                            *COM*:0000000000000001 thatHand
     /tmp/cc1hPXM2.s:822    .rodata.row_pins:0000000000000000 row_pins
     /tmp/cc1hPXM2.s:811    .rodata.col_pins:0000000000000000 col_pins
     /tmp/cc1hPXM2.s:441    .text._matrix_scan:0000000000000000 _matrix_scan
     /tmp/cc1hPXM2.s:801    .bss.raw_matrix:0000000000000000 raw_matrix
     /tmp/cc1hPXM2.s:704    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/cc1hPXM2.s:794    .bss.error_count.3713:0000000000000000 error_count.3713

UNDEFINED SYMBOLS
debounce_active
bitpop
keyboard_split_setup
isLeftHand
debounce_init
matrix_init_quantum
debounce
is_keyboard_master
transport_master
matrix_scan_quantum
transport_slave
__do_copy_data
__do_clear_bss
